import type { LoadContext, Plugin } from '@docusaurus/types';
import * as fs from 'node:fs';
import * as path from 'node:path';

interface CheckExamplesOptions {
  strict?: boolean;
  include?: string[];
  exclude?: string[];
}

interface CodeBlock {
  code: string;
  lang: string;
  filePath: string;
  lineNumber: number;
  annotation: string;
  testPath?: string;
  strict?: boolean;
}

interface VerificationError {
  mdxFile: string;
  lineNumber: number;
  code: string;
  testPath: string;
  message: string;
}

/**
 * Normalize TypeScript/JavaScript code for comparison:
 * Remove single-line comments, multi-line comments, and collapse whitespace
 */
function normalizeCode(code: string): string {
  return code
    // Remove single-line comments
    .replace(/\/\/.*$/gm, '')
    // Remove multi-line comments
    .replace(/\/\*[\s\S]*?\*\//g, '')
    // Collapse whitespace
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Check if code should use normalization or strict matching
 */
function shouldNormalize(lang: string, strict: boolean): boolean {
  if (strict) return false;
  return lang === 'typescript' || lang === 'ts' || lang === 'javascript' || lang === 'js';
}

/**
 * Parse annotation to extract test path and options
 * Examples:
 *   @check-example('path/to/test.ts')
 *   @check-example('path/to/test.ts', { strict: true })
 */
function parseAnnotation(annotation: string): { testPath: string; strict: boolean } | null {
  const match = annotation.match(/@check-example\(['"]([^'"]+)['"]\s*(,\s*{[^}]*strict:\s*true[^}]*})?\s*\)/);
  if (!match) return null;
  
  return {
    testPath: match[1],
    strict: !!match[2],
  };
}

/**
 * Infer test path from .mdx file location
 * Examples:
 *   website/docs/utils/route-do-request.mdx ‚Üí packages/utils/test/route-do-request.test.ts
 *   website/docs/rpc/quick-start.mdx ‚Üí packages/rpc/test/quick-start.test.ts
 */
function inferTestPath(mdxFilePath: string): string | undefined {
  // Match: docs/<package>/<filename>.mdx
  const match = mdxFilePath.match(/docs\/([^/]+)\/([^/]+)\.mdx$/);
  if (!match) return undefined;
  
  const [, packageName, filename] = match;
  
  // Skip API docs (generated by typedoc)
  if (filename === 'api' || mdxFilePath.includes('/api/')) {
    return undefined;
  }
  
  // Convert kebab-case to kebab-case for test files
  return `packages/${packageName}/test/${filename}.test.ts`;
}

/**
 * Extract annotated code blocks from .mdx content
 */
function extractCodeBlocks(content: string, filePath: string): CodeBlock[] {
  const blocks: CodeBlock[] = [];
  const lines = content.split('\n');
  
  let inCodeBlock = false;
  let currentBlock: { lang: string; code: string[]; startLine: number; fenceLine: string } | null = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Start of code block
    const codeBlockStart = line.match(/^```(\w+)/);
    if (codeBlockStart && !inCodeBlock) {
      inCodeBlock = true;
      currentBlock = {
        lang: codeBlockStart[1],
        code: [],
        startLine: i + 1,
        fenceLine: line,
      };
      continue;
    }
    
    // End of code block
    if (line.startsWith('```') && inCodeBlock && currentBlock) {
      inCodeBlock = false;
      
      // Check fence line for @skip-check
      if (currentBlock.fenceLine.includes('@skip-check')) {
        currentBlock = null;
        continue;
      }
      
      // Check first line of code for @skip-check (backward compatibility)
      if (currentBlock.code.length > 0 && currentBlock.code[0].includes('@skip-check')) {
        currentBlock = null;
        continue;
      }
      
      // Determine test path - either explicit or derived from file location
      let testPath: string | undefined;
      let strict = false;
      let annotation = '';
      
      // Check fence line for explicit @check-example
      if (currentBlock.fenceLine.includes('@check-example')) {
        const parsed = parseAnnotation(currentBlock.fenceLine);
        if (parsed) {
          testPath = parsed.testPath;
          strict = parsed.strict;
          annotation = currentBlock.fenceLine;
        }
      }
      // Check first line of code for explicit @check-example (backward compatibility)
      else if (currentBlock.code.length > 0 && currentBlock.code[0].includes('@check-example')) {
        const firstCodeLine = currentBlock.code[0];
        const parsed = parseAnnotation(firstCodeLine);
        if (parsed) {
          testPath = parsed.testPath;
          strict = parsed.strict;
          annotation = firstCodeLine;
          // Remove the annotation line from the code
          currentBlock.code = currentBlock.code.slice(1);
        }
      }
      // Default: infer test path from .mdx file location
      else {
        testPath = inferTestPath(filePath);
        annotation = '(inferred from file path)';
      }
      
      if (testPath) {
        blocks.push({
          code: currentBlock.code.join('\n'),
          lang: currentBlock.lang,
          filePath,
          lineNumber: currentBlock.startLine,
          annotation,
          testPath,
          strict,
        });
      }
      
      currentBlock = null;
      continue;
    }
    
    // Inside code block
    if (inCodeBlock && currentBlock) {
      currentBlock.code.push(line);
    }
  }
  
  return blocks;
}

/**
 * Verify a code block against its test file
 */
function verifyCodeBlock(
  block: CodeBlock,
  testFileCache: Map<string, string>,
  repoRoot: string
): VerificationError | null {
  if (!block.testPath) return null;
  
  // Resolve test file path relative to repo root
  const fullTestPath = path.join(repoRoot, block.testPath);
  
  // Read test file (with caching if easy)
  let testContent: string;
  if (testFileCache.has(fullTestPath)) {
    testContent = testFileCache.get(fullTestPath)!;
  } else {
    try {
      testContent = fs.readFileSync(fullTestPath, 'utf-8');
      testFileCache.set(fullTestPath, testContent);
    } catch (error) {
      return {
        mdxFile: block.filePath,
        lineNumber: block.lineNumber,
        code: block.code,
        testPath: block.testPath,
        message: `Test file not found: ${fullTestPath}`,
      };
    }
  }
  
  // Normalize or use strict matching
  const useNormalization = shouldNormalize(block.lang, block.strict || false);
  
  const docCode = useNormalization ? normalizeCode(block.code) : block.code;
  const testCode = useNormalization ? normalizeCode(testContent) : testContent;
  
  // Check if doc code exists in test code
  if (!testCode.includes(docCode)) {
    return {
      mdxFile: block.filePath,
      lineNumber: block.lineNumber,
      code: block.code,
      testPath: block.testPath,
      message: 'Code not found in test file',
    };
  }
  
  return null;
}

/**
 * Find all .mdx files in a directory
 */
function findMdxFiles(dir: string, exclude: string[] = []): string[] {
  const files: string[] = [];
  
  function walk(currentDir: string) {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);
      
      // Skip excluded paths
      if (exclude.some(pattern => fullPath.includes(pattern))) {
        continue;
      }
      
      if (entry.isDirectory()) {
        walk(fullPath);
      } else if (entry.name.endsWith('.mdx')) {
        files.push(fullPath);
      }
    }
  }
  
  walk(dir);
  return files;
}

/**
 * Check if file has doc-testing frontmatter (skip if generated)
 */
function isGeneratedByDocTesting(content: string): boolean {
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) return false;
  
  return frontmatterMatch[1].includes('generated_by: doc-testing');
}

/**
 * Main plugin function
 */
export default function pluginCheckExamples(
  context: LoadContext,
  options: CheckExamplesOptions = {}
): Plugin {
  return {
    name: 'docusaurus-plugin-check-examples',
    
    async postBuild({ outDir }) {
      const startTime = Date.now();
      console.log('\nüîç Checking code examples...\n');
      
      const repoRoot = context.siteDir.replace(/\/website$/, '');
      const docsDir = path.join(context.siteDir, 'docs');
      
      // Find all .mdx files
      const mdxFiles = findMdxFiles(docsDir, options.exclude);
      
      const testFileCache = new Map<string, string>();
      const errors: VerificationError[] = [];
      let checkedBlocks = 0;
      let skippedFiles = 0;
      
      for (const mdxFile of mdxFiles) {
        const content = fs.readFileSync(mdxFile, 'utf-8');
        
        // Skip doc-testing generated files (they're already verified)
        if (isGeneratedByDocTesting(content)) {
          skippedFiles++;
          continue;
        }
        
        // Skip API documentation (generated by TypeDoc)
        if (mdxFile.includes('/api/')) {
          skippedFiles++;
          continue;
        }
        
        // Extract code blocks
        const blocks = extractCodeBlocks(content, mdxFile);
        
        // Verify each block
        for (const block of blocks) {
          checkedBlocks++;
          const error = verifyCodeBlock(block, testFileCache, repoRoot);
          if (error) {
            errors.push(error);
          }
        }
      }
      
      const elapsed = Date.now() - startTime;
      
      // Report results
      if (errors.length === 0) {
        console.log(`‚úÖ All ${checkedBlocks} code examples verified successfully!`);
        console.log(`   Checked ${mdxFiles.length} files (${skippedFiles} generated, ${mdxFiles.length - skippedFiles} hand-written)`);
        console.log(`   Completed in ${elapsed}ms\n`);
      } else {
        console.error(`\n‚ùå Found ${errors.length} example verification error(s):\n`);
        
        for (const error of errors) {
          const relPath = error.mdxFile.replace(context.siteDir, 'website');
          console.error(`üìÑ ${relPath}:${error.lineNumber}`);
          console.error(`   Test: ${error.testPath}`);
          console.error(`   Error: ${error.message}\n`);
          console.error(`   Expected code:`);
          console.error(`   ${error.code.split('\n').join('\n   ')}\n`);
          console.error(`   Possible issues:`);
          console.error(`   - Function renamed? Check test file for similar patterns`);
          console.error(`   - API changed? Update example to match current implementation`);
          console.error(`   - Test file moved? Update @check-example path\n`);
        }
        
        console.error(`Completed in ${elapsed}ms\n`);
        throw new Error(`${errors.length} code example(s) failed verification`);
      }
    },
  };
}
