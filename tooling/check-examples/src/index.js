import * as fs from 'node:fs';
import * as path from 'node:path';

/**
 * @typedef {Object} CheckExamplesOptions
 * @property {boolean} [strict] - Use strict (exact) matching for all code blocks
 * @property {string[]} [include] - File patterns to include
 * @property {string[]} [exclude] - File patterns to exclude
 */

/**
 * @typedef {Object} CodeBlock
 * @property {string} code - The code content
 * @property {string} lang - Language identifier (typescript, javascript, etc)
 * @property {string} filePath - Path to the .mdx file
 * @property {number} lineNumber - Line number where code block starts
 * @property {string} annotation - Annotation string from fence or comment
 * @property {string} [testPath] - Path to test file to check against
 * @property {boolean} [strict] - Whether to use strict matching for this block
 */

/**
 * @typedef {Object} VerificationError
 * @property {string} mdxFile - Path to .mdx file with error
 * @property {number} lineNumber - Line number of code block
 * @property {string} code - Code that failed verification
 * @property {string} testPath - Path to test file
 * @property {string} message - Error message
 */

/**
 * Normalize TypeScript/JavaScript code for comparison:
 * Remove imports, comments, type parameters, and collapse whitespace
 * Supports // ... as a wildcard to skip intervening code
 * @param {string} code - Code to normalize
 * @returns {string} Normalized code
 */
function normalizeCode(code) {
  return code
    // Remove import statements (allows docs to show @lumenize/package imports while tests use relative paths)
    .replace(/^import\s+.*?from\s+['"].*?['"];?\s*$/gm, '')
    // Remove export statements from the beginning (export default, export const, etc.)
    .replace(/^export\s+(default\s+)?(class|function|const|let|var|type|interface|enum)\s+/gm, '$2 ')
    // Remove type parameters from class/interface declarations (e.g., DurableObject<Env> → DurableObject)
    .replace(/(class|interface|type)\s+(\w+)<[^>]+>/g, '$1 $2')
    // Remove generic type parameters from extends/implements (e.g., extends DurableObject<Env> → extends DurableObject)
    .replace(/extends\s+(\w+)<[^>]+>/g, 'extends $1')
    .replace(/implements\s+(\w+)<[^>]+>/g, 'implements $1')
    // Replace // ... with a unique placeholder before removing other comments
    .replace(/\/\/\s*\.\.\.\s*$/gm, '___ELLIPSIS___')
    // Remove single-line comments
    .replace(/\/\/.*$/gm, '')
    // Remove multi-line comments
    .replace(/\/\*[\s\S]*?\*\//g, '')
    // Collapse whitespace (including newlines)
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Check if code should use normalization or strict matching
 * @param {string} lang - Language identifier
 * @param {boolean} strict - Strict mode flag
 * @returns {boolean}
 */
function shouldNormalize(lang, strict) {
  if (strict) return false;
  return lang === 'typescript' || lang === 'ts' || lang === 'javascript' || lang === 'js';
}

/**
 * Parse annotation to extract test path and options
 * Examples:
 *   @check-example('path/to/test.ts')
 *   @check-example('path/to/test.ts', { strict: true })
 * @param {string} annotation - Annotation string to parse
 * @returns {{ testPath: string; strict: boolean } | null}
 */
function parseAnnotation(annotation) {
  const match = annotation.match(/@check-example\(['"]([^'"]+)['"]\s*(,\s*{[^}]*strict:\s*true[^}]*})?\s*\)/);
  if (!match) return null;
  
  return {
    testPath: match[1],
    strict: !!match[2],
  };
}

/**
 * Infer test path from .mdx file location
 * Examples:
 *   website/docs/utils/route-do-request.mdx → packages/utils/test/route-do-request.test.ts
 *   website/docs/rpc/quick-start.mdx → packages/rpc/test/quick-start.test.ts
 * @param {string} mdxFilePath - Path to .mdx file
 * @returns {string | undefined}
 */
function inferTestPath(mdxFilePath) {
  // Match: docs/<package>/<filename>.mdx
  const match = mdxFilePath.match(/docs\/([^/]+)\/([^/]+)\.mdx$/);
  if (!match) return undefined;
  
  const [, packageName, filename] = match;
  
  // Skip API docs (generated by typedoc)
  if (filename === 'api' || mdxFilePath.includes('/api/')) {
    return undefined;
  }
  
  // Convert kebab-case to kebab-case for test files
  return `packages/${packageName}/test/${filename}.test.ts`;
}

/**
 * Extract annotated code blocks from .mdx content
 * @param {string} content - .mdx file content
 * @param {string} filePath - Path to .mdx file
 * @returns {CodeBlock[]}
 */
function extractCodeBlocks(content, filePath) {
  const blocks = [];
  const lines = content.split('\n');
  
  let inCodeBlock = false;
  let currentBlock = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Start of code block
    const codeBlockStart = line.match(/^```(\w+)/);
    if (codeBlockStart && !inCodeBlock) {
      inCodeBlock = true;
      currentBlock = {
        lang: codeBlockStart[1],
        code: [],
        startLine: i + 1,
        fenceLine: line,
      };
      continue;
    }
    
    // End of code block
    if (line.startsWith('```') && inCodeBlock && currentBlock) {
      inCodeBlock = false;
      
      // Check fence line for @skip-check
      if (currentBlock.fenceLine.includes('@skip-check')) {
        currentBlock = null;
        continue;
      }
      
      // Check first line of code for @skip-check (backward compatibility)
      if (currentBlock.code.length > 0 && currentBlock.code[0].includes('@skip-check')) {
        currentBlock = null;
        continue;
      }
      
      // Determine test path - either explicit or derived from file location
      let testPath;
      let strict = false;
      let annotation = '';
      
      // Check fence line for explicit @check-example
      if (currentBlock.fenceLine.includes('@check-example')) {
        const parsed = parseAnnotation(currentBlock.fenceLine);
        if (parsed) {
          testPath = parsed.testPath;
          strict = parsed.strict;
          annotation = currentBlock.fenceLine;
        }
      }
      // Check first line of code for explicit @check-example (backward compatibility)
      else if (currentBlock.code.length > 0 && currentBlock.code[0].includes('@check-example')) {
        const firstCodeLine = currentBlock.code[0];
        const parsed = parseAnnotation(firstCodeLine);
        if (parsed) {
          testPath = parsed.testPath;
          strict = parsed.strict;
          annotation = firstCodeLine;
          // Remove the annotation line from the code
          currentBlock.code = currentBlock.code.slice(1);
        }
      }
      // Default: infer test path from .mdx file location
      else {
        testPath = inferTestPath(filePath);
        annotation = '(inferred from file path)';
      }
      
      if (testPath) {
        blocks.push({
          code: currentBlock.code.join('\n'),
          lang: currentBlock.lang,
          filePath,
          lineNumber: currentBlock.startLine,
          annotation,
          testPath,
          strict,
        });
      }
      
      currentBlock = null;
      continue;
    }
    
    // Inside code block
    if (inCodeBlock && currentBlock) {
      currentBlock.code.push(line);
    }
  }
  
  return blocks;
}

/**
 * Verify a code block against its test file
 * @param {CodeBlock} block - Code block to verify
 * @param {Map<string, string>} testFileCache - Cache of test file contents
 * @param {string} repoRoot - Repository root path
 * @returns {VerificationError | null}
 */
function verifyCodeBlock(block, testFileCache, repoRoot) {
  if (!block.testPath) return null;
  
  // Resolve test file path relative to repo root
  const fullTestPath = path.join(repoRoot, block.testPath);
  
  // Read test file (with caching)
  let testContent;
  if (testFileCache.has(fullTestPath)) {
    testContent = testFileCache.get(fullTestPath);
  } else {
    try {
      testContent = fs.readFileSync(fullTestPath, 'utf-8');
      testFileCache.set(fullTestPath, testContent);
    } catch (error) {
      return {
        mdxFile: block.filePath,
        lineNumber: block.lineNumber,
        code: block.code,
        testPath: block.testPath,
        message: `Test file not found: ${fullTestPath}`,
      };
    }
  }
  
  // Normalize or use strict matching
  const useNormalization = shouldNormalize(block.lang, block.strict || false);
  
  const docCode = useNormalization ? normalizeCode(block.code) : block.code;
  const testCode = useNormalization ? normalizeCode(testContent) : testContent;
  
  // Check if doc code contains ellipsis wildcards
  if (docCode.includes('___ELLIPSIS___')) {
    // Convert to regex pattern, escaping special chars except our placeholder
    const pattern = docCode
      .split('___ELLIPSIS___')
      .map(part => part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
      .join('.*?'); // Non-greedy wildcard
    
    const regex = new RegExp(pattern, 's'); // s flag for dotAll (. matches newlines)
    
    if (!regex.test(testCode)) {
      return {
        mdxFile: block.filePath,
        lineNumber: block.lineNumber,
        code: block.code,
        testPath: block.testPath,
        message: 'Code pattern not found in test file',
      };
    }
  } else {
    // Simple substring match
    if (!testCode.includes(docCode)) {
      return {
        mdxFile: block.filePath,
        lineNumber: block.lineNumber,
        code: block.code,
        testPath: block.testPath,
        message: 'Code not found in test file',
      };
    }
  }
  
  return null;
}

/**
 * Find all .mdx files in a directory
 * @param {string} dir - Directory to search
 * @param {string[]} exclude - Patterns to exclude
 * @returns {string[]}
 */
function findMdxFiles(dir, exclude = []) {
  const files = [];
  
  function walk(currentDir) {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);
      
      // Skip excluded paths
      if (exclude.some(pattern => fullPath.includes(pattern))) {
        continue;
      }
      
      if (entry.isDirectory()) {
        walk(fullPath);
      } else if (entry.name.endsWith('.mdx')) {
        files.push(fullPath);
      }
    }
  }
  
  walk(dir);
  return files;
}

/**
 * Check if file has doc-testing frontmatter (skip if generated)
 * @param {string} content - File content
 * @returns {boolean}
 */
function isGeneratedByDocTesting(content) {
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) return false;
  
  return frontmatterMatch[1].includes('generated_by: doc-testing');
}

/**
 * Main plugin function
 * @param {import('@docusaurus/types').LoadContext} context - Docusaurus context
 * @param {CheckExamplesOptions} options - Plugin options
 * @returns {import('@docusaurus/types').Plugin}
 */
export default function pluginCheckExamples(context, options = {}) {
  return {
    name: 'docusaurus-plugin-check-examples',
    
    async postBuild({ outDir }) {
      const startTime = Date.now();
      console.log('\n🔍 Checking code examples...\n');
      
      const repoRoot = context.siteDir.replace(/\/website$/, '');
      const docsDir = path.join(context.siteDir, 'docs');
      
      // Find all .mdx files
      const mdxFiles = findMdxFiles(docsDir, options.exclude);
      
      const testFileCache = new Map();
      const errors = [];
      let checkedBlocks = 0;
      let skippedFiles = 0;
      
      for (const mdxFile of mdxFiles) {
        const content = fs.readFileSync(mdxFile, 'utf-8');
        
        // Skip doc-testing generated files (they're already verified)
        if (isGeneratedByDocTesting(content)) {
          skippedFiles++;
          continue;
        }
        
        // Skip API documentation (generated by TypeDoc)
        if (mdxFile.includes('/api/')) {
          skippedFiles++;
          continue;
        }
        
        // Extract code blocks
        const blocks = extractCodeBlocks(content, mdxFile);
        
        // Verify each block
        for (const block of blocks) {
          checkedBlocks++;
          const error = verifyCodeBlock(block, testFileCache, repoRoot);
          if (error) {
            errors.push(error);
          }
        }
      }
      
      const elapsed = Date.now() - startTime;
      
      // Report results
      if (errors.length === 0) {
        console.log(`✅ All ${checkedBlocks} code examples verified successfully!`);
        console.log(`   Checked ${mdxFiles.length} files (${skippedFiles} generated, ${mdxFiles.length - skippedFiles} hand-written)`);
        console.log(`   Completed in ${elapsed}ms\n`);
      } else {
        console.error(`\n❌ Found ${errors.length} example verification error(s):\n`);
        
        for (const error of errors) {
          const relPath = error.mdxFile.replace(context.siteDir, 'website');
          console.error(`📄 ${relPath}:${error.lineNumber}`);
          console.error(`   Test: ${error.testPath}`);
          console.error(`   Error: ${error.message}\n`);
          console.error(`   Expected code:`);
          console.error(`   ${error.code.split('\n').join('\n   ')}\n`);
          console.error(`   Possible issues:`);
          console.error(`   - Function renamed? Check test file for similar patterns`);
          console.error(`   - API changed? Update example to match current implementation`);
          console.error(`   - Test file moved? Update @check-example path\n`);
        }
        
        console.error(`Completed in ${elapsed}ms\n`);
        throw new Error(`${errors.length} code example(s) failed verification`);
      }
    },
  };
}
