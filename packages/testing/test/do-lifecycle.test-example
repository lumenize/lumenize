import { describe, test, it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types are not consistently recognized by VS Code
import { SELF } from 'cloudflare:test';
import { 
  checkServerAvailability, 
  createMaybeIt, 
  MessageBuilders, 
  ExpectedResponses,
  createMockConnection 
} from '@lumenize/testing';

describe('Comprehensive Entity Subscription Lifecycle', () => {

  test('complete entity lifecycle with subscription notifications', async () => {
    await runTestWithLumenize(async (instance, mock, state) => {
      // URI router for constructing test URIs
      const uriRouter = new EntityUriRouter();
      
      // Clear any previous state
      mock.clearNotifications();
      mock.clearMessages();

      const startTime = performance.now();

      // === PHASE 1: Entity Type Creation ===
      const createEntityTypeMessage = MessageBuilders.toolCall(1, 'add-entity-type', {
        name: 'comprehensive-test-entity',
        version: 1,
        jsonSchema: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            status: { type: 'string' },
            metadata: { 
              type: 'object',
              properties: {
                version: { type: 'number' },
                tags: { type: 'array', items: { type: 'string' } }
              }
            },
            counters: {
              type: 'object',
              properties: {
                views: { type: 'number' },
                updates: { type: 'number' }
              }
            }
          },
          required: ['name', 'status']
        },
        description: 'A comprehensive test entity for subscription testing'
      });

      await instance.onMessage(mock.connection, createEntityTypeMessage);
      const result1 = mock.getMessageById(1);
      expect(result1.result.structuredContent.success).toBe(true);

      // === PHASE 2: Create Test Entity ===
      const entityId = 'test-entity-123';
      const entityData = {
        name: 'Comprehensive Test Entity',
        status: 'active',
        metadata: { version: 1, tags: ['test', 'comprehensive'] },
        counters: { views: 0, updates: 0 }
      };

      const createEntityMessage = MessageBuilders.toolCall(2, 'upsert-entity', {
        entityId,
        entityTypeName: 'comprehensive-test-entity',
        entityTypeVersion: 1,
        changedBy: [{ userId: 'test-user' }],
        parentId: 'test-parent',
        value: entityData
      });

      await instance.onMessage(mock.connection, createEntityMessage);
      const result2 = mock.getMessageById(2);
      if (result2.error) {
        console.log('Entity creation error:', result2.error);
        throw new Error(`Entity creation failed: ${result2.error.message}`);
      }

      // Debug: Check the actual response structure
      console.log('Entity creation response structure:', JSON.stringify(result2, null, 2));

      // Verify upsert-entity returns all public metadata fields
      expect(result2.result.structuredContent.success).toBe(true);
      expect(result2.result.structuredContent.entityId).toBe(entityId);
      expect(result2.result.structuredContent.validFrom).toBeDefined();
      expect(result2.result.structuredContent.validTo).toBe('9999-01-01T00:00:00.000Z');
      expect(result2.result.structuredContent.changedBy).toEqual([{ userId: 'test-user' }]);
      expect(result2.result.structuredContent.value).toEqual(entityData);
      expect(result2.result.structuredContent.deleted).toBe(false);
      expect(result2.result.structuredContent.parentId).toBe('test-parent');
      expect(result2.result.structuredContent.entityTypeName).toBe('comprehensive-test-entity');
      expect(result2.result.structuredContent.entityTypeVersion).toBe(1);
      
      // Capture the original creation timestamp directly from the upsert response
      const originalCreationTimestamp = result2.result.structuredContent.validFrom;
      console.log('Original creation timestamp from upsert:', originalCreationTimestamp);

      // === PHASE 3: Subscribe to Entity Changes ===
      const subscribeMessage = {
        jsonrpc: '2.0',
        id: 3,
        method: 'resources/subscribe',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(subscribeMessage));
      const subscribeResponse = mock.getLastMessage();
      expect(subscribeResponse).toBeDefined();
      
      const subscribeResult = JSON.parse(subscribeResponse);
      expect(subscribeResult.id).toBe(3);
      if (subscribeResult.error) {
        console.log('Subscription error:', subscribeResult.error);
        throw new Error(`Subscription failed: ${subscribeResult.error.message}`);
      }
      // For resources/subscribe, expect a result indicating success
      expect(subscribeResult.result).toBeDefined();

      // Clear notifications to start fresh
      mock.clearNotifications();

      // === PHASE 4: Update Entity (should trigger notification) ===
      const updateData = {
        name: 'Updated Comprehensive Test Entity',
        status: 'updated',
        metadata: { version: 2, tags: ['test', 'comprehensive', 'modified'] },
        counters: { views: 5, updates: 1 }
      };

      const updateEntityMessage = MessageBuilders.toolCall(4, 'upsert-entity', {
        entityId,
        entityTypeName: 'comprehensive-test-entity',
        entityTypeVersion: 1,
        changedBy: [{ userId: 'test-user' }],
        parentId: 'test-parent',
        value: updateData
      });

      await instance.onMessage(mock.connection, updateEntityMessage);
      const result3 = mock.getMessageById(4);
      if (result3.error) {
        console.log('Entity update error:', result3.error);
        throw new Error(`Entity update failed: ${result3.error.message}`);
      }

      // Verify upsert-entity update returns all public metadata fields
      expect(result3.result.structuredContent.success).toBe(true);
      expect(result3.result.structuredContent.entityId).toBe(entityId);
      expect(result3.result.structuredContent.validFrom).toBeDefined();
      expect(result3.result.structuredContent.validTo).toBe('9999-01-01T00:00:00.000Z');
      expect(result3.result.structuredContent.changedBy).toEqual([{ userId: 'test-user' }]);
      expect(result3.result.structuredContent.value).toEqual(updateData);
      expect(result3.result.structuredContent.deleted).toBe(false);
      expect(result3.result.structuredContent.parentId).toBe('test-parent');
      expect(result3.result.structuredContent.entityTypeName).toBe('comprehensive-test-entity');
      expect(result3.result.structuredContent.entityTypeVersion).toBe(1);
      
      console.log('Updated entity timestamp from upsert:', result3.result.structuredContent.validFrom);

      // Verify update notification was received
      const updateNotifications = mock.getNotifications();
      expect(updateNotifications).toHaveLength(1);
      const updateNotification = updateNotifications[0];
      expect(updateNotification.method).toBe('notifications/resources/updated');
      expect(updateNotification.params.uri).toBe(uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
        domain: 'lumenize',
        universe: 'default',
        galaxy: 'default',
        star: 'default',
        id: entityId
      }));
      
      // Verify the notification includes the actual updated entity data
      expect(updateNotification.params.title).toContain('comprehensive-test-entity');
      expect(updateNotification.params.data).toBeDefined();
      expect(updateNotification.params.data.entityId).toBe(entityId);
      expect(updateNotification.params.data.value).toEqual(updateData);
      expect(updateNotification.params.data.deleted).toBe(false);
      expect(updateNotification.params.data.entityTypeName).toBe('comprehensive-test-entity');
      expect(updateNotification.params.data.entityTypeVersion).toBe(1);

      // Clear notifications for next phase
      mock.clearNotifications();

      // === PHASE 5: Read Entity to Verify Update ===
      const readEntityMessage = {
        jsonrpc: '2.0',
        id: 5,
        method: 'resources/read',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(readEntityMessage));
      const response4 = mock.getLastMessage();
      expect(response4).toBeDefined();
      
      const result4 = JSON.parse(response4);
      expect(result4.id).toBe(5);
      expect(result4.result.contents).toHaveLength(1);
      const entitySnapshot = JSON.parse(result4.result.contents[0].text);
      expect(entitySnapshot.value).toEqual(updateData); // Use the update data

      console.log('Updated entity timestamp:', entitySnapshot.validFrom);

      // === PHASE 5.5: PATCH_READ - Test PATCH_READ functionality ===
      // Test 1: Invalid baseline should fail
      const invalidBaseline = '2024-01-01T00:00:00.000Z';
      const invalidPatchReadMessage = {
        jsonrpc: '2.0',
        id: 51,
        method: 'resources/read',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.PATCH_READ, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId,
            baseline: invalidBaseline
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(invalidPatchReadMessage));
      const invalidPatchResponse = mock.getLastMessage();
      const invalidPatchResult = JSON.parse(invalidPatchResponse);
      expect(invalidPatchResult.error).toBeDefined();
      expect(invalidPatchResult.error.message).toContain('Snapshot not found');

      // Test 2: Valid baseline from original creation (should have non-empty patch showing changes)
      const originalPatchReadMessage = {
        jsonrpc: '2.0',
        id: 52,
        method: 'resources/read',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.PATCH_READ, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId,
            baseline: originalCreationTimestamp
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(originalPatchReadMessage));
      const originalPatchResponse = mock.getLastMessage();
      expect(originalPatchResponse).toBeDefined();
      
      const originalPatchResult = JSON.parse(originalPatchResponse);
      expect(originalPatchResult.id).toBe(52);
      expect(originalPatchResult.error).toBeUndefined();
      
      // PATCH_READ should succeed and show actual changes
      expect(originalPatchResult.result.contents).toHaveLength(1);
      const originalPatchData = JSON.parse(originalPatchResult.result.contents[0].text);
      
      console.log('PATCH_READ from original creation, data:', JSON.stringify(originalPatchData, null, 2));
      
      // Verify the response structure
      expect(originalPatchData.baseline).toBe(originalCreationTimestamp);
      expect(originalPatchData.entityId).toBe(entityId);
      
      // Since we're comparing original creation to updated version,
      // patch should contain the actual differences
      expect(originalPatchData.patch).toBeDefined();
      expect(Object.keys(originalPatchData.patch).length).toBeGreaterThan(0);
      
      // Verify specific changes in the patch
      expect(originalPatchData.patch.name).toBe('Updated Comprehensive Test Entity');
      expect(originalPatchData.patch.status).toBe('updated');
      expect(originalPatchData.patch.metadata.version).toBe(2); // Now version 2 due to the update
      expect(originalPatchData.patch.metadata.tags).toEqual(['test', 'comprehensive', 'modified']);
      expect(originalPatchData.patch.counters.views).toBe(5);
      expect(originalPatchData.patch.counters.updates).toBe(1);

      // Test 3: Valid baseline from current entity (should succeed but have empty patch)
      const baseline = entitySnapshot.validFrom;
      console.log('Using baseline timestamp from current entity:', baseline);
      
      const patchReadMessage = {
        jsonrpc: '2.0',
        id: 55,
        method: 'resources/read',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.PATCH_READ, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId,
            baseline: baseline
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(patchReadMessage));
      const patchResponse = mock.getLastMessage();
      expect(patchResponse).toBeDefined();
      
      const patchResult = JSON.parse(patchResponse);
      expect(patchResult.id).toBe(55);
      expect(patchResult.error).toBeUndefined();
      
      // PATCH_READ should succeed
      expect(patchResult.result.contents).toHaveLength(1);
      const patchData = JSON.parse(patchResult.result.contents[0].text);
      
      console.log('PATCH_READ from same timestamp, data:', JSON.stringify(patchData, null, 2));
      
      // Verify the response structure
      expect(patchData.baseline).toBe(baseline);
      expect(patchData.entityId).toBe(entityId);
      
      // Since we're using the current entity's validFrom as baseline,
      // there should be no changes, so patch should be an empty object
      expect(patchData.patch).toEqual({});

      // === PHASE 5.7: HISTORICAL_READ - Test reading at specific timestamp ===
      // Calculate a timestamp halfway between creation and update
      const creationTime = new Date(originalCreationTimestamp).getTime();
      const updateTime = new Date(result3.result.structuredContent.validFrom).getTime();
      const timeDifference = updateTime - creationTime;
      const halfwayTime = creationTime + Math.floor(timeDifference / 2)
      const halfwayTimestamp = new Date(halfwayTime).toISOString();
      
      const historicalReadMessage = {
        jsonrpc: '2.0',
        id: 57,
        method: 'resources/read',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.HISTORICAL, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId,
            timestamp: halfwayTimestamp
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(historicalReadMessage));
      const historicalResponse = mock.getLastMessage();
      expect(historicalResponse).toBeDefined();
      
      const historicalResult = JSON.parse(historicalResponse);
      expect(historicalResult.id).toBe(57);
      expect(historicalResult.error).toBeUndefined();
      
      // Historical read should succeed and return the original entity data
      expect(historicalResult.result.contents).toHaveLength(1);
      const historicalSnapshot = JSON.parse(historicalResult.result.contents[0].text);
      
      console.log('Historical read data:', JSON.stringify(historicalSnapshot, null, 2));
      
      // Verify that we get the original entity data (before the update)
      expect(historicalSnapshot.entityId).toBe(entityId);
      expect(historicalSnapshot.value).toEqual(entityData); // Should be original data, not updated data
      expect(historicalSnapshot.validFrom).toBe(originalCreationTimestamp);
      expect(historicalSnapshot.validTo).toBe(result3.result.structuredContent.validFrom); // Should end when update began
      expect(historicalSnapshot.deleted).toBe(false);
      expect(historicalSnapshot.parentId).toBe('test-parent');
      expect(historicalSnapshot.entityTypeName).toBe('comprehensive-test-entity');
      expect(historicalSnapshot.entityTypeVersion).toBe(1);

      // === PHASE 6: Delete Entity (should trigger notification) ===
      const deleteEntityMessage = MessageBuilders.toolCall(6, 'delete-entity', {
        entityId,
        changedBy: [{ userId: 'test-user' }]
      });

      await instance.onMessage(mock.connection, deleteEntityMessage);
      const result5 = mock.getMessageById(6);
      if (result5.error) {
        console.log('Entity deletion error:', result5.error);
        throw new Error(`Entity deletion failed: ${result5.error.message}`);
      }

      // Verify delete-entity returns all public metadata fields
      expect(result5.result.structuredContent.success).toBe(true);
      expect(result5.result.structuredContent.entityId).toBe(entityId);
      expect(result5.result.structuredContent.validFrom).toBeDefined();
      expect(result5.result.structuredContent.validTo).toBe('9999-01-01T00:00:00.000Z');
      expect(result5.result.structuredContent.changedBy).toEqual([{ userId: 'test-user' }]);
      expect(result5.result.structuredContent.value).toEqual(updateData); // Value remains from last update
      expect(result5.result.structuredContent.deleted).toBe(true);
      expect(result5.result.structuredContent.parentId).toBe('test-parent');
      expect(result5.result.structuredContent.entityTypeName).toBe('comprehensive-test-entity');
      expect(result5.result.structuredContent.entityTypeVersion).toBe(1);
      
      console.log('Deleted entity timestamp from delete:', result5.result.structuredContent.validFrom);

      // Verify deletion notification was received
      const deleteNotifications = mock.getNotifications();
      expect(deleteNotifications).toHaveLength(1); // Regular subscription notification only receive notifications
      console.log('Delete notifications received:', deleteNotifications.length);
      
      // Find the delete notification (should only be the regular one now)
      const deleteNotification = deleteNotifications[0];
      
      // Verify delete notification
      expect(deleteNotification).toBeDefined();
      expect(deleteNotification.method).toBe('notifications/resources/updated');
      expect(deleteNotification.params.uri).toBe(uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
        domain: 'lumenize',
        universe: 'default',
        galaxy: 'default',
        star: 'default',
        id: entityId
      }));
      
      // Verify the deletion notification includes the entity data with deleted=true
      expect(deleteNotification.params.data).toBeDefined();
      expect(deleteNotification.params.data.entityId).toBe(entityId);
      expect(deleteNotification.params.data.value).toEqual(updateData); // Value remains from last update
      expect(deleteNotification.params.data.deleted).toBe(true);
      expect(deleteNotification.params.data.entityTypeName).toBe('comprehensive-test-entity');
      expect(deleteNotification.params.data.entityTypeVersion).toBe(1);

      // Clear notifications for next phase
      mock.clearNotifications();

      // === PHASE 7: Verify Entity Was Deleted ===
      const readDeletedEntityMessage = {
        jsonrpc: '2.0',
        id: 7,
        method: 'resources/read',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(readDeletedEntityMessage));
      const result6 = mock.getMessageById(7);
      expect(result6.error).toBeDefined();
      expect(result6.error.message).toContain('deleted');

      // === PHASE 8: Undelete Entity (should trigger notification) ===
      const undeleteEntityMessage = MessageBuilders.toolCall(8, 'undelete-entity', {
        entityId,
        changedBy: [{ userId: 'test-user' }]
      });

      await instance.onMessage(mock.connection, undeleteEntityMessage);
      const result7 = mock.getMessageById(8);
      if (result7.error) {
        console.log('Entity undelete error:', result7.error);
        throw new Error(`Entity undelete failed: ${result7.error.message}`);
      }

      // Verify undelete-entity returns all public metadata fields
      expect(result7.result.structuredContent.success).toBe(true);
      expect(result7.result.structuredContent.entityId).toBe(entityId);
      expect(result7.result.structuredContent.validFrom).toBeDefined();
      expect(result7.result.structuredContent.validTo).toBe('9999-01-01T00:00:00.000Z');
      expect(result7.result.structuredContent.changedBy).toEqual([{ userId: 'test-user' }]);
      expect(result7.result.structuredContent.value).toEqual(updateData); // Value remains from last update
      expect(result7.result.structuredContent.deleted).toBe(false);
      expect(result7.result.structuredContent.parentId).toBe('test-parent');
      expect(result7.result.structuredContent.entityTypeName).toBe('comprehensive-test-entity');
      expect(result7.result.structuredContent.entityTypeVersion).toBe(1);
      
      console.log('Undeleted entity timestamp from undelete:', result7.result.structuredContent.validFrom);

      // Verify undelete notification was received
      const undeleteNotifications = mock.getNotifications();
      expect(undeleteNotifications).toHaveLength(1); // Only regular subscription notification
      console.log('Undelete notifications received:', undeleteNotifications.length);
      
      // Find the undelete notification
      const undeleteNotification = undeleteNotifications[0];
      
      // Verify undelete notification
      expect(undeleteNotification).toBeDefined();
      expect(undeleteNotification.method).toBe('notifications/resources/updated');
      expect(undeleteNotification.params.uri).toBe(uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
        domain: 'lumenize',
        universe: 'default',
        galaxy: 'default',
        star: 'default',
        id: entityId
      }));
      
      // Verify the undelete notification includes the entity data with deleted=false
      expect(undeleteNotification.params.data).toBeDefined();
      expect(undeleteNotification.params.data.entityId).toBe(entityId);
      expect(undeleteNotification.params.data.value).toEqual(updateData); // Value remains from last update
      expect(undeleteNotification.params.data.deleted).toBe(false);
      expect(undeleteNotification.params.data.entityTypeName).toBe('comprehensive-test-entity');
      expect(undeleteNotification.params.data.entityTypeVersion).toBe(1);

      // === PHASE 8.4: Unsubscribe from regular subscription ===
      const regularUnsubscribeMessage = {
        jsonrpc: '2.0',
        id: 47,
        method: 'resources/unsubscribe',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(regularUnsubscribeMessage));
      const regularUnsubscribeResponse = mock.getLastMessage();
      const regularUnsubscribeResult = JSON.parse(regularUnsubscribeResponse);
      expect(regularUnsubscribeResult.error).toBeUndefined();

      // === PHASE 8.5: HTTP Read via onRequest ===
      // Test reading entity data via HTTP GET request instead of MCP
      const httpUrl = uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
        domain: 'lumenize',
        universe: 'default',
        galaxy: 'default',
        star: 'default',
        id: entityId
      });
      const httpRequest = new Request(httpUrl, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        }
      });

      const httpResponse = instance.onRequest(httpRequest);
      expect(httpResponse).toBeDefined();
      expect(httpResponse.status).toBe(200);
      
      // Parse the HTTP response body
      const httpResponseText = await httpResponse.text();
      const httpEntityData = JSON.parse(httpResponseText);
      
      console.log('HTTP read response:', JSON.stringify(httpEntityData, null, 2));
      
      // Verify HTTP response contains the same entity data as MCP read
      expect(httpEntityData.entityId).toBe(entityId);
      expect(httpEntityData.value).toEqual(updateData); // Should match the updated data
      expect(httpEntityData.validFrom).toBeDefined();
      expect(httpEntityData.validTo).toBe('9999-01-01T00:00:00.000Z');
      expect(httpEntityData.changedBy).toEqual([{ userId: 'test-user' }]);
      expect(httpEntityData.deleted).toBe(false);
      expect(httpEntityData.parentId).toBe('test-parent');
      expect(httpEntityData.entityTypeName).toBe('comprehensive-test-entity');
      expect(httpEntityData.entityTypeVersion).toBe(1);
      
      // Test 404 for non-existent entity via HTTP
      const nonExistentHttpUrl = uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
        domain: 'lumenize',
        universe: 'default',
        galaxy: 'default',
        star: 'default',
        id: 'non-existent-entity'
      });
      const nonExistentHttpRequest = new Request(nonExistentHttpUrl, { method: 'GET' });
      const notFoundResponse = instance.onRequest(nonExistentHttpRequest);
      expect(notFoundResponse.status).toBe(404);
      
      const notFoundResponseText = await notFoundResponse.text();
      const notFoundData = JSON.parse(notFoundResponseText);
      expect(notFoundData.error).toBeDefined();
      expect(notFoundData.error).toContain('No entity found');

      // === PHASE 9: Unsubscribe ===
      const unsubscribeMessage = {
        jsonrpc: '2.0',
        id: 9,
        method: 'resources/unsubscribe',
        params: {
          uri: uriRouter.buildEntityUri(UriTemplateType.CURRENT_ENTITY, {
            domain: 'lumenize',
            universe: 'default',
            galaxy: 'default',
            star: 'default',
            id: entityId
          })
        }
      };

      await instance.onMessage(mock.connection, JSON.stringify(unsubscribeMessage));
      const unsubscribeResult = mock.getMessageById(9);
      expect(unsubscribeResult.result).toBeDefined();

      // Clear notifications and perform one more update to verify no notifications
      mock.clearNotifications();
      
      const finalUpdateMessage = MessageBuilders.toolCall(10, 'upsert-entity', {
        entityId,
        entityTypeName: 'comprehensive-test-entity',
        entityTypeVersion: 1,
        changedBy: [{ userId: 'test-user' }],
        parentId: 'test-parent',
        value: { ...updateData, status: 'final' }
      });

      await instance.onMessage(mock.connection, finalUpdateMessage);
      const finalResult = mock.getMessageById(10);

      // Should receive no notifications after unsubscribe
      const finalNotifications = mock.getNotifications();
      expect(finalNotifications).toHaveLength(0);

      // === PHASE 10: Performance and Coverage Verification ===
      const endTime = performance.now();
      const executionTime = endTime - startTime;
      
      // Should complete much faster than individual tests
      expect(executionTime).toBeLessThan(2000); // Increased timeout for subscription operations
      
      console.log(`Comprehensive test completed in ${executionTime.toFixed(2)}ms`);

      // Verify all core functionality was tested
      const testCoverage = {
        entityTypeCreation: result1.result.structuredContent.success,
        entityCreation: result2.result?.structuredContent?.success || !result2.error,
        subscription: subscribeResult.result !== undefined,
        entityUpdates: result3.result?.structuredContent?.success || !result3.error,
        updateNotifications: updateNotifications.length > 0,
        entityReads: entitySnapshot?.value !== undefined,
        patchReadsWithChanges: originalPatchData !== null && Object.keys(originalPatchData.patch).length > 0,
        patchReadsEmpty: patchData !== null && patchData.baseline !== undefined,
        historicalReads: historicalSnapshot !== null && historicalSnapshot.value !== undefined,
        entityDeletion: result5.result?.structuredContent?.success || !result5.error,
        deleteNotifications: deleteNotifications.length > 0,
        deletionVerification: result6.error !== undefined,
        entityUndelete: result7.result?.structuredContent?.success || !result7.error,
        undeleteNotifications: undeleteNotifications.length > 0,
        httpReads: httpEntityData !== null && httpEntityData.entityId === entityId,
        httpNotFound: notFoundResponse.status === 404,
        unsubscription: regularUnsubscribeResult.result !== undefined,
        noNotificationsAfterUnsubscribe: finalNotifications.length === 0,
        performanceTarget: executionTime < 2000
      };

      // All coverage points should be true
      Object.entries(testCoverage).forEach(([area, covered]) => {
        if (!covered) {
          throw new Error(`Coverage area '${area}' was not properly tested`);
        }
      });
    });
  }, 10000); // 10s timeout for comprehensive test
});
