# Lumenize Development Rules

> For details see AGENTS.md. For Durable Objects concepts see CLOUDFLARE_DO_GUIDE.md.

## Critical "Don't Do This" Rules

- **NEVER use pnpm or yarn** - only npm
- **NEVER use TypeScript `private`** - use `#` prefix
- **NEVER use async storage** - only `ctx.storage.kv.*` or `ctx.storage.sql.*` (not `ctx.storage.put/get`)
- **NEVER manually define Env interface** - `wrangler types` auto-generates it in `worker-configuration.d.ts`
- **NEVER use wrangler compatibility_date before "2025-09-12"**
- **NEVER commit secrets** - use root `.dev.vars` (gitignored, auto-symlinked via postinstall)
- **NEVER create temp docs** - only `/website/docs/` `.mdx` files

## Cloudflare Durable Objects - CRITICAL

**Keep DO methods synchronous** (no `async`/`await`) except:
- The lifecycle entrypoint methods are async: `fetch()`, `alarm()`, and `webSocketMessage()`
- However, all of the other functionality you need in a Durable Object (storage, etc.) is syncronous, so
- All the handlers that you call from those entrypoint methods should be synchronous

**Never use in the synchrounous handlers called by those async lifecycle methods**:
- `setTimeout()`, `setInterval()`

**Never use in a DO**:
- `this.ctx.waitUntil()`. This is only included for consistency with the Worker's API. You never need it in a DO.
- The async DO storage KV methods: `this.ctx.storage.put()`, `.get()`, etc. Rather, use the sync equivalents: `this.ctx.storage.kv.put()`,`.kv.get()`, etc.

**Why**: 
- `async` breaks input/output gates â†’ race conditions
- DOs are billed on wall clock time not CPU time. You pay for the entire time a DO is waiting on one of those async methods to complete.

**Exceptions to the above**:
- If you are designing a DO where you don't care about hibernation. For instance, ProxyFetchDO is expected to handle fetches from a large number of other DOs. It costs
- You don't need or rely upon DO input/output gate transactional behavior.
- Each invocation of an async lifecycle does a single storage operation.

**What if you want to need to do an external fetch(), setTimeout(), or make a Workers RPC call?**:
- If they are fire and forget, don't await them
- If you need a response, then use an outbox pattern with a callback handler, saving any state that handler will need in storage. Then process the outbox in the calling async lifecycle entrypoint method after your syncronous handler returns. When the response comes back, call the synchronous handler

**What if I need to make an async call in the constructor to initialize the DO?**:
- Use [`blockConcurrencyWhile()`](https://developers.cloudflare.com/durable-objects/api/state/#blockconcurrencywhile)

**Instance lifecycle**:
- Fetch from storage at handler start
- Persist before returning
- Don't rely on instance variables

## Code Patterns

- Use TypeBox for anything crossing boundaries (network/process/storage)
- TypeScript types for in-memory only
- Package.json points to `src/` in dev (modified during publish)
- Run tests: `vitest --run`
- Integration tests primary, unit tests only for complex algorithms
- For doc examples: create `test/for-docs/`, use `@check-example` annotations

## Testing Patterns

- **Prefer `vi.waitFor` over `setTimeout`** - retries until conditions are met (default 1s timeout)
- Put all related expectations inside the `vi.waitFor` callback
- This is faster, more robust, and fails fast if something is wrong
- Only use `setTimeout` if `vi.waitFor` truly won't work for your use case

## Documentation

- All docs in `/website/docs/` and `/website/sidebars.ts`
- Use `doc-testing` plugin for literate programming
- Use `check-examples` plugin to validate examples against tests
- README.md: minimal, link to lumenize.com

## Workflow

- Create task file in `tasks/[project-name].md` for multi-phase projects
- Update `tasks/backlog.md` for small standalone tasks
- Ask permission before installing npm packages
- Ask "Ready to proceed?" after each phase
- Favor breaking changes over technical debt
- When refactoring: mark one test `.only`, verify, update others
- Archive completed projects to `tasks/archive/`

