---
description: Cloudflare Durable Objects patterns - avoid race conditions and data corruption
globs:
  - "**/*.ts"
---

# Cloudflare Durable Objects Rules

Critical patterns for working with Cloudflare's Durable Objects to produce clean code that avoids race conditions and the risk of data inconsistency.

## When

When implementing or modifying any Durable Object class or method.

## Then

Follow these synchronous-first patterns to maintain Cloudflare's consistency guarantees.

## Keep DO Methods Synchronous

**Don't create `async` methods except the lifecycle entrypoint methods**:
- ✅ `fetch()` - HTTP request handler
- ✅ `alarm()` - Scheduled task handler
- ✅ `webSocketMessage()`, `webSocketClose()`, `webSocketError()` - WebSocket handlers. Note, since these don't return anything, there is often no reason for them to be async, but they are allowed to be according to Cloudlfare's interface.
- Even when creating a method whose sole purpopse is to be called by another DO via Workers RPC with something like `await this.env.MY_DO.getByName('my-instance').myMethod()` do not make `myMethod()` async. I know it sounds strange to call a non-async method with `await` but the `await` is not for the method, it's for the Workers RPC internals. Workers RPC needs to "teleport" your call over a network. The `await` is for that network requirement.

**Everything you usually need is synchronous**:
- Except for those async lifecycle entrypoint methods, all of the other functionality you need in a Durable Object (storage, etc.) is syncronous
- All the business logic handlers that you write are sychronous and called from those entrypoint methods

**Never use in you synchrounous business logic handlers called by those async lifecycle methods**:
- `setTimeout()`
- `setInterval()`
- You can't because the method is not async, but don't try to `await` anything.

**Never ever use in a DO**:
- `this.ctx.waitUntil()`. This is only included for consistency with the Worker's API. You never need it in a DO.

**Why**: 
- `async` breaks input/output gates → race conditions and risk of inconsistent state
- DOs are billed on wall clock time not CPU time. You pay for the entire time a DO is waiting on one of those async methods to complete.

**Exceptions to the above**:
- If you are designing a DO where you don't care about hibernation. For instance, ProxyFetchDO is expected to handle fetches from a large number of other DOs. It costs ~$4/month to run continuously and there is only one instance.
- You don't need or rely upon DO input/output gate transactional behavior. For instance, when each invocation of an async lifecycle entrypoint method does zero or one storage operation.

**What if you want to need to do an external fetch(), setTimeout(), or make a Workers RPC call?**:
- If they are fire and forget, you might just be able to not `await` them
- If you need a response, then use an outbox pattern with a callback handler, saving any state that handler will need in storage. Then process the outbox in the calling async lifecycle entrypoint method after your syncronous handler returns. When the response comes back, call the synchronous handler. This is how `@lumenize/proxy-fetch` and `@lumenize/alarms` work. They are implementing the outbox pattern.

**What if I need to make an async call in the constructor to initialize the DO?**:
- Use [`blockConcurrencyWhile()`](https://developers.cloudflare.com/durable-objects/api/state/#blockconcurrencywhile)

## Instance Lifecycle

Durable Objects can be evicted from memory at any time. Design accordingly:

**Always:**
- ✅ Fetch from storage at the start of each of your business logic handlers
- ✅ Persist changes to storage before returning from handler
- ✅ Minimize instance variables - only store `this.ctx`, `this.env`.
  - The big exception to this is if the in-storage representation is an expensive transformation from the in-memory representation, but then you need to take extra care in assuring memory and storage are always in sync. My sledgehammer strategy is often to wrap anything that modifies both memory and storage in a try/catch block and call `this.ctx.abort()` in the catch clause. It's usually better to modify your in-storage representation.

**Never:**
- ❌ Don't rely on in-memory state persisting between requests

**Isn't storage less efficient than in-memory?**: In theory, you'd think that but in practice, the difference is usually unmeasurable because storage is running in-process and doesn't need to make a network call and it's cached.

**Isn't it more expensive to use storage than memory?**: DO reads are so inexpensive that the cost difference is almost undetectable and the much more expensive writes are required at the end of every handler regardless to support DO eviction and hibernation.

## Key Concepts

Cloudflare Durable Objects are a globally-distributed, strongly-consistent coordination primitive. Understanding how they work is essential to using them correctly.

### Instance Model

- **Written as TypeScript classes** but instantiated by Cloudflare's runtime, not your code
- **Each DO ID is globally unique** - even name-derived IDs are unique worldwide
- **One instance per ID** - Cloudflare guarantees only one instance runs at a time globally
- **Geolocation embedded in ID** - Initial location chosen based on jurisdiction hints or proximity to creator

### Terminology

- **"Durable Object" or "DO"** = Durable Object instance (specific instantiation)
- **"DO class"** = The TypeScript class definition
- Be explicit when possible; when in doubt, "DO" means "instance"

### Storage Architecture

Each DO instance has a dedicated SQLite database (up to 10GB) accessible only to that instance.

**Three storage APIs** (use only the synchronous ones):

1. ❌ **Legacy async KV API** - NEVER USE
   - `this.ctx.storage.put()`, `this.ctx.storage.get()`, etc.
   - Deprecated, exists only for migration
   
2. ✅ **Synchronous KV API** - USE THIS
   - `this.ctx.storage.kv.put()`, `this.ctx.storage.kv.get()`, etc.
   - Same methods as legacy API but synchronous
   
3. ✅ **Synchronous SQL API** - USE THIS
   - `this.ctx.storage.sql.exec()`
   - Full SQLite-flavored SQL

### Why Synchronous Storage?

SQLite is embedded in the same process and memory space - no network hop, no context switch. This gives fundamentally different performance characteristics:
- **N+1 queries often just as fast** as joins (sometimes faster)
- **No async overhead** - synchronous code is simpler and safer
- **Automatic transactions** - all operations in a handler are atomic (unless you await an external `fetch()`, await a Workers RPC call, or use `setTimeout`/`setInterval`)
  