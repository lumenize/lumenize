---
title: Error Handling
description: Testing error scenarios and edge cases with RPC
testable: true
---

# Error Handling and Edge Cases

RPC preserves error information across the wire

## Error Preservation

Thrown errors maintain their properties through RPC:

```typescript src/index.ts
import { DurableObject } from 'cloudflare:workers';
import { lumenizeRpcDO } from '@lumenize/rpc';

class _PaymentProcessor extends DurableObject {
  processPayment(amount: number): { success: boolean; transactionId: string } {
    if (amount <= 0) {
      const error = new Error('Amount must be positive') as any;
      error.code = 'INVALID_AMOUNT';
      error.statusCode = 400;
      throw error;
    }
    
    if (amount > 10000) {
      const error = new Error('Amount exceeds limit') as any;
      error.code = 'AMOUNT_TOO_LARGE';
      error.statusCode = 400;
      error.limit = 10000;
      throw error;
    }
    
    return {
      success: true,
      transactionId: `txn_${Date.now()}`,
    };
  }

  throwString(message: string): void {
    throw message;  // String throws also work
  }
}

export const PaymentProcessor = lumenizeRpcDO(_PaymentProcessor);
```

Configure Wrangler:

```jsonc wrangler
{
  "name": "payment-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [{ "name": "PAYMENT", "class_name": "PaymentProcessor" }]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["PaymentProcessor"] }
  ]
}
```

Test error handling:

```typescript test
import { describe, it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, RpcAccessible } from '@lumenize/rpc';
import { PaymentProcessor } from '../src/index';

type PaymentProcessor = RpcAccessible<InstanceType<typeof PaymentProcessor>>;

describe('Error Handling', () => {
  it('should preserve error properties across RPC', async () => {
    const client = createRpcClient<PaymentProcessor>({
      transport: 'http',
      doBindingName: 'PAYMENT',
      doInstanceNameOrId: 'error-test',
      fetch: SELF.fetch.bind(SELF),
    });

    // Test invalid amount error
    try {
      await client.processPayment(-100);
      expect.fail('Should have thrown error');
    } catch (error: any) {
      expect(error.message).toBe('Amount must be positive');
      expect(error.code).toBe('INVALID_AMOUNT');
      expect(error.statusCode).toBe(400);
    }

    // Test amount too large error
    try {
      await client.processPayment(15000);
      expect.fail('Should have thrown error');
    } catch (error: any) {
      expect(error.message).toBe('Amount exceeds limit');
      expect(error.code).toBe('AMOUNT_TOO_LARGE');
      expect(error.limit).toBe(10000);
    }

    // Test string throw
    try {
      await client.throwString('Custom error string');
      expect.fail('Should have thrown error');
    } catch (error: any) {
      expect(error).toBe('Custom error string');
    }

    // Valid payment should succeed
    const result = await client.processPayment(100);
    expect(result.success).toBe(true);
    expect(result.transactionId).toMatch(/^txn_/);
  });
});
```

## Concurrent Request Ordering

RPC guarantees Promise.all preserves request order:

```typescript src/index.ts
import { DurableObject } from 'cloudflare:workers';
import { lumenizeRpcDO } from '@lumenize/rpc';

class _SequenceGenerator extends DurableObject {
  #counter = 0;

  next(): number {
    return ++this.#counter;
  }

  reset(): void {
    this.#counter = 0;
  }
}

export const SequenceGenerator = lumenizeRpcDO(_SequenceGenerator);
```

Test concurrent request ordering:

```typescript test
import { describe, it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim, RpcAccessible } from '@lumenize/rpc';
import { SequenceGenerator } from '../src/index';

type SequenceGenerator = RpcAccessible<InstanceType<typeof SequenceGenerator>>;

describe('Concurrent Requests', () => {
  it('should maintain request order with Promise.all', async () => {
    const client = createRpcClient<SequenceGenerator>({
      doBindingName: 'SEQUENCE',
      doInstanceNameOrId: 'order-test',
      WebSocketClass: getWebSocketShim(SELF),
    });

    // Fire many requests concurrently
    const promises = Array.from({ length: 10 }, () => client.next());
    const results = await Promise.all(promises);

    // Results should be in sequential order [1, 2, 3, ..., 10]
    expect(results).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

    await client[Symbol.asyncDispose]();
  });

  it('should handle mixed concurrent operations', async () => {
    const client = createRpcClient<SequenceGenerator>({
      doBindingName: 'SEQUENCE',
      doInstanceNameOrId: 'mixed-test',
      WebSocketClass: getWebSocketShim(SELF),
    });

    // Reset first
    await client.reset();

    // Mix different operations
    const [seq1, seq2, seq3] = await Promise.all([
      client.next(),
      client.next(),
      client.next(),
    ]);

    // All should have unique sequential values
    expect(seq1).toBe(1);
    expect(seq2).toBe(2);
    expect(seq3).toBe(3);

    await client[Symbol.asyncDispose]();
  });
});
```

## WebSocket Disconnect Handling

Test behavior when WebSocket disconnects during operations:

```typescript test
import { describe, it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim, RpcAccessible } from '@lumenize/rpc';
import { SequenceGenerator } from '../src/index';

type SequenceGenerator = RpcAccessible<InstanceType<typeof SequenceGenerator>>;

describe('Disconnect Handling', () => {
  it('should reject pending operations on disconnect', async () => {
    const client = createRpcClient<SequenceGenerator>({
      doBindingName: 'SEQUENCE',
      doInstanceNameOrId: 'disconnect-test',
      WebSocketClass: getWebSocketShim(SELF),
    });

    // Start operation
    const promise = client.next();

    // Immediately disconnect
    await client[Symbol.asyncDispose]();

    // Operation should reject
    await expect(promise).rejects.toThrow();
  });

  it('should auto-reconnect after disconnect', async () => {
    const client = createRpcClient<SequenceGenerator>({
      doBindingName: 'SEQUENCE',
      doInstanceNameOrId: 'reconnect-test',
      WebSocketClass: getWebSocketShim(SELF),
    });

    // First request
    await client.reset();
    const seq1 = await client.next();
    expect(seq1).toBe(1);

    // Disconnect
    await client[Symbol.asyncDispose]();

    // Next request auto-reconnects
    const seq2 = await client.next();
    expect(seq2).toBe(2);

    await client[Symbol.asyncDispose]();
  });
});
```

## Storage Error Scenarios

Test error handling with storage operations:

```typescript test
import { describe, it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, RpcAccessible } from '@lumenize/rpc';
import { PaymentProcessor } from '../src/index';

type PaymentProcessor = RpcAccessible<InstanceType<typeof PaymentProcessor>>;

describe('Storage Errors', () => {
  it('should handle missing storage keys gracefully', async () => {
    const client = createRpcClient<PaymentProcessor>({
      transport: 'http',
      doBindingName: 'PAYMENT',
      doInstanceNameOrId: 'storage-error-test',
      fetch: SELF.fetch.bind(SELF),
    });

    // Reading non-existent key returns undefined
    const value = await client.ctx.storage.get('nonexistent');
    expect(value).toBeUndefined();

    // Can still write and read back
    await client.ctx.storage.put('test-key', 'test-value');
    const retrieved = await client.ctx.storage.get('test-key');
    expect(retrieved).toBe('test-value');
  });
});
```
