---
title: Introduction
description: Understanding Lumenize RPC for Durable Objects
---

# Introduction to Lumenize RPC

Lumenize RPC provides remote procedure calls to Cloudflare Durable Objects over HTTP or WebSocket transports.

Lumenize RPC has two different use cases:
1. In-process integration testing which is documented in 
   [`@lumenize/testing` Usage](/docs/testing/usage)
2. In-production RPC which is documented in this section
   
## In-production RPC

1. **Purpose**: Interact with your DOs from a browser client as if you were running inside the DO.

2. **Supports**:
   - Any StructuredCloneable type, including:
     - `Set`, `Map`, `Date`, circular objects, etc.
   - Errors thrown by your DO propagate back to the client and are re-thrown.
   - Communicate over HTTP or WebSockets.

3. **Secure**:
   - Hooks and examples provided to assure security.

4. **Example Usage**:
   ```typescript
   await client.ctx.storage.put('count', '10');
   const currentCount = await client.increment();  // 11
   ```

## WebSocket vs HTTP

At the moment, both transports have identical functionality, but different characteristics.

### WebSocket (default)
- Persistent connection for multiple calls
- Initial connection overhead
- Lower latency for subsequent calls
- Utilizes automatic connection management
- Will lazy reconnect on next call after connection drops

### HTTP (default for `@lumenize/testing`)
- One request per RPC call
- Simpler
- Slightly higher latency per call

Choose based on your use case:
- **When in doubt**: WebSocket is usually as reliable and almost always more efficient
- **In-production use with unknown network intermediaries**: HTTP is potentially more reliable
- **Future proof**: To-be-released Lumenize uses WebSocket for server to client communications like for state synchronization
