---
title: Introduction
description: Understanding Lumenize RPC for Durable Objects
---

# Introduction to Lumenize RPC

Lumenize RPC provides remote procedure calls to Cloudflare Durable Objects over HTTP or WebSocket transports.

Lumenize RPC has two different use cases:
1. In-process integration testing which is documented in 
   [`@lumenize/testing` Usage](/docs/testing/usage)
2. In-production RPC which is documented in this section

:::note
<details>
  <summary>
    <strong>Lumenize RPC</strong> vs <strong>Cloudflare Cap'n Web</strong>
  </summary>
  If the docs for Lumenize RPC seems a comparatively light (we wrote over 500 
  lines of docs for `routeDORequest`, after all), that's because it is. 
  Somewhere between the time we decided to open-source big chuncks of Lumenize
  and the when we pushed to `npm`, Cloudflare, and the amazing Kenton Varga,
  came out with their own from-the-browser RPC, Cap'n Web.

  As of this writing, we don't have complete insight into when to use which.
  We also don't performance metrics. When we have performance metrics and have
  used Cap'n Web ourselves, we will come back with more guidance. But for 
  now... 
  
  There is one feature of Lumenize RPC that Kenton has said he will never add
  to Cap'n Web, support for circular objects. He went so far as to say that
  he wishes he had never supported it in Cloudflare-native RPC (aka Cap'n 
  Protocol) and may work to remove it behind a compatibility date.
</details>
:::
   
## In-production RPC

1. **Purpose**: Interact with your DOs from a browser client as if you were running inside the DO.

2. **Supports**:
   - Any StructuredCloneable type, including:
     - `Set`, `Map`, `Date`, circular objects, etc.
   - Errors thrown by your DO propagate back to the client and are re-thrown.
   - Communicate over HTTP or WebSockets.

3. **Secure**:
   - Hooks and examples provided to assure security.

4. **Example Usage**:
   ```typescript
   await client.ctx.storage.put('count', '10');
   const currentCount = await client.increment();  // 11
   ```

## WebSocket vs HTTP

At the moment, both transports have identical functionality, but different characteristics.

### WebSocket (default)
- Persistent connection for multiple calls
- Initial connection overhead
- Lower latency for subsequent calls
- Utilizes automatic connection management
- Will lazy reconnect on next call after connection drops

### HTTP (default for `@lumenize/testing`)
- One request per RPC call
- Simpler
- Slightly higher latency per call

Choose based on your use case:
- **When in doubt**: WebSocket is usually as reliable and almost always more efficient
- **In-production use with unknown network intermediaries**: HTTP is potentially more reliable
- **Future proof**: The as-yet-to-be-released LumenizeBase uses WebSockets for real-time updates, like state synchronization. You won't need to change your client-side code if you start with WebSockets today and later upgrade server-side to use LumenizeBase.
