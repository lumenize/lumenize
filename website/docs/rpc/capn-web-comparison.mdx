---

generated_by: doc-testing

---



# vs Cap'n Web

<details>
<summary><strong>ðŸ“˜ Doc-testing</strong> â€“ Why do these examples look like tests?</summary>

This documentation uses **testable code examples** to ensure accuracy and reliability:

- **Guaranteed accuracy**: All examples are real, working code that runs against the actual library
- **Always up-to-date**: When the library changes, the tests fail and the docs must be updated
- **Copy-paste confidence**: What you see is what works - no outdated or broken examples
- **Real-world patterns**: Tests show complete, runnable scenarios, not just snippets

Ignore the test boilerplate (`it()`, `describe()`, etc.) - focus on the code inside.

</details>

This living documentation compares how Lumenize RPC and Cap'n Web (Cloudflare's 
official RPC solution) handle various features and patterns. Many sections
demonstrates both approaches side-by-side with focus on developer experience (DX) 
differences.

Further down, we show features that Cap'n Web has but Lumenize RPC does not, and
after that, we show features that Lumenize RPC has that Cap'n Web does not.

## References

- Cap'n Web blog post: https://blog.cloudflare.com/capnweb-javascript-rpc-library/
- Cap'n Web GitHub: https://github.com/cloudflare/capnweb
- Lumenize RPC docs: https://lumenize.com/docs/rpc/introduction




```typescript test
import { it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types are not consistently exported
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim } from '@lumenize/rpc';
import { newWebSocketRpcSession } from 'capnweb';

import { LumenizeDO, CapnWebRpcTarget } from '../src/index';

// =============================================================================
// Create clients - Similar amount of boilerplate
// =============================================================================

// Most of this is for vitest-workers-pool. In production, this would be as 
// simple as:
// ```ts
// const client = createRpcClient<typeof LumenizeDO>('LUMENIZE', 'name');
// ```
function getLumenizeClient(instanceName: string) {
  return createRpcClient<typeof LumenizeDO>(
    'LUMENIZE',
    instanceName,
    { WebSocketClass: getWebSocketShim(SELF.fetch.bind(SELF)) }
  );
}

// Similarly, some of this is for vitest-workers-pool. In production, this 
// would be as simple as:
// ```ts
// const url = `wss://test.com/capnweb/capnweb/name`;
// const client = newWebSocketRpcSession<CapnWebRpcTarget>(url);
// ```
function getCapnWebClient(instanceName: string) {
  const url = `wss://test.com/capnweb/capnweb/${instanceName}`;
  const ws = new (getWebSocketShim(SELF.fetch.bind(SELF)))(url);
  return newWebSocketRpcSession<CapnWebRpcTarget>(ws);
}
```




## Simple method call

They have near identical amount of boilerplate for a simple method call




```typescript test
it('demonstrates a simple method call', async () => {
  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('method-call');
  expect(await lumenizeClient.increment()).toBe(1);

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('method-call');
  expect(await capnwebClient.increment()).toBe(1);
});
```




## RPC Client Access to `ctx` and `env`

**Lumenize RPC**:
- âœ… **Full client access**: `client.ctx.storage.kv.put('key', 'value')`
- âœ… **Full client access to env**: `client.env.SOME_BINDING.getByName()`
- âœ… No custom methods needed for storage/state access

**Cap'n Web**:
- âŒ **No client access to `ctx`** - Must write custom methods
- âŒ **No client access to `env`** - Must write custom methods
- âš ï¸ Every storage operation requires a custom DO method




```typescript test
it('demonstrates RPC client access to ctx and env', async () => {
  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('ctx-access');

  // âœ… Lumenize RPC: Direct client access to ctx.storage!
  await lumenizeClient.ctx.storage.put('direct-key', 'direct-value');
  const directValue = await lumenizeClient.ctx.storage.get('direct-key');
  expect(directValue).toBe('direct-value');
  
  // âœ… Access to env and hopping to another instance
  const anotherInstance = await lumenizeClient.env.LUMENIZE.getByName(
    'another-instance'
  );
  expect(anotherInstance.name).toBe('another-instance');
  
  // âœ… You can still call custom methods if you want
  expect(await lumenizeClient.increment()).toBe(1);

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('ctx-access');

  // âŒ Trying to use ctx.storage will fail
  const capnCtx: any = capnwebClient.ctx;
  await expect(async () => {
    await capnCtx.storage.put('direct-key', 'direct-value');
    const directValue = await capnCtx.storage.get('direct-key');
    expect(directValue).toBe('direct-value');
  }).rejects.toThrow();

  // âŒ Trying to use env will also fail
  const capnEnv = (capnwebClient as any).env;
  await expect(async () => {
    const anotherInstance = await capnEnv.CAPNWEB.getByName('another-instance');
    expect(anotherInstance.name).toBe('another-instance');
  }).rejects.toThrow();
  
  // You MUST write a custom method like increment() to access storage
  expect(await capnwebClient.increment()).toBe(1);
});
```




## Supported Types

Both frameworks support structured-cloneable types, but with differences. This 
table shows DO Storage support first (the foundation), then how each RPC 
framework extends it.

| Type | DO Storage | Lumenize RPC | Cap'n Web | Notes |
|------|------------|--------------|-----------|-------|
| **Primitives** | | | | |
| undefined | âœ… | âœ… | âœ… | |
| null | âœ… | âœ… | âœ… | |
| **Special Numbers** | | | | |
| NaN | âœ… | âœ… | âŒ | Cap'n Web returns null |
| Infinity | âœ… | âœ… | âŒ | Cap'n Web returns null |
| -Infinity | âœ… | âœ… | âŒ | Cap'n Web returns null |
| **Built-in Types** | | | | |
| BigInt | âœ… | âœ… | âœ… | |
| Date | âœ… | âœ… | âœ… | |
| RegExp | âœ… | âœ… | âŒ | |
| Map | âœ… | âœ… | âŒ | |
| Set | âœ… | âœ… | âŒ | |
| ArrayBuffer | âœ… | âœ… | âŒ | |
| TypedArray | âœ… | âœ… | âœ… | |
| **Errors** | | | | |
| Error (thrown) | N/A | âœ… | âš ï¸ | Cap'n Web lose name and remote stack |
| Error (value) | âš ï¸ | âœ… | âš ï¸ | Cap'n Web lose name and remote stack |
| **Circular References** | âœ… | âœ… | âŒ | Cap'n Web throws error |
| **Web API Types** | | | | |
| Request | âŒ | âœ… | âŒ | |
| Response | âŒ | âœ… | âŒ | |
| Headers | âœ… | âœ… | âŒ | |
| URL | âŒ | âœ… | âŒ | |
| ReadableStream | âŒ | âŒ | âŒ | |
| WritableStream | âŒ | âŒ | âŒ | |

**Key insight**: Lumenize RPC supports everything that Durable Object storage 
(SQLite engine) supports and a few more. Cap'n Web's limited type support is
a significant foot-gun. If that improves over time, we'll update this table.

For comprehensive type support testing, see the [behavior test suite](https://github.com/lumenize/lumenize/blob/main/packages/rpc/test/shared/behavior-tests.ts).

## Error handling (thrown)

**Lumenize RPC**: âœ… Preserves name, message, and remote stack trace  
**Cap'n Web**: âš ï¸ Preserves message only, loses name and remote stack




```typescript test
it('demonstrates error throwing', async () => {
  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('error-throw');
  try {
    await lumenizeClient.throwError();
    expect.fail('should not reach');
  } catch (e: any) {
    expect(e.message).toContain('Intentional error');
    expect(e.stack).toContain('throwError'); // Actual remote stack
  }

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('error-throw');
  try {
    await capnwebClient.throwError();
    expect.fail('should not reach');
  } catch (e: any) {
    expect(e.message).toContain('Intentional error');
    expect(e.stack).not.toContain('throwError'); // Local RPC internals
  }
});
```




## Error as value

**Lumenize RPC**: âœ… Error type (name), message, and stack all preserved  
**Cap'n Web**: âŒ Loses error type (name), stack shows RPC internals not origin  
**Both**: âš ï¸ Loses prototype, but name can be used as a substitute for Lumenize




```typescript test
it('demonstrates error as value', async () => {
  class CustomError extends Error {}
  const testError = new CustomError('Test error');

  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('error-value');
  const lumenizeResult = await lumenizeClient.echo(testError);
  expect(lumenizeResult.message).toBe('Test error');
  expect(lumenizeResult).toBeInstanceOf(Error);
  // Prototype not preserved
  expect(lumenizeResult).not.toBeInstanceOf(CustomError);
  // But name is automatically set and preserved
  expect(lumenizeResult.name).toBe('CustomError');
  // Original stack preserved
  expect(lumenizeResult.stack).toContain('feature-comparison.test.ts');

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('error-value');
  const capnwebResult = await capnwebClient.echo(testError);
  expect(capnwebResult.message).toBe('Test error');
  expect(capnwebResult).toBeInstanceOf(Error);
  expect(capnwebResult.name).toBe('Error'); // Lost CustomError type
  expect(capnwebResult.stack).toContain('_Evaluator'); // RPC stack
});
```




## Circular references

**Lumenize RPC**: âœ… Handles circular references correctly  
**Cap'n Web**: âŒ Throws "DataCloneError: The object could not be cloned"




```typescript test
it('demonstrates circular references', async () => {
  const circular: any = { name: 'root' };
  circular.self = circular;

  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('circular');
  const lumenizeResult = await lumenizeClient.echo(circular);
  expect(lumenizeResult.name).toBe('root');
  expect(lumenizeResult.self).toBe(lumenizeResult);

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('circular');
  let capnwebThrew = false;
  try {
    await capnwebClient.echo(circular);
  } catch (e) {
    capnwebThrew = true;
  }
  expect(capnwebThrew).toBe(true);
});
```




## Web API types (Request, Response, Headers, URL)

**Lumenize RPC**: âœ… Web API types work (Request shown as example)  
**Cap'n Web**: âŒ Cannot serialize any Web API types  
**Both**: âŒ ReadableStream not yet supported




```typescript test
it('demonstrates Web API Request support', async () => {
  const testRequest = new Request('https://example.com/test', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  });
  
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue('test');
      controller.close();
    }
  });

  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('request');
  const lumenizeResult = await lumenizeClient.echo(testRequest);
  expect(lumenizeResult).toBeInstanceOf(Request);
  expect(lumenizeResult.url).toBe('https://example.com/test');
  expect(lumenizeResult.method).toBe('POST');
  
  // ReadableStream not yet supported
  await expect(async () => {
    await lumenizeClient.echo(stream);
  }).rejects.toThrow();

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('request');
  let capnwebThrew = false;
  try {
    await capnwebClient.echo(testRequest);
  } catch (e) {
    capnwebThrew = true;
  }
  expect(capnwebThrew).toBe(true);
  
  // ReadableStream not yet supported
  await expect(async () => {
    await capnwebClient.echo(stream);
  }).rejects.toThrow();
});
```




## Standard types (primitives and built-ins)

**Lumenize RPC**: âœ… All standard types preserved correctly  
**Cap'n Web**: âš ï¸ Special numbers (NaN, Infinity, -Infinity) become null




```typescript test
it('demonstrates standard type support', async () => {
  const bigInt = 12345678901234567890n;

  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeClient('types');
  expect(await lumenizeClient.echo(undefined)).toBeUndefined();
  expect(await lumenizeClient.echo(null)).toBeNull();
  expect(Number.isNaN(await lumenizeClient.echo(NaN))).toBe(true);
  expect(await lumenizeClient.echo(Infinity)).toBe(Infinity);
  expect(await lumenizeClient.echo(-Infinity)).toBe(-Infinity);
  expect(await lumenizeClient.echo(bigInt)).toBe(bigInt);

  // ==========================================================================
  // Cap'n Web
  // ==========================================================================
  using capnwebClient = getCapnWebClient('types');
  expect(await capnwebClient.echo(undefined)).toBeUndefined();
  expect(await capnwebClient.echo(null)).toBeNull();
  expect(Number.isNaN(await capnwebClient.echo(NaN))).toBe(false);
  expect(await capnwebClient.echo(Infinity)).not.toBe(Infinity);
  expect(await capnwebClient.echo(-Infinity)).not.toBe(-Infinity);
  expect(await capnwebClient.echo(bigInt)).toBe(bigInt);
});
```




## Installation

```bash npm2yarn
npm install --save-dev vitest@3.2
npm install --save-dev @vitest/coverage-istanbul@3.2
npm install --save-dev @cloudflare/vitest-pool-workers
npm install --save-dev @lumenize/rpc
npm install --save-dev @lumenize/utils
npm install --save-dev capnweb
```

## Configuration Files

### src/index.ts

Worker, DurableObjects and RpcTargets

```typescript src/index.ts
import { DurableObject, RpcTarget } from 'cloudflare:workers';
import { lumenizeRpcDO } from '@lumenize/rpc';
import { routeDORequest } from '@lumenize/utils';
import { newWorkersRpcResponse } from 'capnweb';

// ============================================================================
// Lumenize RPC
// ============================================================================

class _LumenizeDO extends DurableObject {
  increment(): number {
    let count = (this.ctx.storage.kv.get<number>("count")) ?? 0;
    this.ctx.storage.kv.put("count", ++count);
    return count;
  }

  throwError(): never {
    throw new Error('Intentional error from Lumenize DO');
  }

  echo(value: any): any {
    return value;
  }
}

export const LumenizeDO = lumenizeRpcDO(_LumenizeDO);

// ============================================================================
// Cap'n Web - A little more boilerplate (fetch and constructor, but the latter
//             is only because we want to use storage and test env access)
// ============================================================================

// Per Cap'n Web docs: "Classes which are intended to be passed by reference 
// and called over RPC must extend RpcTarget"
export class CapnWebRpcTarget extends RpcTarget {
  // RpcTarget requires us to manually capture ctx/env in constructor
  constructor(
    public ctx: DurableObjectState,
    public env: any
  ) {
    super();
  }
  
  increment(): number {
    let count = (this.ctx.storage.kv.get<number>("count")) ?? 0;
    this.ctx.storage.kv.put("count", ++count);
    return count;
  }

  throwError(): never {
    throw new Error('Intentional error from Cap\'n Web RpcTarget');
  }

  echo(value: any): any {
    return value;
  }

  fetch(request: Request): Response | Promise<Response> {
    return newWorkersRpcResponse(request, this);
  }
}

// ============================================================================
// Worker - Route requests to appropriate DO
// ============================================================================

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const lumenizeResponse = await routeDORequest(request, env, { prefix: '__rpc' });
    if (lumenizeResponse) return lumenizeResponse;
    
    const capnwebResponse = await routeDORequest(request, env, { prefix: 'capnweb' });
    if (capnwebResponse) return capnwebResponse;

    // Fallback for non-RPC requests
    return new Response('Not found', { status: 404 });
  },
};

```

### wrangler.jsonc

```json wrangler.jsonc
{
  "name": "feature-comparison",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      {
        "name": "LUMENIZE",
        "class_name": "LumenizeDO"
      },
      {
        "name": "CAPNWEB",
        "class_name": "CapnWebRpcTarget"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["LumenizeDO", "CapnWebRpcTarget"]
    }
  ]
}

```

### vitest.config.js

```javascript vitest.config.js
import { defineWorkersProject } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersProject({
  test: {
    testTimeout: 2000, // 2 second global timeout
    poolOptions: {
      workers: {
        // Must be false to use websockets. Have each test
        // reference a different DO instance to avoid state sharing.
        isolatedStorage: false,
        // Important! use the wrangler.jsonc in ./test
        wrangler: { configPath: "./wrangler.jsonc" },  
      },
    },
    // Use `vitest --run --coverage` to get test coverage report(s)
    coverage: {
      provider: "istanbul",  // Cannot use V8
      reporter: ['text', 'json', 'html'],
      include: ['**/src/**'],
      exclude: [
        '**/node_modules/**', 
        '**/dist/**', 
        '**/build/**', 
        '**/*.config.ts',
        '**/scratch/**'
      ],
    },
  },
});

```

## Try it out

To run these examples:
```bash
vitest --run
```

To see test coverage:
```bash
vitest --run --coverage
```