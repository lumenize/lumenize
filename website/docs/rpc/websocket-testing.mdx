---
title: WebSocket Testing
description: Testing Durable Object WebSocket functionality with RPC
testable: true
---

# WebSocket Testing with RPC

RPC makes testing WebSocket-enabled Durable Objects straightforward. Access WebSocket APIs through the RPC client for comprehensive testing.

## Accessing WebSocket APIs

All `DurableObjectState` methods are available via RPC:

```typescript src/index.ts
import { DurableObject } from 'cloudflare:workers';
import { lumenizeRpcDo } from '@lumenize/rpc';

class _ChatRoom extends DurableObject {
  async broadcast(message: string, tag?: string): Promise<number> {
    const connections = tag 
      ? this.ctx.getWebSockets(tag)
      : this.ctx.getWebSockets();
    
    connections.forEach(ws => ws.send(message));
    return connections.length;
  }

  async webSocketMessage(ws: WebSocket, message: string): Promise<void> {
    // Echo message to all connections
    await this.broadcast(message);
  }
}

export const ChatRoom = lumenizeRpcDo(_ChatRoom);
```

Configure Wrangler:

```jsonc wrangler
{
  "name": "chat-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [{ "name": "CHAT_ROOM", "class_name": "ChatRoom" }]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["ChatRoom"] }
  ]
}
```

Test WebSocket connections and methods:

```typescript test
import { describe, it, expect, vi } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim, RpcAccessible } from '@lumenize/rpc';
import { ChatRoom } from '../src/index';

type ChatRoom = RpcAccessible<InstanceType<typeof ChatRoom>>;

describe('WebSocket Testing', () => {
  it('should test WebSocket connections via RPC', async () => {
    const client = createRpcClient<ChatRoom>({
      doBindingName: 'CHAT_ROOM',
      doInstanceNameOrId: 'test-room',
      WebSocketClass: getWebSocketShim(SELF),
    });

    // Initially no connections
    const sockets0 = await client.ctx.getWebSockets();
    expect(sockets0).toHaveLength(0);

    // Create a WebSocket connection to the DO
    const WebSocketClass = getWebSocketShim(SELF);
    const ws1 = new WebSocketClass('wss://test/__rpc/chat-room/test-room/call');
    
    await vi.waitFor(() => {
      expect(ws1.readyState).toBe(WebSocket.OPEN);
    });

    // Verify connection exists
    const sockets1 = await client.ctx.getWebSockets();
    expect(sockets1).toHaveLength(1);

    // Create second connection
    const ws2 = new WebSocketClass('wss://test/__rpc/chat-room/test-room/call');
    await vi.waitFor(() => {
      expect(ws2.readyState).toBe(WebSocket.OPEN);
    });

    const sockets2 = await client.ctx.getWebSockets();
    expect(sockets2).toHaveLength(2);

    // Test broadcast
    let ws1Messages: string[] = [];
    let ws2Messages: string[] = [];
    
    ws1.addEventListener('message', (e: MessageEvent) => ws1Messages.push(e.data));
    ws2.addEventListener('message', (e: MessageEvent) => ws2Messages.push(e.data));

    const count = await client.broadcast('Hello, room!');
    expect(count).toBe(2);

    await vi.waitFor(() => {
      expect(ws1Messages).toContain('Hello, room!');
      expect(ws2Messages).toContain('Hello, room!');
    });

    // Cleanup
    ws1.close();
    ws2.close();
    await client[Symbol.asyncDispose]();
  });
});
```

## Testing WebSocket Tags

Tags help organize and target specific connection groups:

```typescript src/index.ts
import { DurableObject } from 'cloudflare:workers';
import { lumenizeRpcDo } from '@lumenize/rpc';

class _GameRoom extends DurableObject {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    
    // Accept WebSocket with team tag
    if (url.pathname.includes('/join')) {
      const team = url.searchParams.get('team') || 'spectator';
      const { 0: client, 1: server } = new WebSocketPair();
      this.ctx.acceptWebSocket(server, [team]);
      return new Response(null, { status: 101, webSocket: client });
    }
    
    return new Response('Not Found', { status: 404 });
  }

  async messageTeam(team: string, message: string): Promise<number> {
    const connections = this.ctx.getWebSockets(team);
    connections.forEach(ws => ws.send(message));
    return connections.length;
  }

  async getTeamSize(team: string): Promise<number> {
    return this.ctx.getWebSockets(team).length;
  }
}

export const GameRoom = lumenizeRpcDo(_GameRoom);
```

Test tagged WebSocket connections:

```typescript test
import { describe, it, expect, vi } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim, RpcAccessible } from '@lumenize/rpc';
import { GameRoom } from '../src/index';

type GameRoom = RpcAccessible<InstanceType<typeof GameRoom>>;

describe('WebSocket Tagging', () => {
  it('should test tagged WebSocket connections', async () => {
    const client = createRpcClient<GameRoom>({
      doBindingName: 'GAME_ROOM',
      doInstanceNameOrId: 'test-game',
      WebSocketClass: getWebSocketShim(SELF),
    });

    const WebSocketClass = getWebSocketShim(SELF);

    // Create connections for different teams
    const redWs = new WebSocketClass('wss://test/game-room/test-game/join?team=red');
    const blueWs = new WebSocketClass('wss://test/game-room/test-game/join?team=blue');
    const spectatorWs = new WebSocketClass('wss://test/game-room/test-game/join');

    await vi.waitFor(() => {
      expect(redWs.readyState).toBe(WebSocket.OPEN);
      expect(blueWs.readyState).toBe(WebSocket.OPEN);
      expect(spectatorWs.readyState).toBe(WebSocket.OPEN);
    });

    // Verify team sizes
    expect(await client.getTeamSize('red')).toBe(1);
    expect(await client.getTeamSize('blue')).toBe(1);
    expect(await client.getTeamSize('spectator')).toBe(1);

    // Send message to red team only
    let redMessages: string[] = [];
    let blueMessages: string[] = [];
    
    redWs.addEventListener('message', (e: MessageEvent) => redMessages.push(e.data));
    blueWs.addEventListener('message', (e: MessageEvent) => blueMessages.push(e.data));

    const redCount = await client.messageTeam('red', 'Red team, go!');
    expect(redCount).toBe(1);

    await vi.waitFor(() => {
      expect(redMessages).toContain('Red team, go!');
    });
    
    // Blue team didn't receive the message
    expect(blueMessages).toHaveLength(0);

    // Cleanup
    redWs.close();
    blueWs.close();
    spectatorWs.close();
    await client[Symbol.asyncDispose]();
  });
});
```

## Testing WebSocket Auto-Response

Auto-response pairs let you test WebSocket protocols without manual handlers:

```typescript test
import { describe, it, expect, vi } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim, RpcAccessible } from '@lumenize/rpc';
import { ChatRoom } from '../src/index';

type ChatRoom = RpcAccessible<InstanceType<typeof ChatRoom>>;

describe('WebSocket Auto-Response', () => {
  it('should test setWebSocketAutoResponse', async () => {
    const client = createRpcClient<ChatRoom>({
      doBindingName: 'CHAT_ROOM',
      doInstanceNameOrId: 'auto-response-test',
      WebSocketClass: getWebSocketShim(SELF),
    });

    // Set up auto-response for ping/pong
    await client.ctx.setWebSocketAutoResponse(
      new WebSocketRequestResponsePair('ping', 'pong')
    );

    // Create WebSocket connection
    const WebSocketClass = getWebSocketShim(SELF);
    const ws = new WebSocketClass('wss://test/__rpc/chat-room/auto-response-test/call');
    
    await vi.waitFor(() => {
      expect(ws.readyState).toBe(WebSocket.OPEN);
    });

    // Test auto-response
    let receivedPong = false;
    ws.addEventListener('message', (e: MessageEvent) => {
      if (e.data === 'pong') receivedPong = true;
    });

    ws.send('ping');
    
    await vi.waitFor(() => {
      expect(receivedPong).toBe(true);
    });

    // Cleanup
    ws.close();
    await client[Symbol.asyncDispose]();
  });
});
```

## Pre-populating State for Tests

Set up WebSocket state before running operations:

```typescript test
import { describe, it, expect } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { SELF } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim, RpcAccessible } from '@lumenize/rpc';
import { ChatRoom } from '../src/index';

type ChatRoom = RpcAccessible<InstanceType<typeof ChatRoom>>;

describe('Pre-populated WebSocket State', () => {
  it('should set up state then verify via RPC', async () => {
    const client = createRpcClient<ChatRoom>({
      doBindingName: 'CHAT_ROOM',
      doInstanceNameOrId: 'prepopulated-test',
      WebSocketClass: getWebSocketShim(SELF),
    });

    const WebSocketClass = getWebSocketShim(SELF);

    // Pre-populate: create several connections
    const ws1 = new WebSocketClass('wss://test/__rpc/chat-room/prepopulated-test/call');
    const ws2 = new WebSocketClass('wss://test/__rpc/chat-room/prepopulated-test/call');
    const ws3 = new WebSocketClass('wss://test/__rpc/chat-room/prepopulated-test/call');

    await vi.waitFor(() => {
      expect(ws1.readyState).toBe(WebSocket.OPEN);
      expect(ws2.readyState).toBe(WebSocket.OPEN);
      expect(ws3.readyState).toBe(WebSocket.OPEN);
    });

    // Test broadcast to all pre-populated connections
    const count = await client.broadcast('Test message');
    expect(count).toBe(3);

    // Cleanup
    ws1.close();
    ws2.close();
    ws3.close();
    await client[Symbol.asyncDispose]();
  });
});
```

## Best Practices

1. **Always await**: Even synchronous-looking calls like `ctx.getWebSockets()` must be awaited in RPC
2. **Use vi.waitFor**: WebSocket operations are asynchronous, wait for readyState and messages
3. **Clean up connections**: Close WebSockets and dispose RPC clients in test cleanup
4. **Test realistic scenarios**: Multiple connections, different tags, broadcast patterns

## Next Steps

- Learn about [Error Handling](./error-handling.mdx)
- Review [Limitations and Quirks](./limitations.mdx)
