---

generated_by: doc-testing

---



# vs Cap'n Web ("It just works")

<details>
<summary><strong>📘 Doc-testing</strong> – Why do these examples look like tests?</summary>

This documentation uses **testable code examples** to ensure accuracy and reliability:

- **Guaranteed accuracy**: All examples are real, working code that runs against the actual package(s)
- **Guaranteed latest comparisons**: Further, our release script won't allow us to release a new
  version of Lumenize, without prompting us to update any doc-tested comparison package 
  (e.g. Cap'n Web).
- **Always up-to-date**: When the library changes, the tests fail and the docs must be updated
- **Copy-paste confidence**: What you see is what works - no outdated or broken examples
- **Real-world patterns**: Tests show complete, runnable scenarios, not just snippet

Ignore the test boilerplate (`it()`, `describe()`, etc.) - focus on the code inside.

</details>

Cap'n Web's documentation states that Workers RPC interoperability 
["basically, it 'just works.'"](https://github.com/cloudflare/capnweb/tree/main#cloudflare-workers-rpc-interoperability) This living documentation demonstrates 
that claim and highlights the current limitations of it.

**Bottom line**: Cap'n Web's syntax, which allows you to magically return an RpcTarget instance or Durable Object stub is quite elegant and conceptually consistent. Lumenize RPC's is more explicit but similarly concise. Still, we'd give the slight advantage to Cap'n Web except for one little thing-[unsupported types](https://github.com/cloudflare/capnweb/tree/main?tab=readme-ov-file#pass-by-value-types). We drill down on this in the next doc-test but if you want to skip ahead, there is [summary table of types supported by Workers RPC compared to those supported by Cap'n Web and Lumenize RPC](/docs/rpc/capn-web-comparison-basics-and-types#supported-types). Note, Cloudflare says some of these "may be added in the future" and if that happens we will quickly update these documents, but until then, the claim "it just works" falls short.

TODO:
- Doesn't callbacks break consistency guarantees of input/output gates because you must await a callback function.
- Maybe too much magic. I had to fight my LLM to force it to even try. It kept saying, "that won't work" but once I forced it to try, it did!
- 

### src/index.ts

Normally, we start off these doc-tests with the tests that show behavior, but in this case, we want you to look at the Worker, DurableObjects and RpcTargets first.

```typescript src/index.ts
import { DurableObject, RpcTarget } from 'cloudflare:workers';
import { lumenizeRpcDO } from '@lumenize/rpc';
import { routeDORequest } from '@lumenize/utils';
import { newWorkersRpcResponse, RpcStub } from 'capnweb';

// =======================================================================
// Lumenize RPC - User and Room services
// =======================================================================

// Room stores messages using Map<number, string>
export class Room extends DurableObject {
  addMessage(text: string): number {
    const messages =
      this.ctx.storage.kv.get<Map<number, string>>('messages') ??
      new Map();
    const id = messages.size + 1;
    messages.set(id, text);
    this.ctx.storage.kv.put('messages', messages);
    return id;
  }

  getMessages(): Map<number, string> {
    return (
      this.ctx.storage.kv.get<Map<number, string>>('messages') ??
      new Map()
    );
  }
}

// User acts as a gateway, hopping to Room via env
class _User extends DurableObject<Env> {
  // Generic method forwarder - calls any Room method by name
  room(roomName: string, method: string, ...params: any[]): Promise<any> {
    return (this.env.ROOM.getByName(roomName) as any)[method](...params);
  }
}

export const User = lumenizeRpcDO(_User);

// =======================================================================
// Cap'n Web - Clean and elegant
// =======================================================================

// Cap'n Web Room - Uses Map (will fail on getMessages())
export class CapnWebRoom extends DurableObject<Env> {
  addMessage(text: string): number {
    const messages =
      this.ctx.storage.kv.get<Map<number, string>>('messages') ??
      new Map();
    const id = messages.size + 1;
    messages.set(id, text);
    this.ctx.storage.kv.put('messages', messages);
    return id;
  }

  getMessages(): Map<number, string> {
    return (
      this.ctx.storage.kv.get<Map<number, string>>('messages') ??
      new Map()
    );
  }
}

// Cap'n Web PlainRoom - Uses plain object (will work)
export class CapnWebPlainRoom extends DurableObject<Env> {
  // Store callbacks to test multi-hop scenario
  #callbacks = new Map<string, (message: string) => void>();
  #joinPromises = new Map<string, {resolve: () => void, reject: (err: any) => void}>();

  async joinAndListen(userName: string, onMessage: (message: string) => void): Promise<void> {
    console.log('CapnWebPlainRoom.joinAndListen called for user:', userName);
    this.#callbacks.set(userName, onMessage);
    console.log('Callback stored, total callbacks:', this.#callbacks.size);
    
    // Don't return - keep the RPC connection alive
    // Create a promise that we'll resolve when the user leaves
    return new Promise((resolve, reject) => {
      this.#joinPromises.set(userName, { resolve, reject });
      // For testing, auto-resolve after 5 seconds
      setTimeout(() => {
        console.log('Auto-resolving join for user:', userName);
        resolve();
      }, 5000);
    });
  }

  join(userName: string, onMessage: (message: string) => void): void {
    console.log('CapnWebPlainRoom.join called for user:', userName);
    this.#callbacks.set(userName, onMessage);
    console.log('Callback stored, total callbacks:', this.#callbacks.size);
  }

  async addMessage(text: string): Promise<number> {
    console.log('CapnWebPlainRoom.addMessage called with:', text);
    console.log('Total callbacks registered:', this.#callbacks.size);
    const messages =
      this.ctx.storage.kv.get<Record<number, string>>('messages') ??
      {};
    const id = Object.keys(messages).length + 1;
    messages[id] = text;
    this.ctx.storage.kv.put('messages', messages);
    
    // Try invoking callbacks
    for (const [userName, callback] of this.#callbacks.entries()) {
      console.log('Attempting to invoke callback for user:', userName);
      try {
        await (callback as any)(text);
        console.log('Callback invoked successfully for user:', userName);
      } catch (error) {
        console.error('Error invoking callback for user:', userName, error);
      }
    }
    
    return id;
  }

  getMessages(): Record<number, string> {
    return (
      this.ctx.storage.kv.get<Record<number, string>>('messages') ??
      {}
    );
  }
}

// Cap'n Web User - RpcTarget instantiated directly in worker
export class CapnWebUser extends RpcTarget {
  constructor(private env: Env) {
    super();
  }

  // Store client callbacks for proxying to DOs
  #clientCallbacks = new Map<string, (message: string) => void>();

  // Return Workers RPC stub to Room
  // (uses Map - will fail on getMessages())
  getRoom(roomName: string) {
    return this.env.CAPNWEB_ROOM.getByName(roomName);
  }

  // Return Workers RPC stub to PlainRoom
  // (uses plain object - will work)
  getPlainRoom(roomName: string) {
    return this.env.CAPNWEB_PLAIN_ROOM.getByName(roomName);
  }

  // Test callback directly on User (no Room hop)
  async testCallback(callback: (msg: string) => void): Promise<string> {
    await callback('Hello from CapnWebUser!');
    return 'callback invoked';
  }

  // Proxy pattern: Keep connection alive by not returning until done
  async joinRoomAndListen(roomName: string, userName: string, clientCallback: (message: string) => void): Promise<void> {
    // Store the client callback
    const key = `${roomName}:${userName}`;
    this.#clientCallbacks.set(key, clientCallback);

    // Create our own callback that will be sent to the DO
    const proxyCallback = (message: string) => {
      console.log('User proxy callback invoked with:', message);
      const cb = this.#clientCallbacks.get(key);
      if (cb) {
        cb(message);
      }
    };

    // Get the DO stub and call joinAndListen - this won't return until the session ends
    const roomStub = this.env.CAPNWEB_PLAIN_ROOM.getByName(roomName) as any;
    await roomStub.joinAndListen(userName, proxyCallback);
  }

  // Forward addMessage to the DO
  async addRoomMessage(roomName: string, text: string): Promise<number> {
    const roomStub = this.env.CAPNWEB_PLAIN_ROOM.getByName(roomName) as any;
    return await roomStub.addMessage(text);
  }
}

// =======================================================================
// Worker - Route requests to appropriate service
// =======================================================================

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    
    // Route Lumenize RPC requests (both User and Room)
    const lumenizeResponse = await routeDORequest( request, env, 
      { prefix: '__rpc' });
    if (lumenizeResponse) return lumenizeResponse;
    
    // Route Cap'n Web RPC requests
    // - instantiate RpcTarget directly per Cap'n Web pattern
    if (url.pathname === '/capnweb') {
      return newWorkersRpcResponse(request, new CapnWebUser(env));
    }

    // Fallback for non-RPC requests
    return new Response('Not found', { status: 404 });
  },
};

```

## Imports




```typescript test
import { it, expect, vi } from 'vitest';
// @ts-expect-error - cloudflare:test module types are not consistently exported
import { SELF, env } from 'cloudflare:test';
import { createRpcClient, getWebSocketShim } from '@lumenize/rpc';
import { newWebSocketRpcSession } from 'capnweb';

import { User, CapnWebUser } from '../src/index';
```




## Version(s)

This test asserts the installed version(s) and our release script warns if we 
aren't using the latest version published to npm, so this living documentation 
should always be up to date.




```typescript test
import lumenizeRpcPackage from '../../../../packages/rpc/package.json';
import capnwebPackage from '../../../../node_modules/capnweb/package.json';
it('detects package versions', () => {
  expect(lumenizeRpcPackage.version).toBe('0.10.0');
  expect(capnwebPackage.version).toBe('0.1.0');
});
```




## Creating Clients




```typescript test
function getLumenizeUserClient(instanceName: string) {
  return createRpcClient<typeof User>(
    'USER',
    instanceName,
    { WebSocketClass: getWebSocketShim(SELF.fetch.bind(SELF)) }
  );
}

function getCapnWebUserClient() {
  const url = `wss://test.com/capnweb`;
  const ws = new (getWebSocketShim(SELF.fetch.bind(SELF)))(url);
  return newWebSocketRpcSession<CapnWebUser>(ws);
}

// Alias for brevity
const getCapnWebClient = getCapnWebUserClient;
```




## Service-to-Service Communication via Workers RPC

A common pattern in chat applications: User service acts as a gateway/proxy,
hopping to Room services for actual storage operations.

**Lumenize RPC**:
- ✅ Seamlessly hops from User to Room via `this.env.ROOM`
- ✅ Client accesses User via Lumenize RPC
- ✅ User → Room communication uses Workers RPC automatically
- ✅ No configuration needed - it "just works"

**Cap'n Web**:
- ✅ Can hop from User to Room using stubs
- ✅ Clean pattern - just return Workers RPC stubs directly
- ✅ Works like magic when types are compatible
- ⚠️ Limited type support breaks the magic for Map, Set, etc.




```typescript test
it('demonstrates service-to-service hopping', async () => {
  // ==========================================================================
  // Lumenize RPC
  // ==========================================================================
  using lumenizeClient = getLumenizeUserClient('user-lumenize');

  // ✅ Client → User via Lumenize RPC
  // ✅ User.room() forwards method calls to Room via Workers RPC
  // ✅ No explicit proxy methods needed - one generic forwarder!
  const msgId1 = await lumenizeClient.room('lumenize', 'addMessage', 'Hello');
  expect(msgId1).toBe(1);

  const msgId2 = await lumenizeClient.room('lumenize', 'addMessage', 'World');
  expect(msgId2).toBe(2);

  const messages = await lumenizeClient.room('lumenize', 'getMessages');
  expect(messages).toBeInstanceOf(Map); // ✅ Map works seamlessly
  expect(messages.size).toBe(2);
  expect(messages.get(1)).toBe('Hello');
  expect(messages.get(2)).toBe('World');

  // ==========================================================================
  // Cap'n Web - Map type fails
  // ==========================================================================
  using capnwebClient = getCapnWebUserClient();

  // Get a stub to the Room (uses Map)
  // - Cap'n Web User returns Workers RPC stub
  using roomStub = capnwebClient.getRoom('room-capnweb-map');

  // ✅ Client → User via Cap'n Web RPC
  //    (User is RpcTarget instantiated in worker)
  // ✅ User returns Workers RPC stub to Room
  // ✅ Client → Room via the returned Workers RPC stub
  const capnMsgId1 = await roomStub.addMessage('Hello');
  expect(capnMsgId1).toBe(1);

  const capnMsgId2 = await roomStub.addMessage('World');
  expect(capnMsgId2).toBe(2);

  // ❌ Map FAILS even though this is a Workers RPC stub!
  // While Cap'n Web proxies Workers RPC stubs, return values STILL
  // go through Cap'n Web's serialization layer, which doesn't
  // support Map.
  let capnwebThrew = false;
  let capnwebError: Error | undefined;
  try {
    await roomStub.getMessages();
  } catch (e) {
    capnwebThrew = true;
    capnwebError = e as Error;
  }
  expect(capnwebThrew).toBe(true);
  expect(capnwebError?.message).toContain('Cannot serialize value');

  // ==========================================================================
  // Cap'n Web - Plain object works
  // ==========================================================================
  
  // Get a stub to PlainRoom (uses plain object instead of Map)
  using plainRoomStub = capnwebClient.getPlainRoom(
    'room-capnweb-plain'
  );

  const plainMsgId1 = await plainRoomStub.addMessage('Hello');
  expect(plainMsgId1).toBe(1);

  const plainMsgId2 = await plainRoomStub.addMessage('World');
  expect(plainMsgId2).toBe(2);

  // ✅ Plain object works because it's Cap'n Web compatible
  const plainMessages = await plainRoomStub.getMessages();
  expect(plainMessages[1]).toBe('Hello');
  expect(plainMessages[2]).toBe('World');

  // ===========================================================================
  // CONCLUSION: "It Just Works" requires Cap'n Web-compatible types
  // ===========================================================================
  // Cap'n Web can proxy Workers RPC stubs (getRoom() and
  // getPlainRoom() work), but return values STILL go through Cap'n
  // Web serialization.
  // - Map, Set, RegExp, ArrayBuffer: ❌ Fail
  // - Plain objects, arrays, primitives: ✅ Work
  //
  // Compare with Lumenize RPC where Map works seamlessly without
  // workarounds.
});
```




## Function Callbacks Work (With Limitations)

Cap'n Web supports passing functions as RPC parameters, leveraging Workers RPC's 
ability to pass functions as stubs. When you pass a function, the recipient gets 
a stub that makes an RPC **back** to the sender when called.

**Testing hypothesis**: Does extending RpcTarget instead of DurableObject allow 
callbacks to work across multiple hops?




```typescript test
it('demonstrates function callback support', async () => {
  // ✅ Works: Direct call from client to CapnWebUser (RpcTarget)
  const capnwebClient = getCapnWebClient();

  const receivedMessages: string[] = [];
  
  const myCallback = (message: string) => {
    receivedMessages.push(message);
  };

  // First test: Direct callback works
  const result = await capnwebClient.testCallback(myCallback);
  expect(result).toBe('callback invoked');

  await vi.waitFor(() => {
    expect(receivedMessages).toContain('Hello from CapnWebUser!');
  }, { timeout: 500 });

  // Second test: Multi-hop callback with long-lived connection
  // The key: joinAndListen doesn't return, keeping the RPC connection alive
  const roomMessages: string[] = [];
  const roomCallback = (message: string) => {
    console.log('Client callback received:', message);
    roomMessages.push(message);
  };

  // Start listening - this won't return for 5 seconds
  const listenPromise = capnwebClient.joinRoomAndListen('room-callbacks-test', 'Alice', roomCallback);

  // Give it a moment to establish
  await new Promise(resolve => setTimeout(resolve, 100));

  // Add message which should trigger: DO → User proxy → Client
  // The callback stub is still valid because joinAndListen hasn't returned yet
  await capnwebClient.addRoomMessage('room-callbacks-test', 'Test message via proxy');

  // Wait to see if callback fires
  await vi.waitFor(() => {
    expect(roomMessages).toContain('Test message via proxy');
  }, { timeout: 500 });
  
  expect(roomMessages).toEqual(['Test message via proxy']);
  
  // The listen promise will resolve after 5 seconds (or we could cancel it)
  // For now, just let it timeout naturally
});
```




## The Type Support Problem

Cap'n Web's "it just works" claim breaks down when you try to use 
StructuredClone types that Workers RPC supports but Cap'n Web doesn't.

**Workers RPC** (DO Storage): Supports all StructuredClone types including 
Map, Set, RegExp, ArrayBuffer, circular references, etc.

**Lumenize RPC**: Supports everything Workers RPC supports (and more).

**Cap'n Web**: Limited type support - no Map, Set, RegExp, ArrayBuffer,
circular references, etc.

For a comprehensive type support comparison, see the 
[basics and types documentation](/docs/rpc/capn-web-comparison-basics-and-types#supported-types).

## Configuration Comparison

**Lumenize RPC**:
- DOs extend `DurableObject` (no special base class required)
- No manual constructor or fetch method needed
- `lumenizeRpcDO()` wrapper handles all RPC setup

**Cap'n Web**:
- DOs must extend `RpcTarget` instead of `DurableObject`
- Must manually implement constructor to capture `ctx` and `env`
- Must manually implement `fetch()` method
- Cannot reuse existing DurableObjects without modification

The configuration differences show Lumenize RPC's design priority: 
make it easy to add RPC to existing DOs without refactoring.

## Installation

```bash npm2yarn
npm install --save-dev vitest@3.2
npm install --save-dev @vitest/coverage-istanbul@3.2
npm install --save-dev @cloudflare/vitest-pool-workers
npm install --save-dev @lumenize/rpc
npm install --save-dev @lumenize/utils
npm install --save-dev capnweb
```

## Configuration Files

### wrangler.jsonc

```json wrangler.jsonc
{
  "name": "capnweb-just-works-comparison",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      {
        "name": "USER",
        "class_name": "User"
      },
      {
        "name": "ROOM",
        "class_name": "Room"
      },
      {
        "name": "CAPNWEB_ROOM",
        "class_name": "CapnWebRoom"
      },
      {
        "name": "CAPNWEB_PLAIN_ROOM",
        "class_name": "CapnWebPlainRoom"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": [
        "User", 
        "Room", 
        "CapnWebRoom", 
        "CapnWebPlainRoom"
      ]
    }
  ]
}

```

### vitest.config.js

```javascript vitest.config.js
import { defineWorkersProject } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersProject({
  test: {
    testTimeout: 2000, // 2 second global timeout
    poolOptions: {
      workers: {
        // Must be false to use websockets. Have each test
        // reference a different DO instance to avoid state sharing.
        isolatedStorage: false,
        // Important! use the wrangler.jsonc in ./test
        wrangler: { configPath: "./wrangler.jsonc" },  
      },
    },
    // Use `vitest --run --coverage` to get test coverage report(s)
    coverage: {
      provider: "istanbul",  // Cannot use V8
      reporter: ['text', 'json', 'html'],
      include: ['**/src/**'],
      exclude: [
        '**/node_modules/**', 
        '**/dist/**', 
        '**/build/**', 
        '**/*.config.ts',
        '**/scratch/**'
      ],
    },
  },
});

```

## Try it out

To run these examples:
```bash
vitest --run
```

To see test coverage:
```bash
vitest --run --coverage
```