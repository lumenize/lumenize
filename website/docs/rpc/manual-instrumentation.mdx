---
sidebar_position: 2
title: Manual Instrumentation
description: Using handleRPCRequest and handleWebSocketRPCMessage for custom routing
testable: true
---

# Manual Instrumentation

When you need custom routing alongside RPC (health checks, webhooks, custom WebSocket messages), use manual instrumentation with `handleRPCRequest()` and `handleWebSocketRPCMessage()`.

## When to Use Manual Instrumentation

- **Custom HTTP routes**: `/health`, `/metrics`, webhooks
- **Custom WebSocket messages**: Application-specific protocols (PING/PONG, streaming)
- **Complex routing**: Conditional RPC based on request properties
- **Fine-grained control**: Custom error handling, logging, rate limiting

## Complete Example: HTTP & WebSocket Custom Routing

Combine RPC with custom HTTP routes and WebSocket messages:

```typescript src/index.ts
import { DurableObject } from 'cloudflare:workers';
import { handleRPCRequest, handleWebSocketRPCMessage } from '@lumenize/rpc';
import { routeDORequest } from '@lumenize/utils';

export class MyDO extends DurableObject {
  #counter = 0;

  // Your DO methods (available via RPC)
  increment(): number {
    return ++this.#counter;
  }

  reset(): void {
    this.#counter = 0;
  }

  // Custom routing in fetch()
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    // Custom HTTP: Health check endpoint
    if (url.pathname.endsWith('/health')) {
      return new Response('OK');
    }

    // Custom HTTP: Counter status endpoint
    if (url.pathname.endsWith('/status')) {
      return Response.json({ counter: this.#counter });
    }

    // Custom WebSocket: Non-RPC WebSocket endpoint
    if (url.pathname.endsWith('/custom-ws')) {
      const { 0: client, 1: server } = new WebSocketPair();
      this.ctx.acceptWebSocket(server, ['custom']);
      return new Response(null, { status: 101, webSocket: client });
    }

    // Handle RPC requests (both HTTP and WebSocket)
    return await handleRPCRequest(request, this);
  }

  // Handle all WebSocket messages
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): Promise<void> {
    const tags = this.ctx.getTags(ws);

    // Custom WebSocket protocol for tagged connections
    if (tags.includes('custom')) {
      if (message === 'PING') {
        ws.send('PONG');
        return;
      }
    }

    // Handle RPC WebSocket messages
    await handleWebSocketRPCMessage(ws, message, this);
  }

  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean): Promise<void> {
    // Optional: cleanup for both custom and RPC WebSockets
  }
}

// Worker routes requests to DOs
export default {
  async fetch(request: Request, env: any): Promise<Response> {
    // Try RPC routing first
    const rpcResponse = await routeDORequest(request, env, { prefix: '__rpc' });
    if (rpcResponse) return rpcResponse;
    
    // For custom endpoints, also route to DO (without RPC prefix)
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(Boolean);
    
    // Pattern: /binding-name/instance-id/...rest
    if (pathParts.length >= 2) {
      const bindingName = pathParts[0].toUpperCase().replace(/-/g, '_');
      const instanceId = pathParts[1];
      
      if (env[bindingName]) {
        const id = env[bindingName].idFromName(instanceId);
        const stub = env[bindingName].get(id);
        return stub.fetch(request);
      }
    }
    
    return new Response('Not Found', { status: 404 });
  },
};
```

Configure Wrangler:

```jsonc wrangler
{
  "name": "manual-routing-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [{ "name": "MY_DO", "class_name": "MyDO" }]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["MyDO"] }
  ]
}
```

Test custom routes alongside RPC:

```typescript test
import { describe, it, expect, vi } from 'vitest';
// @ts-expect-error - cloudflare:test module types
import { env } from 'cloudflare:test';
import { createRpcClient, RpcAccessible, getWebSocketShim } from '@lumenize/rpc';
import { MyDO } from '../src/index';

type MyDO = RpcAccessible<InstanceType<typeof MyDO>>;

describe('Manual Instrumentation', () => {
  it('should support custom HTTP routes alongside RPC', async () => {
    const instanceId = 'manual-http-test';
    const id = env.MY_DO.idFromName(instanceId);
    const stub = env.MY_DO.get(id);

    // Test custom /health endpoint (direct DO stub call)
    const healthRes = await stub.fetch('https://test/health');
    expect(await healthRes.text()).toBe('OK');

    // Test RPC using HTTP transport
    const client = createRpcClient<MyDO>({
      transport: 'http',
      doBindingName: 'MY_DO',
      doInstanceNameOrId: instanceId,
    });

    const count1 = await client.increment();
    expect(count1).toBe(1);

    // Test custom /status endpoint (direct DO stub call)
    const statusRes = await stub.fetch('https://test/status');
    const status = await statusRes.json();
    expect(status).toEqual({ counter: 1 });

    // RPC still works
    const count2 = await client.increment();
    expect(count2).toBe(2);

    // Reset via RPC
    await client.reset();

    // Verify via custom endpoint
    const statusRes2 = await stub.fetch('https://test/status');
    const status2 = await statusRes2.json();
    expect(status2).toEqual({ counter: 0 });
  });

  it('should support custom WebSocket messages alongside RPC', async () => {
    const instanceId = 'manual-ws-test';
    const WebSocketClass = getWebSocketShim(SELF);

    // Create custom WebSocket connection (direct to DO, not via /__rpc)
    const customWs = new WebSocketClass(`wss://test/my-do/${instanceId}/custom-ws`);

    await vi.waitFor(() => {
      expect(customWs.readyState).toBe(WebSocket.OPEN);
    });

    // Test custom protocol (PING/PONG)
    let receivedPong = false;
    customWs.addEventListener('message', (event: MessageEvent) => {
      if (event.data === 'PONG') receivedPong = true;
    });

    customWs.send('PING');
    await vi.waitFor(() => expect(receivedPong).toBe(true));

    // Create RPC client (uses RPC WebSocket endpoint, not custom)
    await using client = createRpcClient<MyDO>({
      doBindingName: 'MY_DO',
      doInstanceNameOrId: instanceId,
      WebSocketClass,
    });

    // RPC works independently
    const count1 = await client.increment();
    expect(count1).toBe(1);

    const count2 = await client.increment();
    expect(count2).toBe(2);

    // Custom WebSocket still works
    receivedPong = false;
    customWs.send('PING');
    await vi.waitFor(() => expect(receivedPong).toBe(true));

    // Cleanup custom WebSocket
    customWs.close();
  });
});
```

## Best Practices

1. **Check tags first**: In `webSocketMessage()`, handle custom protocols before calling `handleWebSocketRPCMessage()`
2. **Use path-based routing**: Separate custom WebSocket endpoints (`/custom-ws`) from RPC endpoints (`/__rpc`)
3. **Consistent patterns**: Keep custom routes simple, let RPC handle complex method calls
4. **Error handling**: Custom routes should match RPC's error response format when appropriate

## Next Steps

- Learn about [WebSocket Testing](./websocket-testing.mdx)
- Explore [Error Handling](./error-handling.mdx) patterns
