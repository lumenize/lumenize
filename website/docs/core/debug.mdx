---
title: "Debug"
description: "Scoped, filterable debug logging optimized for Cloudflare's JSON log dashboard"
---

# Debug

A de✨light✨ful scoped debug logging system for Cloudflare Durable Objects, inspired by npm's `debug` package with level support and JSON output.

Part of `@lumenize/core`.

## Features

- **Namespace filtering**: Use dot-notation scopes (e.g., `lmz.proxy-fetch.serialization`) with wildcard patterns
- **Level support**: `debug`, `info`, and `warn` levels, all filterable
- **JSON output**: Structured logs integrate seamlessly with Cloudflare's log dashboard
- **Zero-cost when disabled**: Early exit via `enabled` flag - no string interpolation or object creation
- **NADIS integration**: Use standalone or auto-inject into `LumenizeBase` via `this.svc.debug`

## Installation

```bash @skip-check
npm install @lumenize/core
```

## Quick Start

### In Durable Objects (LumenizeBase)

```typescript @skip-check
import '@lumenize/core';  // Registers in this.svc
import { LumenizeBase } from '@lumenize/lumenize-base';

class MyDO extends LumenizeBase<Env> {
  async fetch(request: Request) {
    const log = this.svc.debug('my-app.http');
    
    const url = new URL(request.url);
    log.debug('Processing request', { 
      pathname: url.pathname,
      method: request.method 
    });
    
    // Update counter in storage
    const count = (this.ctx.storage.kv.get('requestCount') ?? 0) + 1;
    this.ctx.storage.kv.set('requestCount', count);
    
    log.info('Request completed', { 
      requestCount: count,
      pathname: url.pathname
    });
    
    return new Response('OK');
  }
}
```

### In Vanilla Durable Objects

```typescript @skip-check
import { debug } from '@lumenize/core';
import { DurableObject } from 'cloudflare:workers';

class MyDO extends DurableObject {
  #log = debug(this)('my-namespace');
  
  async fetch(request: Request) {
    this.#log.debug('Processing request', { url: request.url });
    return new Response('OK');
  }
}
```

### In Workers (outside DOs)

```typescript @skip-check
import { debug } from '@lumenize/core';

export default {
  async fetch(request: Request, env: Env) {
    const log = debug({ env })('worker.router');
    
    log.debug('Routing request', { 
      pathname: new URL(request.url).pathname 
    });
    
    // Route to DO...
    return response;
  }
}
```

## Configuration

Control logging via the `DEBUG` environment variable (in `.dev.vars` for local development):

```bash @skip-check
# Enable all levels for a namespace
DEBUG=lmz.proxy-fetch

# Enable only warn level
DEBUG=lmz.proxy-fetch:warn

# Multiple namespaces
DEBUG=lmz.proxy-fetch,lmz.rpc.client

# Wildcard patterns
DEBUG=lmz.proxy-fetch.*

# Everything (both your app and Lumenize)
DEBUG=*

# Only your app (exclude all Lumenize internal logging)
DEBUG=my-app.*

# Your app plus specific Lumenize subsystem
DEBUG=my-app.*,lmz.utils.route-do-request

# Everything except Lumenize internals
DEBUG=*,-lmz.*

# Exclusions (enable all Lumenize except one verbose part)
DEBUG=lmz.*,-lmz.proxy-fetch.queue
```

### Level Filtering

Each namespace can have a level filter:

- `DEBUG=app` - All levels (debug, info, warn)
- `DEBUG=app:info` - Info and warn only
- `DEBUG=app:warn` - Warn only

Default is all levels when no level specified.

## Log Output Format

All logs output as JSON objects to `console.debug`:

```json @skip-check
{
  "level": "debug",
  "namespace": "lmz.proxy-fetch.queue",
  "message": "Processing request",
  "url": "https://api.example.com/data",
  "method": "POST",
  "timestamp": 1699564800000
}
```

This format integrates with Cloudflare's log dashboard, allowing you to:
- Query by field (e.g., `namespace:"lmz.proxy-fetch.queue"`)
- Filter by level
- Search message content
- Analyze structured data

## API

### `debug(instance)`

Creates a debug logger factory.

**Parameters:**
- `instance` - Durable Object instance (with `env`) or object with `env` property

**Returns:** Factory function `(namespace: string) => DebugLogger`

**Example:**
```typescript @skip-check
const createLogger = debug(this);
const log = createLogger('my-namespace');
```

### `DebugLogger` Interface

#### `log.debug(message, data?)`

Log at debug level (most verbose).

```typescript @skip-check
log.debug('Parsing request body', { 
  contentType: 'application/json',
  size: body.length 
});
```

#### `log.info(message, data?)`

Log informational messages (milestones, events).

```typescript @skip-check
log.info('Cache hit', { 
  key: 'user:123',
  ttl: 3600 
});
```

#### `log.warn(message, data?)`

Log warnings (expected operational issues, not errors).

```typescript @skip-check
log.warn('Retry limit reached', { 
  reqId: 'abc-123',
  retryCount: 5 
});
```

#### `log.enabled`

Boolean flag indicating if this logger is enabled for any level.

```typescript @skip-check
if (log.enabled) {
  // Expensive computation only if logging enabled
  const details = computeExpensiveDetails();
  log.debug('Details', details);
}
```

## Namespace Conventions

### Your Application Code

For your own application code, use descriptive namespaces without the `lmz.` prefix:

- **App scope**: `my-app`, `chat-app`, `api-service`
- **Feature scope**: `my-app.websocket`, `my-app.auth`, `my-app.billing`
- **Component scope**: `my-app.auth.session`, `my-app.chat.room`

Examples for your app:

```typescript @skip-check
// Main app DO
const log = this.svc.debug('my-app.main');

// WebSocket handling
const wsLog = this.svc.debug('my-app.websocket');

// Authentication/authorization
const authLog = this.svc.debug('my-app.auth');

// Specific callbacks
const onConnectLog = this.svc.debug('my-app.onBeforeConnect');
```

### Lumenize Internal Code

Lumenize packages use the `lmz.` prefix to separate framework logging from your application logging:

- **Package scope**: `lmz.proxy-fetch`, `lmz.rpc`, `lmz.utils`
- **Component scope**: `lmz.proxy-fetch.queue`, `lmz.rpc.client`
- **Feature scope**: `lmz.proxy-fetch.serialization`, `lmz.rpc.websocket`

Examples from Lumenize packages:

- `lmz.proxy-fetch.queue` - Queue consumer
- `lmz.proxy-fetch.do` - Durable Object
- `lmz.rpc.client` - RPC client
- `lmz.rpc.factory` - RPC factory
- `lmz.rpc.client.websocket` - WebSocket transport
- `lmz.rpc.client.http` - HTTP transport
- `lmz.utils.route-do-request` - Request routing

This separation allows you to:
- See only your logs: `DEBUG=my-app.*`
- See only Lumenize logs: `DEBUG=lmz.*`
- See everything: `DEBUG=*`
- See your app + specific Lumenize subsystem: `DEBUG=my-app.*,lmz.rpc.*`

## Performance

The debug system has minimal overhead:

1. **Early exit**: `enabled` flag checked first - no-op if disabled
2. **No string interpolation**: Use object format, not template literals
3. **No object creation**: Only when actually logging

```typescript @skip-check
// ✅ Good - no overhead when disabled
log.debug('Processing', { items: items.length });

// ❌ Bad - string interpolation happens even when disabled
log.debug(`Processing ${items.length} items`);
```

## Error Logging

**Important**: Don't use the debug system for critical errors. Use `console.error` directly:

```typescript @skip-check
// ✅ Critical system errors - always visible
console.error('Queue processing failed', {
  error: e.message,
  stack: e.stack,
  reqId
});

// ✅ Expected operational issues - filterable
log.warn('Retry limit reached', {
  reqId,
  retryCount: 5
});

// ✅ Debugging information - filterable
log.debug('Parsed request', {
  url,
  method
});
```

## Use Cases

### Development - See Everything

Enable all logging during local development:

```bash @skip-check
DEBUG=* npm run dev
```

### Testing - Targeted Debugging

Enable specific namespaces for failing tests:

```bash @skip-check
DEBUG=lmz.proxy-fetch.queue npm test
```

### Production Debugging

Add `DEBUG` to environment variables temporarily to debug production issues without code changes.

### Common Filtering Scenarios

**Scenario 1: Only your application logging (hide all Lumenize internals)**

```bash @skip-check
# In .dev.vars or environment variables
DEBUG=my-app.*
```

This shows only your application's debug logs, completely hiding Lumenize framework logging.

**Scenario 2: Your app + specific Lumenize subsystem**

```bash @skip-check
# Debug your app and see what routeDORequest is doing
DEBUG=my-app.*,lmz.utils.route-do-request
```

Useful when debugging routing issues - you see your app logs plus the routing details from Lumenize.

**Scenario 3: Debugging authentication/connection callbacks**

```typescript @skip-check
// In your Worker code
import { routeDORequest } from '@lumenize/utils';
import { debug } from '@lumenize/core';

export default {
  async fetch(request: Request, env: Env) {
    return await routeDORequest(request, env, {
      onBeforeConnect: async (request, context) => {
        // Create logger for your callback
        const log = debug({ env })('my-app.onBeforeConnect');
        
        log.debug('WebSocket connection attempt', {
          origin: request.headers.get('Origin'),
          doInstance: context.doInstanceNameOrId
        });
        
        // Your auth logic here
        const token = request.headers.get('Authorization');
        if (!token) {
          log.warn('Connection rejected - missing auth', {
            doInstance: context.doInstanceNameOrId
          });
          return new Response('Unauthorized', { status: 401 });
        }
        
        log.info('Connection authorized', {
          doInstance: context.doInstanceNameOrId
        });
      }
    });
  }
}
```

Then enable it:

```bash @skip-check
# See your auth callback logs and routing behavior
DEBUG=my-app.onBeforeConnect,lmz.utils.route-do-request
```

**Scenario 4: Everything except Lumenize internals**

```bash @skip-check
# Enable all logging but hide Lumenize framework noise
DEBUG=*,-lmz.*
```

Useful when you're using multiple libraries and want to see their debug output without Lumenize cluttering the logs.

### State Tracking

Use debug logs to track state changes and data flow:

```typescript @skip-check
import '@lumenize/core';
import { LumenizeBase } from '@lumenize/lumenize-base';

class CounterDO extends LumenizeBase<Env> {
  increment(delta: number) {
    const log = this.svc.debug('counter.operations');
    
    const before = this.ctx.storage.kv.get('count') ?? 0;
    const after = before + delta;
    
    log.debug('Incrementing counter', { 
      before, 
      delta, 
      after 
    });
    
    if (after > 1000) {
      log.warn('Counter exceeds threshold', { 
        value: after, 
        threshold: 1000 
      });
    }
    
    this.ctx.storage.kv.set('count', after);
    
    log.info('Counter updated', { 
      newValue: after,
      isHighValue: after > 1000
    });
    
    return after;
  }
}
```

## TypeScript Integration

The package provides full TypeScript support with NADIS auto-registration:

```typescript @skip-check
// After importing '@lumenize/debug', TypeScript knows about it
import '@lumenize/debug';
import { LumenizeBase } from '@lumenize/lumenize-base';

class MyDO extends LumenizeBase<Env> {
  myMethod() {
    // ✅ TypeScript autocomplete works
    const log = this.svc.debug('my-namespace');
    log.debug('message', { data });  // ✅ Type checked
  }
}
```

## Best Practices

1. **Use object format**: Always pass data as second parameter object
2. **Descriptive messages**: Make messages searchable (e.g., "CORS origin rejected", not "rejected")
3. **Structured data**: Include relevant context (IDs, counts, flags)
4. **Appropriate levels**: 
   - `debug` - Everything
   - `info` - Milestones, events
   - `warn` - Expected issues
5. **Namespace organization**: Use dot-notation hierarchy (package.component.feature)
6. **Performance**: Check `log.enabled` before expensive computations

## Comparison with npm's `debug`

Similarities:
- Namespace filtering with wildcards
- Environment variable configuration
- Zero-cost when disabled

Differences:
- **Level support**: debug, info, warn (vs. single level)
- **JSON output**: Structured objects (vs. plain text)
- **Cloudflare-optimized**: No colors, no TTY detection
- **NADIS integration**: Auto-injection in LumenizeBase

## License

MIT

