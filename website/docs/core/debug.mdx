---
title: "Debug"
description: "Scoped, filterable debug logging optimized for Cloudflare's JSON log dashboard"
---

# Debug

A de✨light✨ful scoped debug logging system for Cloudflare Durable Objects, inspired by npm's `debug` package with level support and JSON output.

Part of `@lumenize/core`.

## Features

- **Namespace filtering**: Use dot-notation scopes (e.g., `lmz.proxy-fetch.serialization`) with wildcard patterns
- **Level support**: `debug`, `info`, `warn`, and `error` levels
- **JSON output**: Structured logs integrate seamlessly with Cloudflare's log dashboard
- **Zero-cost when disabled**: Early exit via `enabled` flag - no string interpolation or object creation
- **NADIS integration**: Use standalone or auto-inject into `LumenizeBase` via `this.svc.debug`
- **⚠️ Error level never filtered**: `log.error()` always outputs regardless of DEBUG environment variable

## Installation

```bash @skip-check
npm install @lumenize/core
```

## Quick Start

### In Durable Objects (LumenizeBase)

```typescript @skip-check
import '@lumenize/core';  // Registers in this.svc
import { LumenizeBase } from '@lumenize/lumenize-base';

class MyDO extends LumenizeBase<Env> {
  async fetch(request: Request) {
    const log = this.svc.debug('my-app.http');
    
    const url = new URL(request.url);
    log.debug('Processing request', { 
      pathname: url.pathname,
      method: request.method 
    });
    
    // Update counter in storage
    const count = (this.ctx.storage.kv.get('requestCount') ?? 0) + 1;
    this.ctx.storage.kv.set('requestCount', count);
    
    log.info('Request completed', { 
      requestCount: count,
      pathname: url.pathname
    });
    
    return new Response('OK');
  }
}
```

### In Vanilla Durable Objects

```typescript @skip-check
import { debug } from '@lumenize/core';
import { DurableObject } from 'cloudflare:workers';

class MyDO extends DurableObject {
  #log = debug(this)('my-namespace');
  
  async fetch(request: Request) {
    this.#log.debug('Processing request', { url: request.url });
    return new Response('OK');
  }
}
```

### In Workers (outside DOs)

```typescript @skip-check
import { debug } from '@lumenize/core';

export default {
  async fetch(request: Request, env: Env) {
    const log = debug({ env })('worker.router');
    
    log.debug('Routing request', { 
      pathname: new URL(request.url).pathname 
    });
    
    // Route to DO...
    return response;
  }
}
```

## Configuration

Control logging via the `DEBUG` environment variable (in `.dev.vars` for local development):

```bash @skip-check
# Enable all levels for a namespace
DEBUG=lmz.proxy-fetch

# Enable only warn level
DEBUG=lmz.proxy-fetch:warn

# Multiple namespaces
DEBUG=lmz.proxy-fetch,lmz.rpc.client

# Wildcard patterns
DEBUG=lmz.proxy-fetch.*

# Everything (both your app and Lumenize)
DEBUG=*

# Only your app (exclude all Lumenize internal logging)
DEBUG=my-app.*

# Your app plus specific Lumenize subsystem
DEBUG=my-app.*,lmz.utils.route-do-request

# Everything except Lumenize internals
DEBUG=*,-lmz.*

# Exclusions (enable all Lumenize except one verbose part)
DEBUG=lmz.*,-lmz.proxy-fetch.queue
```

### Level Filtering

Each namespace can have a level filter:

- `DEBUG=app` - All filterable levels (debug, info, warn)
- `DEBUG=app:info` - Info and warn only
- `DEBUG=app:warn` - Warn only
- `DEBUG=app:error` - Would only enable error, but error ALWAYS outputs anyway

**⚠️ IMPORTANT**: The `error` level is NEVER filtered and always outputs, regardless of your DEBUG configuration.

## Log Output Format

All logs output as JSON objects to `console.debug`:

```json @skip-check
{
  "level": "debug",
  "namespace": "lmz.proxy-fetch.queue",
  "message": "Processing request",
  "url": "https://api.example.com/data",
  "method": "POST",
  "timestamp": 1699564800000
}
```

This format integrates with Cloudflare's log dashboard, allowing you to:
- Query by field (e.g., `namespace:"lmz.proxy-fetch.queue"`)
- Filter by level
- Search message content
- Analyze structured data

## API

The debug system provides a simple, type-safe logging interface:

```typescript
// Create logger
const log = this.svc.debug('my-app.feature');  // LumenizeBase
const log = debug(this)('my-app.feature');     // Vanilla DO
const log = debug({ env })('my-app.feature');  // Worker

// Log at different levels
log.debug(message: string, data?: any);  // Most verbose
log.info(message: string, data?: any);   // Milestones, events
log.warn(message: string, data?: any);   // Expected operational issues
log.error(message: string, data?: any);  // ⚠️ ALWAYS outputs - never filtered

// Check if enabled (for expensive operations)
if (log.enabled) { /* ... */ }
```

See [Error Logging](#error-logging) for detailed examples of when to use each level.

## Namespace Conventions

Use dot-notation hierarchies to organize your logging:

**Your application** (no prefix):
- `my-app.main`, `my-app.auth`, `my-app.websocket`
- More specific: `my-app.auth.session`, `my-app.chat.room`

**Lumenize internals** (`lmz.` prefix):
- `lmz.rpc.client`, `lmz.proxy-fetch.queue`, `lmz.utils.route-do-request`

This separation allows targeted filtering:
```bash
DEBUG=my-app.*              # Only your app
DEBUG=lmz.*                 # Only Lumenize
DEBUG=my-app.*,lmz.rpc.*    # Your app + specific subsystem
DEBUG=*,-lmz.*              # Everything except Lumenize
```


## Error Logging

The debug system includes an `error()` level that **ALWAYS outputs, regardless of DEBUG filter**. This gives you structured JSON logging for errors while ensuring they're never accidentally hidden.

### When to Use Each Level

Use this decision tree to choose the right level:

```
Is this an unexpected system failure, bug, or assertion violation?
├─ YES → Use log.error() [NEVER filtered]
└─ NO → Is this an expected operational issue?
    ├─ YES → Use log.warn() [filterable]
    └─ NO → Is this a milestone or important event?
        ├─ YES → Use log.info() [filterable]
        └─ NO → Use log.debug() [filterable]
```

### Examples

```typescript @skip-check
import '@lumenize/core';
import { LumenizeBase } from '@lumenize/lumenize-base';

class MyDO extends LumenizeBase<Env> {
  async fetch(request: Request) {
    const log = this.svc.debug('my-app.main');
    
    // ERROR: Unexpected system failure (always logged)
    try {
      const stub = this.env.SOME_DO.get(this.env.SOME_DO.idFromName('test'));
      return await stub.fetch(request);
    } catch (e) {
      log.error('Unexpected DO fetch failure', {
        error: e.message,
        stack: e.stack,
        url: request.url
      });
      return new Response('Internal Server Error', { status: 500 });
    }
  }
  
  async processWithRetry(reqId: string) {
    const log = this.svc.debug('my-app.processor');
    let retryCount = 0;
    
    // WARN: Expected operational issue (filterable)
    while (retryCount < 3) {
      try {
        await this.doWork();
        return;
      } catch (e) {
        if (++retryCount >= 3) {
          log.warn('Retry limit exhausted', { reqId, retryCount });
          throw e;
        }
      }
    }
  }
  
  async authenticate(token: string) {
    const log = this.svc.debug('my-app.auth');
    
    // WARN: Expected - users provide bad tokens
    if (!token || !await this.validateToken(token)) {
      log.warn('Authentication failed', { hasToken: !!token });
      return null;
    }
    
    // INFO: Milestone/event
    log.info('User authenticated', { tokenExpiry: this.getExpiry(token) });
    return { authenticated: true };
  }
  
  processRequest(request: Request) {
    const log = this.svc.debug('my-app.processor');
    
    // DEBUG: Detailed diagnostics
    log.debug('Processing request', {
      method: request.method,
      contentType: request.headers.get('content-type')
    });
  }
}
```

## Common Patterns

**Development:**
```bash
DEBUG=*                     # See everything
```

**Testing:**
```bash
DEBUG=my-app.feature        # Target specific feature
DEBUG=lmz.rpc.*            # Debug Lumenize subsystem
```

**Production:**
Add DEBUG to environment variables temporarily to debug issues without code changes.

**Filtering scenarios:**
```bash
DEBUG=my-app.*                           # Only your app
DEBUG=my-app.*,lmz.utils.route-do-request  # App + specific Lumenize component
DEBUG=*,-lmz.*                           # Everything except Lumenize
```

**Debugging callbacks:**
```typescript @skip-check
// In Worker
export default {
  async fetch(request: Request, env: Env) {
    return await routeDORequest(request, env, {
      onBeforeConnect: async (request, context) => {
        const log = debug({ env })('my-app.onBeforeConnect');
        
        const token = request.headers.get('Authorization');
        if (!token) {
          log.warn('Connection rejected - missing auth', {
            doInstance: context.doInstanceNameOrId
          });
          return new Response('Unauthorized', { status: 401 });
        }
        
        log.info('Connection authorized');
      }
    });
  }
}
```

Then enable: `DEBUG=my-app.onBeforeConnect,lmz.utils.route-do-request`

## Best Practices

1. **Use object format** - Always pass data as second parameter (not template literals)
   ```typescript
   log.debug('Processing', { count: items.length });  // ✅ Zero-cost when disabled
   log.debug(`Processing ${items.length} items`);     // ❌ String interpolation always runs
   ```

2. **Descriptive messages** - Make messages searchable: "CORS origin rejected", not "rejected"

3. **Structured data** - Include relevant context: IDs, counts, flags, timestamps

4. **Right level for the job**:
   - `error` - Unexpected failures, bugs (NEVER filtered)
   - `warn` - Expected operational issues (retry exhausted, auth failed)
   - `info` - Milestones, events (connection established, batch complete)
   - `debug` - Detailed diagnostics (parsing, cache lookups)

5. **Namespace hierarchy** - Use dot-notation: `my-app.auth.session`, `lmz.rpc.client`

6. **Performance** - Check `log.enabled` before expensive operations:
   ```typescript
   if (log.enabled) {
     const expensiveData = computeExpensiveDetails();
     log.debug('Details', expensiveData);
   }
   ```

## Comparison with npm's `debug`

Similarities:
- Namespace filtering with wildcards
- Environment variable configuration
- Zero-cost when disabled

Differences:
- **Level support**: debug, info, warn, error (vs. single level)
- **Error level**: Never filtered - always outputs
- **JSON output**: Structured objects (vs. plain text)
- **Cloudflare-optimized**: No colors, no TTY detection
- **NADIS integration**: Auto-injection in LumenizeBase

## License

MIT

