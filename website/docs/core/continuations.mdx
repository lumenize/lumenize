---
title: Continuations
description: Non-blocking async operations with type-safe callbacks for Durable Objects
---

# Continuations

**Continuations** are Lumenize's pattern for handling asynchronous operations in Durable Objects without blocking. Instead of using `async`/`await` (which breaks Cloudflare's consistency guarantees), you describe what should happen next using **operation chains**.

:::tip Key Concept
A continuation is a **description of future work** that gets executed later with the result of an async operation. It maintains DO consistency by keeping the handler synchronous.
:::

## Why Continuations?

Durable Objects have special consistency guarantees, but only if you follow their rules:

**❌ Don't Do This** (breaks consistency):
```typescript @skip-check
class MyDO extends DurableObject {
  async fetch(request: Request) {
    // This async method can be interrupted!
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    
    // ⚠️ Another request could execute here, causing race conditions
    this.ctx.storage.kv.put('data', data);
  }
}
```

**✅ Do This Instead** (maintains consistency):
```typescript @skip-check
class MyDO extends LumenizeBase {
  async fetch(request: Request) {
    // Non-blocking: returns immediately
    await proxyFetchWorker(
      this,
      'https://api.example.com/data',
      this.ctn().handleResponse(this.ctn().$result) // Continuation!
    );
    
    return new Response('Processing...');
  }
  
  // Synchronous handler - no race conditions
  handleResponse(result: Response | Error) {
    if (result instanceof Error) {
      console.error('Failed:', result);
      return;
    }
    
    const data = await result.json();
    this.ctx.storage.kv.put('data', data);
  }
}
```

## The `this.ctn()` Factory

Every DO that extends `LumenizeBase` has access to `this.ctn()`, which creates continuation chains:

```typescript @skip-check
// Simple method call
this.ctn().myHandler(this.ctn().$result)

// Chaining
this.ctn().processData(this.ctn().$result).saveToStorage()

// With multiple arguments
this.ctn().updateUser(userId, this.ctn().$result, timestamp)
```

### How It Works

1. **`this.ctn()`** returns a Proxy object
2. Each method/property access builds an **operation chain**
3. The chain is serialized and stored
4. When the async operation completes, the chain is executed with the result

## The `$result` Placeholder

The special `$result` property marks where the async operation's result should be injected:

```typescript @skip-check
// $result will be replaced with the actual Response or Error
this.ctn().handleFetchResult(this.ctn().$result)

// You can use it anywhere in the arguments
this.ctn().processWithContext(metadata, this.ctn().$result, timestamp)
```

### Result Types

Handlers receive a **union type** of the expected result and `Error`:

```typescript @skip-check
// For fetch operations
handleFetchResult(result: Response | Error) {
  if (result instanceof Error) {
    // Network failure, timeout, etc.
    return;
  }
  
  // Success - process the response
  const data = await result.text();
}

// For DO-to-DO calls
handleRemoteResult(result: any | Error) {
  if (result instanceof Error) {
    // Remote DO threw an error
    return;
  }
  
  // Success - use the result
  console.log('Got:', result);
}
```

## Common Patterns

### 1. Simple Callback

```typescript @skip-check
class MyDO extends LumenizeBase {
  async startWork() {
    await call(
      this,
      'REMOTE_DO',
      'instance-id',
      this.ctn().remoteMethod(arg),
      this.ctn().handleResult(this.ctn().$result)
    );
  }
  
  handleResult(result: any | Error) {
    if (result instanceof Error) {
      console.error('Call failed:', result);
      return;
    }
    
    console.log('Got result:', result);
  }
}
```

### 2. Chaining Operations

```typescript @skip-check
class MyDO extends LumenizeBase {
  async processData(url: string) {
    await proxyFetchWorker(
      this,
      url,
      // Chain: fetch → parse → validate → save
      this.ctn()
        .parseResponse(this.ctn().$result)
        .validateData()
        .saveToStorage()
    );
  }
  
  parseResponse(result: Response | Error) {
    if (result instanceof Error) throw result;
    return result.json();
  }
  
  validateData(data: any) {
    if (!data.id) throw new Error('Invalid data');
    return data;
  }
  
  saveToStorage(data: any) {
    this.ctx.storage.kv.put(`data:${data.id}`, data);
  }
}
```

### 3. Context Preservation

```typescript @skip-check
class MyDO extends LumenizeBase {
  async fetchForUser(userId: string, url: string) {
    const timestamp = Date.now();
    
    await proxyFetchWorker(
      this,
      url,
      // Capture context in the continuation
      this.ctn().handleUserData(userId, this.ctn().$result, timestamp)
    );
  }
  
  handleUserData(userId: string, result: Response | Error, timestamp: number) {
    if (result instanceof Error) {
      this.ctx.storage.kv.put(`user:${userId}:error`, {
        error: result.message,
        timestamp
      });
      return;
    }
    
    const data = await result.json();
    this.ctx.storage.kv.put(`user:${userId}:data`, {
      data,
      timestamp
    });
  }
}
```

## Under the Hood

Continuations are built on **OCAN** (Operation Chaining and Nesting):

1. **Proxy Factory**: `this.ctn()` returns a Proxy that records operations
2. **Serialization**: The operation chain is serialized via `structured-clone`
3. **Storage**: Stored in DO storage until the result arrives
4. **Deserialization**: Chain is deserialized when result arrives
5. **Execution**: Chain is executed with `$result` replaced by actual result

This ensures:
- ✅ **Type safety**: TypeScript validates the method chains
- ✅ **Serialization**: Chains survive DO eviction/restart
- ✅ **Consistency**: Handlers execute synchronously (no race conditions)
- ✅ **Flexibility**: Complex flows without callback hell

## Error Handling

Always check for `Error` in your handlers:

```typescript @skip-check
handleResult(result: any | Error) {
  // Guard clause pattern (recommended)
  if (result instanceof Error) {
    console.error('Operation failed:', result.message);
    // Handle error, notify user, retry, etc.
    return;
  }
  
  // Success path - TypeScript knows result is not an Error here
  this.ctx.storage.kv.put('result', result);
}
```

:::warning Important
If you don't check for `Error`, your handler might crash when operations fail. Always use `if (result instanceof Error)` at the start of handlers.
:::

## Best Practices

### ✅ Do

- Check for `Error` first in every handler
- Keep handlers synchronous (no `async` unless wrapped in `ctx.waitUntil`)
- Use descriptive handler names
- Chain related operations together
- Preserve context by passing it as arguments

### ❌ Don't

- Don't use `async` handlers (breaks consistency)
- Don't ignore errors (check `instanceof Error`)
- Don't store sensitive data in continuation chains (they're serialized)
- Don't create circular references (serialization will fail)

## Next Steps

- **[@lumenize/lumenize-base](/docs/lumenize-base/index)** - DO-to-DO communication with `this.lmz.call()`
- **[@lumenize/alarms](/docs/alarms/index)** - Scheduled tasks with continuations
- **[@lumenize/proxy-fetch](/docs/proxy-fetch/proxy-fetch-worker)** - External fetches with continuations
- **[OCAN](/docs/core/ocan)** - The operation chaining pattern underlying continuations

