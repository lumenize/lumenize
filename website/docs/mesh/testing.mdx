---
title: Testing
description: Testing Lumenize Mesh applications with multi-user scenarios and RPC verification
---

# Testing

This document demonstrates testing Lumenize Mesh applications using `@lumenize/testing`. We cover:

1. **Multi-user collaboration** - Testing state synchronization across multiple WebSocket connections with separate `Browser` instances
2. **Magic link authentication** - Using `testLoginWithMagicLink` for realistic auth flows
3. **RPC storage access** - Inspecting and modifying DO storage directly for test verification

For basic usage of `@lumenize/testing`, see the [usage documentation](/docs/testing/usage). For testing Cloudflare's `Agent` class, see [Testing Agents](/docs/testing/agents).

## Why testing LumenizeClient is hard

Testing real-time collaborative applications typically requires:
- Separate processes for server and client
- Complex WebSocket mocking or live connections
- Manual token management for auth flows
- No direct access to server-side state for verification

`@lumenize/testing` solves all of these by providing:
- **Browser simulation** with cookie isolation for multi-user scenarios
- **WebSocket injection** that works with `vitest-pool-workers`
- **`testLoginWithMagicLink`** for complete auth flow simulation
- **RPC access** to DO internals via `createTestingClient`

## Multi-user collaboration example

This example demonstrates testing a collaborative document editor where:
- Multiple users connect via separate `Browser` instances (cookie isolation)
- Users authenticate via magic link flow
- Real-time updates broadcast to all subscribers
- Server-side spell checking sends results to originators

### The test

```typescript @skip-check
import { it, expect, vi } from 'vitest';
import { Browser } from '@lumenize/testing';
import { testLoginWithMagicLink } from '@lumenize/auth';
import { EditorClient } from './editor-client.js';
import type { SpellFinding } from './spell-check-worker.js';

it('collaborative document editing with multiple clients', async () => {
  const documentId = 'collab-doc-1';

  // Track events for each client
  const aliceEvents = { content: [] as string[], spellFindings: [] as SpellFinding[][] };
  const bobEvents = { content: [] as string[], spellFindings: [] as SpellFinding[][] };

  // ============================================
  // Phase 1: Alice connects and opens a document
  // ============================================

  const aliceBrowser = new Browser();
  const aliceUserId = await testLoginWithMagicLink(aliceBrowser, 'alice@example.com');

  // Use `using` for automatic cleanup via Symbol.dispose
  using alice = new EditorClient({
    instanceName: `${aliceUserId}.tab1`,
    baseUrl: 'https://localhost',
    refresh: 'https://localhost/auth/refresh-token',
    // Test-specific: inject browser's fetch/WebSocket
    fetch: aliceBrowser.fetch,
    WebSocket: aliceBrowser.WebSocket,
  });

  await vi.waitFor(() => {
    expect(alice.connectionState).toBe('connected');
  });

  // Alice opens the document - should receive empty content for new document
  const aliceDoc = alice.openDocument(documentId, {
    onContentUpdate: (content) => aliceEvents.content.push(content),
    onSpellFindings: (findings) => aliceEvents.spellFindings.push(findings),
  });

  await vi.waitFor(() => {
    expect(aliceEvents.content[0]).toBe('');
  });

  // ============================================
  // Phase 2: Alice starts writing the document
  // ============================================

  aliceDoc.saveContent('The quick brown fox');

  // Alice should receive the broadcast of her own update
  await vi.waitFor(() => {
    expect(aliceEvents.content[1]).toBe('The quick brown fox');
  });

  // ============================================
  // Phase 3: Bob connects and opens the same document
  // ============================================

  const bobBrowser = new Browser();
  const bobUserId = await testLoginWithMagicLink(bobBrowser, 'bob@example.com');

  using bob = new EditorClient({
    instanceName: `${bobUserId}.tab1`,
    baseUrl: 'https://localhost',
    refresh: 'https://localhost/auth/refresh-token',
    fetch: bobBrowser.fetch,
    WebSocket: bobBrowser.WebSocket,
  });

  await vi.waitFor(() => {
    expect(bob.connectionState).toBe('connected');
  });

  // Bob opens the same document - should receive current content
  const bobDoc = bob.openDocument(documentId, {
    onContentUpdate: (content) => bobEvents.content.push(content),
    onSpellFindings: (findings) => bobEvents.spellFindings.push(findings),
  });

  await vi.waitFor(() => {
    expect(bobEvents.content[0]).toBe('The quick brown fox');
  });

  // ============================================
  // Phase 4: Bob continues the document, both receive the broadcast
  // ============================================

  bobDoc.saveContent('The quick brown fox jumps over teh lazy dog.');

  // Both Alice and Bob should receive the broadcast
  await vi.waitFor(() => {
    expect(aliceEvents.content[2]).toBe('The quick brown fox jumps over teh lazy dog.');
    expect(bobEvents.content[1]).toBe('The quick brown fox jumps over teh lazy dog.');
  });

  // ============================================
  // Phase 5: Spell check findings go only to the originator
  // ============================================

  // The spell checker sends results directly to the client who made the update.
  // Only Bob should receive findings (he made the update with "teh").
  await vi.waitFor(() => {
    expect(bobEvents.spellFindings.length).toBeGreaterThan(0);
  });

  // Alice should NOT receive spell findings (she didn't make this update)
  expect(aliceEvents.spellFindings.length).toBe(0);

  // Verify Bob's findings
  const bobFindings = bobEvents.spellFindings.at(-1)!;
  expect(bobFindings[0].word).toBe('teh');
  expect(bobFindings[0].suggestions).toContain('the');

  // Cleanup: close document handles (clients auto-disconnect via `using`)
  aliceDoc.close();
  bobDoc.close();
});
```

## Key patterns

### Browser isolation for multi-user testing

Each user needs their own `Browser` instance for cookie isolation:

```typescript @skip-check
const aliceBrowser = new Browser();
const bobBrowser = new Browser();

// Each browser has its own cookie jar
// Auth cookies from Alice's login won't leak to Bob
```

### Magic link authentication

`testLoginWithMagicLink` simulates the complete magic link flow:

```typescript @skip-check
import { testLoginWithMagicLink } from '@lumenize/auth';

// Requires AUTH_TEST_MODE=true in your .dev.vars
const userId = await testLoginWithMagicLink(browser, 'alice@example.com');

// Browser now has refresh-token cookie stored
// Pass browser.fetch and browser.WebSocket to LumenizeClient
```

This function:
1. Requests a magic link (test mode returns URL in response)
2. "Clicks" the magic link (Browser follows redirect and captures cookies)
3. Exchanges refresh token cookie for access token
4. Returns the userId from the JWT

### WebSocket and fetch injection

`LumenizeClient` accepts `fetch` and `WebSocket` in its constructor for testing:

```typescript @skip-check
const client = new EditorClient({
  instanceName: `${userId}.tab1`,
  baseUrl: 'https://localhost',
  refresh: 'https://localhost/auth/refresh-token',
  // Inject browser's implementations
  fetch: browser.fetch,
  WebSocket: browser.WebSocket,
});
```

This enables:
- Cookie sharing between HTTP requests and WebSocket handshake
- Full request/response inspection
- Realistic CORS behavior

### RPC access to DO storage

Use `createTestingClient` to directly inspect or modify DO storage:

```typescript @skip-check
import { createTestingClient } from '@lumenize/testing';
import type { RpcAccessible } from '@lumenize/testing';
import type { DocumentDO } from './document-do.js';

type DocumentDOType = RpcAccessible<InstanceType<typeof DocumentDO>>;

// Create RPC client for direct DO access
using client = createTestingClient<DocumentDOType>('DOCUMENT_DO', 'collab-doc-1');

// Read storage directly
const content = await client.ctx.storage.kv.get('content');
expect(content).toBe('The quick brown fox');

// Read subscribers set
const subscribers = await client.ctx.storage.kv.get('subscribers');
expect(subscribers.size).toBe(2);

// You can also write to storage for test setup
await client.ctx.storage.kv.put('content', 'Pre-populated content');
```

### Using `vi.waitFor()` for async events

Always use `vi.waitFor()` for WebSocket events and async state changes:

```typescript @skip-check
// Wait for connection
await vi.waitFor(() => {
  expect(client.connectionState).toBe('connected');
});

// Wait for broadcast to arrive
await vi.waitFor(() => {
  expect(events.content.length).toBeGreaterThan(0);
});
```

## Installation

```bash
npm install --save-dev vitest@3.2
npm install --save-dev @cloudflare/vitest-pool-workers
npm install --save-dev @lumenize/testing
```

## Configuration

### vitest.config.js

```javascript @skip-check
import { defineWorkersProject } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersProject({
  test: {
    testTimeout: 5000,
    poolOptions: {
      workers: {
        // Must be false for WebSocket support
        isolatedStorage: false,
        wrangler: { configPath: "./test/wrangler.jsonc" },
      },
    },
  },
});
```

### .dev.vars

Enable test mode for magic link authentication:

```
AUTH_TEST_MODE=true
```

### test/wrangler.jsonc

Point to your test harness that instruments DO classes:

```json
{
  "name": "my-app-test",
  "main": "./test-harness.ts",
  "compatibility_date": "2025-09-12",
  // ... rest of config
}
```

### test/test-harness.ts

```typescript @skip-check
import * as sourceModule from '../src';
import { instrumentDOProject } from '@lumenize/testing';

const instrumented = instrumentDOProject({
  sourceModule,
  doClassNames: ['DocumentDO', 'LumenizeClientGateway', 'LumenizeAuth']
});

export const { DocumentDO, LumenizeClientGateway, LumenizeAuth } = instrumented.dos;
export default instrumented;
```

## Tips

- **Use `using`** for automatic cleanup of LumenizeClient connections
- **Separate Browser instances** for each user to ensure cookie isolation
- **`vi.waitFor()`** for all async assertions (WebSocket events, broadcasts)
- **RPC clients** for test setup/verification without going through the public API
- **`testLoginWithMagicLink`** for realistic auth flows without manual token management
