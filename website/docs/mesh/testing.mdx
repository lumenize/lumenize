---
title: Testing
description: Testing Lumenize Mesh applications with multi-user scenarios and RPC verification
---

# Testing

Testing Lumenize Mesh applications using `@lumenize/testing`. For basic usage of `@lumenize/testing`, see the [usage documentation](/docs/testing/usage).

## Why testing real-time code is hard

Testing real-time collaborative applications typically requires:
- Separate processes for server and client
- Complex WebSocket mocking or live connections
- Manual token management for auth flows
- No direct access to server-side state for verification

`@lumenize/testing` solves all of these by providing:
- **Browser simulation** with cookie isolation for multi-user scenarios
- **WebSocket injection** that works with `vitest-pool-workers`
- **`testLoginWithMagicLink`** for complete auth flow simulation
- **RPC access** to DO internals via `createTestingClient`

## Installation

```bash
npm install --save-dev vitest@3.2
npm install --save-dev @cloudflare/vitest-pool-workers
npm install --save-dev @lumenize/testing
```

## Configuration

### vitest.config.js

```javascript @skip-check-approved('conceptual')
import { defineWorkersProject } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersProject({
  test: {
    testTimeout: 5000,
    poolOptions: {
      workers: {
        // Must be false for WebSocket support
        isolatedStorage: false,
        wrangler: { configPath: "./test/wrangler.jsonc" },
      },
    },
  },
});
```

Enable test mode for `testLoginWithMagicLink` in your vitest config's miniflare bindings (never in wrangler.jsonc):

```javascript @check-example('packages/mesh/vitest.config.js')
miniflare: {
  bindings: { LUMENIZE_AUTH_TEST_MODE: 'true' },
},
```

### test/wrangler.jsonc

Point to your test harness that instruments DO classes:

```json
{
  "name": "my-app-test",
  "main": "./test-harness.ts",
  "compatibility_date": "2025-09-12",
  // ... rest of config
}
```

### test/test-harness.ts

The test harness wraps your DO classes with RPC instrumentation so `createTestingClient` can access storage and other internals:

```typescript @check-example('packages/mesh/test/for-docs/getting-started/test/test-harness.ts')
import * as sourceModule from '../index.js';
import { instrumentDOProject } from '@lumenize/testing';

// ...
const instrumented = instrumentDOProject({
  sourceModule,
  doClassNames: ['LumenizeClientGateway', 'DocumentDO', 'LumenizeAuth'],
});

// ...
export const { LumenizeClientGateway, DocumentDO, LumenizeAuth } = instrumented.dos;

// ...
export default instrumented;
```

## Multi-user collaboration example

The following test exercises the full mesh architecture: two users connect via separate `Browser` instances (cookie isolation), authenticate via magic link, exchange real-time updates via broadcasts, and receive targeted spell-check results.

```typescript @check-example('packages/mesh/test/for-docs/getting-started/index.test.ts')
import { it, expect, vi } from 'vitest';
import { createTestingClient, Browser } from '@lumenize/testing';
import { testLoginWithMagicLink } from '@lumenize/auth';
import { EditorClient } from './editor-client.js';
// ...

it('collaborative document editing with multiple clients', async () => {
  const documentId = 'collab-doc-1';

  // ...
  const events = { content: [] as string[], spellFindings: [] as SpellFinding[][] };
  const bobEvents = { content: [] as string[], spellFindings: [] as SpellFinding[][] };

  // ...

  const browser = new Browser();
  const aliceCtx = browser.context('https://localhost');
  await testLoginWithMagicLink(browser, 'alice@example.com', { subjectData: { adminApproved: true } });

  // ...

  using client = new EditorClient({
    baseUrl: 'https://localhost',
    refresh: 'https://localhost/auth/refresh-token',
    fetch: browser.fetch,
    WebSocket: browser.WebSocket,
    sessionStorage: aliceCtx.sessionStorage,
    BroadcastChannel: aliceCtx.BroadcastChannel,
  });

  await vi.waitFor(() => {
    expect(client.connectionState).toBe('connected');
  });

  const doc = client.openDocument(documentId, {
    onContentUpdate: updateEditor,
    onSpellFindings: showSpellingSuggestions,
  });

  await vi.waitFor(() => {
    expect(events.content[0]).toBe('');
  });

  doc.saveContent('The quick brown fox');

  await vi.waitFor(() => {
    expect(events.content[1]).toBe('The quick brown fox');
  });

  // ...

  const bobBrowser = new Browser();
  const bobCtx = bobBrowser.context('https://localhost');
  await testLoginWithMagicLink(bobBrowser, 'bob@example.com', { subjectData: { adminApproved: true } });

  using bob = new EditorClient({
    baseUrl: 'https://localhost',
    refresh: 'https://localhost/auth/refresh-token',
    fetch: bobBrowser.fetch,
    WebSocket: bobBrowser.WebSocket,
    sessionStorage: bobCtx.sessionStorage,
    BroadcastChannel: bobCtx.BroadcastChannel,
  });

  await vi.waitFor(() => {
    expect(bob.connectionState).toBe('connected');
  });

  // ...

  const bobDoc = bob.openDocument(documentId, {
    onContentUpdate: updateBobEditor,
    onSpellFindings: showBobSpellingSuggestions,
  });

  await vi.waitFor(() => {
    expect(bobEvents.content[0]).toBe('The quick brown fox');
  });

  // ...

  // Verify Bob is subscribed via direct storage inspection
  {
    using docClient = createTestingClient<typeof DocumentDO>('DOCUMENT_DO', documentId);
    const subscribers = await docClient.ctx.storage.kv.get<Set<string>>('subscribers');
    expect(subscribers).toBeInstanceOf(Set);
    expect(subscribers!.has(bob.lmz.instanceName)).toBe(true);
  }

  // ...
  bobDoc.saveContent('The quick brown fox jumps over teh lazy dog.');

  // ...
  await vi.waitFor(() => {
    expect(events.content.at(-1)).toBe('The quick brown fox jumps over teh lazy dog.');
    expect(bobEvents.content.at(-1)).toBe('The quick brown fox jumps over teh lazy dog.');
  });

  // ...
  await vi.waitFor(() => {
    expect(bobEvents.spellFindings.length).toBeGreaterThan(0);
  });

  // ...
  expect(events.spellFindings.length).toBe(0);

  // ...
  const bobFindings = bobEvents.spellFindings.at(-1)!;
  expect(bobFindings[0].word).toBe('teh');
  expect(bobFindings[0].suggestions).toContain('the');
  // ...
});
```

### What to notice

**`using` for automatic cleanup** — `using client` and `using bob` ensure WebSocket connections disconnect when the variables go out of scope. No manual `client.disconnect()` needed.

**Separate `Browser` instances** — Each user gets their own `Browser` with an independent cookie jar. Alice's auth cookies never leak to Bob.

**`testLoginWithMagicLink`** simulates the complete magic link flow:
1. Requests a magic link (test mode returns URL in response)
2. "Clicks" the magic link (Browser follows redirect and captures cookies)
3. Exchanges refresh token cookie for access token
4. Returns `{ sub, accessToken }` — `sub` from the refresh response

**`vi.waitFor()`** — WebSocket events arrive asynchronously. Never use `setTimeout` — `vi.waitFor()` retries the assertion until it passes or times out, giving you deterministic tests without arbitrary delays.

**`createTestingClient` for RPC access** — Directly inspect or modify DO storage without going through the public API. The test uses it to verify Bob's subscription was stored correctly. Also useful for pre-populating state during test setup.

### Dependency injection

`LumenizeClient` accepts testing overrides for dependency injection. Use `Browser` for cookie-aware HTTP/WebSocket, and `browser.context()` for per-tab sessionStorage and BroadcastChannel:

| Option | What to inject | Why |
|--------|---------------|-----|
| `fetch` | `browser.fetch` | Cookie-aware HTTP with CORS validation |
| `WebSocket` | `browser.WebSocket` | Cookie-aware WebSocket handshake |
| `sessionStorage` | `context.sessionStorage` | Per-tab tab ID persistence |
| `BroadcastChannel` | `context.BroadcastChannel` | Duplicate-tab detection across contexts |

For simpler tests that don't need tab ID isolation, `browser.fetch` and `browser.WebSocket` are sufficient.

Use `browser.duplicateContext(ctx)` to simulate browser tab duplication (clones sessionStorage, shares BroadcastChannel). The client's built-in duplicate-tab detection will automatically generate a fresh tab ID for the duplicate.
