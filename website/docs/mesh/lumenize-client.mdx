---
title: LumenizeClient
description: Browser and Node.js clients as full mesh peers
---

# LumenizeClient

`LumenizeClient` is the base class for **client-side mesh nodes** running anywhere outside of Cloudflare with JavaScript and WebSocket support (browsers, Node.js, bun, etc.). Clients are full mesh peers. They can both make and receive calls. They enjoy access to the same built in services and are coded the same way. For a hands-on introduction, see the [Getting Started Guide](./getting-started).

## How Clients Become Mesh Peers

Despites WebSocket's bidirectional nature, most WebSocket architectures make a distinction between client and server. Lumenize takes a different approach.

Each `LumenizeClient` connects via a hibernating WebSocket to its own dedicated [LumenizeClientGateway](./gateway) Durable Object instance. This Gateway acts as the client's proxy inside the mesh — any mesh node can call your client's `@mesh()` methods just like they'd call a DO or Worker. The Gateway maintains the connection, handles authentication, and routes messages bidirectionally.

This architecture means:
- **Server-initiated calls work** — A DO can call `this.lmz.call('LUMENIZE_CLIENT_GATEWAY', clientId, ...)` and your client's handler executes
- **Same API everywhere** — `this.lmz.call()`, `@mesh()`, and continuations work identically on clients
- **Automatic reconnection** — The client reconnects seamlessly; the Gateway preserves state during brief disconnections and has mechanisms for seamless restoration of state for longer ones

See [Gateway Internals](./gateway) for the full architecture and protocol details.

## Quick Start

```typescript @skip-check
class EditorClient extends LumenizeClient {
  @mesh()
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

// Minimal config — baseUrl defaults to origin, refresh defaults to /auth/refresh-token
using client = new EditorClient({
  instanceName: `${sub}.${tabId}`
});
```

Extend `LumenizeClient` and define `@mesh()` methods for incoming calls — the same pattern as `LumenizeDO` and `LumenizeWorker`.

## Configuration

### Connection & Identity

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `baseUrl` | `string?` | Current origin | WebSocket URL base. Required in Node.js. |
| `instanceName` | `string` | — | **Required.** Format: `{sub}.{tabId}`. Gateway validates `sub` matches JWT. |
| `gatewayBindingName` | `string?` | `LUMENIZE_CLIENT_GATEWAY` | [Gateway](./gateway) DO binding name. |

### Authentication

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `accessToken` | `string?` | — | Initial JWT. If omitted, fetched via `refresh` (recommended). |
| `refresh` | `string \| () => Promise<string>` | `/auth/refresh-token` | Token refresh endpoint or custom function. |

**Custom refresh example** (for non-standard auth providers):
```typescript @skip-check
using client = new EditorClient({
  instanceName: `${sub}.${tabId}`,
  refresh: async () => {
    const response = await fetch('/my/custom/refresh');  // Cookies sent automatically
    const data = await response.json();
    return data.token;  // Return just the access token string
  }
});
```

### Lifecycle Callbacks

| Callback | When Fired |
|----------|-----------|
| `onConnectionStateChange(state)` | State changes: `connecting`, `connected`, `reconnecting`, `disconnected` |
| `onLoginRequired(error)` | Re-login required (not routine token refresh) |
| `onSubscriptionsLost()` | After reconnection if grace period had expired |
| `onConnectionError(error)` | Low-level WebSocket errors (rarely actionable) |

## Mesh API

`LumenizeClient` shares the standard [Mesh API](./mesh-api) with all node types — `this.lmz` for identity and calls, `@mesh()` decorator for entry points, `onBeforeCall()` for access control, and `this.ctn<T>()` for continuations.

### Local vs Mesh Calls

Methods on your client class can be called two ways:

| Call Origin | Example | Access Control |
|-------------|---------|----------------|
| **Local** (your browser code) | `client.sendChange(change)` | No checks — direct method call |
| **Mesh** (from DO/Worker) | `this.lmz.call()` via Gateway | `@mesh()` decorator required |

This means you can have both public methods for your UI and `@mesh()` decorated methods for the mesh on the same class:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  // Called by your browser code — no @mesh needed
  sendChange(change: DocumentChange) {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().update(change));
  }

  // Called by mesh nodes — requires @mesh
  @mesh()
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}
```

## Connection Lifecycle

The WebSocket connection is established automatically upon instantiation. Use the `using` keyword for automatic cleanup:

```typescript @skip-check
{
  using client = new EditorClient(config);
  // ...
} // disconnects here
```

Or call `disconnect()` manually. Monitor state via `onConnectionStateChange` callback or check `client.connectionState` programmatically.

## Access Control

LumenizeClient has almost the exact same **secure-by-default** model as LumenizeDO and LumenizeWorker. The exception is that LumenizeClient's have one additional restriction. Calls originating from other LumenizeClients are rejected by default:

- ✅ Calls from LumenizeDOs and LumenizeWorkers are allowed
- ✅ Calls that originated from this same client instance (responses flowing back through the mesh) are also allowed
- ❌ Calls originating from other LumenizeClients are rejected

### Opting In to Calls From Other LumenizeClients

For collaborative features (cursors, voice/video signaling, etc.), override `onBeforeCall`:

```typescript @skip-check
class CollaborativeClient extends LumenizeClient {
  onBeforeCall() {
    // Note: NOT calling super.onBeforeCall() — we WANT to allow peers
    // Auth is already guaranteed by auth hooks — originAuth.sub always exists
  }

  @mesh()
  handlePeerCursor(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}
```

For method-level guards, see [Security](./security#method-level-meshguard).

## Reconnection & Subscription Loss

LumenizeClient handles flaky networks and tab hibernation automatically.

### Grace Period

When disconnected, the mesh maintains client state for at least a **5-second grace period**:

- **Within 5 seconds**: Reconnection is seamless — all subscriptions remain active
- **After 5 seconds**: Mesh nodes may clean up resources. Resubscribing is necessary.

### Handling Subscription Loss

After the client reconnects once the grace period has expired, `onSubscriptionsLost` fires:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  onSubscriptionsLost = () => {
    // Re-establish subscriptions
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}
```

## Handling Relogin

Token expiration is handled automatically — refresh and reconnect happen transparently. `onLoginRequired` only fires when the user must re-login (e.g., refresh token expired):

```typescript @skip-check
using client = new EditorClient({
  instanceName: `${sub}.${tabId}`,
  onLoginRequired: (error) => {
    console.log('Login required:', error.reason);
    window.location.href = '/login';
  }
});
```

For call errors, see [Making Calls: Error Handling](./calls#error-handling).

## Browser Considerations

### Tab Identity

While it's possible to instantiate multiple Clients with different instanceNames in the same browser tab, we recommend that you have only one active `LumenizeClient` instance at a time for each browser tab. See the [Getting Started Guide](./getting-started#step-4-connect-from-the-browser) for the `getTabId()` helper pattern.

### Hibernation and Backgrounding

No manual handling needed. `LumenizeClient` automatically detects tab wake-up, reconnects, and triggers `onSubscriptionsLost` if needed.

## Testing

Test clients using `@lumenize/testing`'s `Browser` class, which provides cookie simulation, CORS behavior, and injectable WebSocket polyfills. See **[@lumenize/testing: Agents](/docs/testing/agents)** for complete patterns including multi-user scenarios and authentication testing.

## API Reference

See [Mesh API](./mesh-api) for the full `LumenizeClient` class reference including `connectionState`, `lmz`, `connect()`, `disconnect()`, `onBeforeCall()`, and `ctn<T>()`.

### Type: `LumenizeClientConfig`

```typescript @skip-check
interface LumenizeClientConfig {
  baseUrl?: string;
  instanceName: string;
  gatewayBindingName?: string;
  accessToken?: string;
  refresh?: string | (() => Promise<string>);
  onConnectionStateChange?: (state: ConnectionState) => void;
  onConnectionError?: (error: Error) => void;
  onLoginRequired?: (error: LoginRequiredError) => void;
  onSubscriptionsLost?: () => void;
  WebSocket?: typeof WebSocket;  // For testing
  fetch?: typeof fetch;          // For testing
}

type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';
```
