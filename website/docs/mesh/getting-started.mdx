---
title: Getting Started
description: Build a collaborative document editor with the Lumenize Mesh
---

import MeshArchitectureDiagram from '../_partials/_mesh-architecture-diagram.mdx';

# Getting Started

This tutorial builds a **collaborative document editor** using all mesh node types. By the end, you'll have:

- A `DocumentDO` that stores document content and notifies collaborators
- A `SpellCheckWorker` that checks spelling via an external API
- An `EditorClient` that runs in the browser and receives real-time updates

## What You'll Build

With the exception of the Workspace LumenizeDO, which we leave as a potential exercise for the reader, we will flesh out the nodes in this diagram:

<MeshArchitectureDiagram />

**Call flows:**
1. **User edits** → Client → Gateway → DocumentDO
2. **DocumentDO notifies** → Gateway → Client (real-time update)
3. **DocumentDO spell checks** → SpellCheckWorker → DocumentDO → Gateway → Client

## Prerequisites

```bash @skip-check
npm install @lumenize/mesh @lumenize/utils
```

## Step 1: Define the Document DO

`LumenizeDO` is for **stateful server-side logic**. It has persistent SQL/KV storage and can receive calls from any mesh node.

```typescript @check-example('packages/mesh/test/for-docs/getting-started/document-do.ts')
import { LumenizeDO, mesh } from '@lumenize/mesh';
import type { SpellCheckWorker } from './spell-check-worker.js';
import type { EditorClient } from './editor-client.js';

export class DocumentDO extends LumenizeDO<Env> {
  // Require authentication for all mesh calls
  onBeforeCall(): void {
    super.onBeforeCall();
    if (!this.lmz.callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }

  @mesh
  update(content: string) {
    this.ctx.storage.kv.put('content', content);

    // Notify all subscribers with new content
    this.#broadcastContent(content);

    // Trigger spell check - worker sends results directly to originator
    const { callChain } = this.lmz.callContext;
    const clientId = callChain.at(-1)?.instanceName;
    const documentId = this.lmz.instanceNameOrId!;

    if (clientId) {
      this.lmz.call(
        'SPELLCHECK_WORKER',
        undefined,
        this.ctn<SpellCheckWorker>().check(content, clientId, documentId)
      );
    }
  }

  @mesh
  subscribe(): string {
    const { callChain } = this.lmz.callContext;
    const clientId = callChain.at(-1)?.instanceName;
    if (clientId) {
      const subscribers: Set<string> = this.ctx.storage.kv.get('subscribers') ?? new Set();
      subscribers.add(clientId);
      this.ctx.storage.kv.put('subscribers', subscribers);
    }
    return this.ctx.storage.kv.get('content') ?? '';
  }

  // unsubscribe() left as exercise for reader

  #broadcastContent(content: string) {
    const documentId = this.lmz.instanceNameOrId!;
    const subscribers: Set<string> = this.ctx.storage.kv.get('subscribers') ?? new Set();
    // Note: In production, you'd skip the originator to avoid redundant updates
    for (const clientId of subscribers) {
      const remote = this.ctn<EditorClient>().handleContentUpdate(documentId, content);
      // Start new chain - this is a server-initiated push, not a response to client
      this.lmz.call(
        'LUMENIZE_CLIENT_GATEWAY',
        clientId,
        remote,
        undefined,
        { newChain: true }
      );
    }
  }
}
```

**Key patterns:**
- `onBeforeCall()` enforces authentication at the class level
- `@mesh` decorator exposes methods as entry points
- `this.lmz.call()` makes fire-and-forget or request/response calls
- `this.ctn<T>()` builds type-safe continuations for remote methods
- `{ newChain: true }` starts a fresh call chain for server-initiated pushes

### Design Insights

| Pattern | Why It Matters |
|---------|----------------|
| No `async`/`await` | Continuations describe work; framework handles timing. Avoids race conditions. |
| No instance variables | State in storage survives hibernation/eviction. Reads are cached and cheap (writes cost 10,000x more). |
| Direct delivery | SpellCheckWorker sends findings straight to the originating client, not back through DocumentDO. |
| `{ newChain: true }` | Server-initiated broadcasts start fresh call chains, not continuations of client requests. |
| `@mesh(guard)` not shown | Fine-grained permissions per method. See [Security](./security#method-level-guards). |

## Step 2: Define the Spell Check Worker

`LumenizeWorker` is for **stateless server-side logic**. It's perfect for proxying external APIs, compute-intensive tasks, or offloading fanout.

```typescript @check-example('packages/mesh/test/for-docs/getting-started/spell-check-worker.ts')
import { LumenizeWorker, mesh } from '@lumenize/mesh';
import type { EditorClient } from './editor-client.js';

export interface SpellFinding {
  word: string;
  position: number;
  suggestions: string[];
}

export class SpellCheckWorker extends LumenizeWorker<Env> {
  @mesh
  async check(content: string, clientId: string, documentId: string): Promise<void> {
    // Mock implementation - in real app this would call external API
    // For testing, we'll flag any word containing "teh" as a typo
    const findings: SpellFinding[] = [];
    const words = content.split(/\s+/);
    let position = 0;

    for (const word of words) {
      if (word.toLowerCase().includes('teh')) {
        findings.push({
          word,
          position,
          suggestions: [word.replaceAll(/teh/gi, 'the')],
        });
      }
      position += word.length + 1; // +1 for space
    }

    // Send results directly to the originating client (fire-and-forget)
    if (findings.length > 0) {
      await this.lmz.callRaw(
        'LUMENIZE_CLIENT_GATEWAY',
        clientId,
        this.ctn<EditorClient>().handleSpellFindings(documentId, findings)
      );
    }
  }
}
```

**Key patterns:**
- Workers can be `async` — they don't have the same consistency constraints as DOs
- Workers have no instance name (pass `undefined` to `lmz.call`)
- Direct delivery: Worker sends findings straight to the client that triggered the check

:::tip Cost Optimization
For long-running external calls, consider using `@lumenize/fetch` with the "two one-way call" pattern to avoid DO wall-clock billing while waiting for long-running (>2s) responses.
:::

## Step 3: Define the Browser Client

`LumenizeClient` runs in the browser and is a **full mesh peer** — it can both make and receive calls.

```typescript @check-example('packages/mesh/test/for-docs/getting-started/editor-client.ts')
import { LumenizeClient, mesh, type LumenizeClientConfig } from '@lumenize/mesh';
import type { DocumentDO } from './document-do.js';
import type { SpellFinding } from './spell-check-worker.js';

// Callbacks for a single document
export interface DocumentCallbacks {
  // Called when document content is updated (initial load or broadcast)
  onContentUpdate?: (content: string) => void;
  // Called when spell check findings are received
  onSpellFindings?: (findings: SpellFinding[]) => void;
}

// Handle for an open document - allows saving content and closing
export interface DocumentHandle {
  // Save new content to the document
  saveContent(content: string): void;
  // Close this document (unsubscribe and remove from registry)
  close(): void;
}

export class EditorClient extends LumenizeClient {
  // Registry of open documents by documentId
  readonly #documents = new Map<string, DocumentCallbacks>();

  /**
   * Open a document for editing
   *
   * Subscribes to the document and registers callbacks for updates.
   * Returns a handle for saving content and closing the document.
   */
  openDocument(documentId: string, callbacks: DocumentCallbacks): DocumentHandle {
    // Register callbacks
    this.#documents.set(documentId, callbacks);

    // Subscribe to document updates
    this.#subscribe(documentId, callbacks);

    // Return handle for interacting with this document
    return {
      saveContent: (content: string) => {
        this.lmz.call(
          'DOCUMENT_DO',
          documentId,
          this.ctn<DocumentDO>().update(content)
        );
      },
      close: () => {
        this.#documents.delete(documentId);
        // Should create and use DocumentDO.unsubscribe
      },
    };
  }

  #subscribe(documentId: string, callbacks: DocumentCallbacks) {
    this.lmz.call(
      'DOCUMENT_DO',
      documentId,
      this.ctn<DocumentDO>().subscribe(),
      this.ctn().handleSubscribeResult(documentId, this.ctn().$result)
    );
  }

  // Called when reconnecting after grace period expired
  onSubscriptionsLost = () => {
    // Re-subscribe to all open documents
    for (const [documentId, callbacks] of this.#documents) {
      this.#subscribe(documentId, callbacks);
    }
  };

  // Response handler for subscribe - receives initial content or Error
  // No @mesh needed - framework trusts your own continuations
  handleSubscribeResult(documentId: string, result: string | Error) {
    const callbacks = this.#documents.get(documentId);
    if (!callbacks) return; // Document was closed

    if (result instanceof Error) {
      console.error(`Failed to subscribe to ${documentId}:`, result);
      return;
    }
    callbacks.onContentUpdate?.(result);
  }

  // Called by DocumentDO when content changes (broadcast)
  @mesh
  handleContentUpdate(documentId: string, content: string) {
    this.#documents.get(documentId)?.onContentUpdate?.(content);
  }

  // Called directly by SpellCheckWorker — not routed back through DocumentDO.
  // This "direct delivery" pattern is a key benefit of the mesh architecture:
  // any node can send results to any other node without intermediate hops.
  @mesh
  handleSpellFindings(documentId: string, findings: SpellFinding[]) {
    this.#documents.get(documentId)?.onSpellFindings?.(findings);
  }
}
```

**Key patterns:**
- Extend `LumenizeClient` and define `@mesh` methods for incoming calls
- Use an `openDocument()` pattern that returns a `DocumentHandle` for multi-document support
- `onSubscriptionsLost` handles resubscription. This is only called if auto-reconnect is unsuccessful within the 5-second grace period
- The client can call any mesh node using the same `this.lmz.call()` API
- Results can be `Error` — always check before using

## Step 4: Connect from the Browser

```typescript @check-example('packages/mesh/test/for-docs/getting-started/getting-started.test.ts')
// ...
import { EditorClient } from './editor-client.js';
import type { SpellFinding } from './spell-check-worker.js';

// ...

  // Track events for each client
  const aliceEvents = { content: [] as string[], spellFindings: [] as SpellFinding[][] };
  // ...

  // ...

  // Use `using` for automatic cleanup via Symbol.dispose
  using alice = new EditorClient({
    instanceName: `${aliceUserId}.tab1`,
    baseUrl: 'https://localhost',
    refresh: 'https://localhost/auth/refresh-token',
    // ...
  });

  // ...

  // Alice opens the document - should receive empty content for new document
  const aliceDoc = alice.openDocument(documentId, {
    onContentUpdate: (content) => aliceEvents.content.push(content),
    onSpellFindings: (findings) => aliceEvents.spellFindings.push(findings),
  });

  // ...

  aliceDoc.saveContent('The quick brown fox');
  // ...

  // Cleanup: close document handles (clients auto-disconnect via `using`)
  aliceDoc.close();
  // ...
```

**Key patterns:**
- Use `using` keyword for automatic cleanup via `Symbol.dispose`
- `instanceName` uniquely identifies the client (typically `userId.tabId`)
- `openDocument()` returns a handle with `saveContent()` and `close()` methods
- Event callbacks receive updates in real-time

When `accessToken` is omitted, `LumenizeClient` automatically calls the `refresh` endpoint to get a token before connecting. This uses the refresh cookie that was set when the user clicked the magic link.

## Step 5: Set Up Authentication

The mesh uses `@lumenize/auth` for passwordless authentication with magic link login. This step sets up the keys and environment.

### Generate Ed25519 Key Pairs

Run twice. Once for each pair (BLUE and GREEN):

```bash @skip-check
# Generate and display private key (copy for next step)
openssl genpkey -algorithm ed25519 | tee /dev/stderr | openssl pkey -pubout
```

### Configure Secrets and Variables

**Secrets** (set via `wrangler secret put`, each prompts interactively):

```bash @skip-check
# Primary key pair (signs new tokens)
wrangler secret put JWT_PRIVATE_KEY_BLUE
wrangler secret put JWT_PUBLIC_KEY_BLUE

# Secondary key pair (can be empty initially — used for zero-downtime rotation)
wrangler secret put JWT_PRIVATE_KEY_GREEN
wrangler secret put JWT_PUBLIC_KEY_GREEN
```

Paste each key (including `-----BEGIN/END-----` lines) when prompted.

Set `PRIMARY_JWT_KEY` to `BLUE` in the dashboard or wrangler.jsonc/wrangler.toml

:::tip Key Rotation
The BLUE/GREEN pattern allows zero-downtime key rotation. See [@lumenize/auth: Key Rotation](/docs/auth#key-rotation) for the procedure.
:::

### Install Auth Package

```bash @skip-check
npm install @lumenize/auth
```

## Step 6: Set Up the Worker Entry Point

```typescript @check-example('packages/mesh/test/for-docs/getting-started/index.ts')
import { env } from 'cloudflare:workers';
import { routeDORequest } from '@lumenize/utils';
import {
  LumenizeAuth,
  createAuthRoutes,
  createWebSocketAuthMiddleware,
  createAuthMiddleware
} from '@lumenize/auth';
import { LumenizeClientGateway } from '@lumenize/mesh';

// Re-export classes for wrangler bindings
export { LumenizeClientGateway, LumenizeAuth };
export { DocumentDO } from './document-do.js';
export { SpellCheckWorker, type SpellFinding } from './spell-check-worker.js';

// Create auth routes and middleware once at module level (not per request)
const publicKeys = [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN].filter(Boolean);
const authRoutes = createAuthRoutes(env, { redirect: '/app' });
const wsAuth = await createWebSocketAuthMiddleware({ publicKeysPem: publicKeys });
const httpAuth = await createAuthMiddleware({ publicKeysPem: publicKeys });

// Worker entry point
export default {
  async fetch(request: Request) {
    // Handle auth routes (/auth/email-magic-link, /auth/magic-link, /auth/refresh-token, /auth/logout)
    const authResponse = await authRoutes(request);
    if (authResponse) {
      return authResponse;
    }

    const response = await routeDORequest(request, env, {
      prefix: 'gateway',
      onBeforeConnect: wsAuth,
      onBeforeRequest: httpAuth,
    });

    if (response) {
      return response;
    }

    return new Response('Not Found', { status: 404 });
  },
};
```

## Step 7: Configure wrangler.jsonc

```jsonc @check-example('packages/mesh/test/for-docs/getting-started/wrangler.jsonc')
{
  "name": "mesh-getting-started",
  "main": "index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      {
        "name": "LUMENIZE_CLIENT_GATEWAY",
        "class_name": "LumenizeClientGateway"
      },
      {
        "name": "DOCUMENT_DO",
        "class_name": "DocumentDO"
      },
      {
        "name": "LUMENIZE_AUTH",
        "class_name": "LumenizeAuth"
      }
    ]
  },
  "services": [
    {
      "binding": "SPELLCHECK_WORKER",
      "service": "mesh-getting-started",
      "entrypoint": "SpellCheckWorker"
    }
  ],
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["LumenizeClientGateway", "DocumentDO"]
    },
    {
      "tag": "v2",
      "new_sqlite_classes": ["LumenizeAuth"]
    }
  ],
  "vars": {
    "PRIMARY_JWT_KEY": "BLUE",
    // ...
  }
}
```

:::note `SpellCheckWorker`
The `SpellCheckWorker` is a [named entrypoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/#named-entrypoints) in the same Worker, bound via `services`.
:::
