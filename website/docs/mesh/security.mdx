---
title: Identity & Access Control
description: Identity propagation, access control, and callContext in the mesh
---

# Identity & Access Control

Authentication has two parts:

1. **Identity verification** — "You are who you say you are" — handled by auth hooks ([`@lumenize/auth`](/docs/auth), Auth0, Stytch, etc.) *before* requests reach the mesh
2. **Identity propagation** — "The mesh knows who you are throughout the call chain" — handled by headers flowing through the Gateway into `callContext.originAuth`

This page covers the second of those, **identity propagation**, as well as **access control** (enforcing permissions via guards). For the first of those, identity verification, see your auth provider's docs or [`@lumenize/auth`](/docs/auth). If you're using a third-party provider like Auth0, Clerk, Stytch, etc. see [Integrating Alternative Auth](#integrating-alternative-auth-advanced) for the header contract that serves as the bridge between 1 and 2 above.

## Architecture Overview

```mermaid
sequenceDiagram
    participant Client
    participant Worker
    participant Gateway
    participant SomeMeshDO

    Note over Client,Worker: WebSocket Upgrade (one-time)
    Client->>Worker: Upgrade + Authorization: Bearer {jwt}
    Note over Worker: Auth hooks verify JWT
    Worker->>Gateway: Upgrade + Authorization: Bearer {verified-jwt}
    Note over Gateway: Decodes JWT, stores<br/>originAuth in WebSocket attachment
    Gateway-->>Worker: 101 Switching Protocols
    Worker-->>Client: 101 Switching Protocols

    Note over Client,SomeMeshDO: Subsequent Calls (via WebSocket)
    Client->>Gateway: call(SomeMeshDO, method, args)
    Note over Gateway: Attaches stored<br/>originAuth to callContext
    Gateway->>SomeMeshDO: callContext.originAuth {sub, claims}
    Note over SomeMeshDO: Guards check originAuth
```

The key insight: **auth hooks *verify* the JWT and forward it** via `Authorization: Bearer {jwt}`. The Gateway decodes the verified JWT to extract `sub` and claims into `originAuth`. The mesh cares about verified identity, not raw tokens.

## WebSocket Authentication

Unlike HTTP where each request carries its own token, WebSocket connections are long-lived. The token is sent once during the upgrade handshake, then identity is stored in the connection attachment.

Browsers don't allow custom headers on WebSocket upgrades, so `LumenizeClient` smuggles the token in the subprotocol list:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

Here's how each component handles it:

1. **Auth hooks** extract the token from `lmz.access-token.{jwt}` in the subprotocol header
2. **Auth hooks** verify JWT signature and expiration
3. **Auth hooks** forward the verified JWT via `Authorization: Bearer {jwt}` header
4. **Gateway** decodes the JWT payload to extract `sub`, `exp`, and claims — stores as `originAuth` in WebSocket attachment
5. **Gateway** validates that JWT `sub` matches the Gateway instance name prefix (prevents hijacking)
6. **Gateway** responds with `Sec-WebSocket-Protocol: lmz`
7. **On each call**, Gateway checks the stored expiration — if expired, closes with `4401`
8. **On 4401**, client refreshes via HTTP and reconnects automatically

The Gateway doesn't re-verify the JWT signature — it trusts that the auth hooks already did. This is the same trust boundary shown in the [Architecture Overview](#architecture-overview) diagram.

:::note Access Token vs Refresh Token
**Access tokens** are short-lived (15 min) and kept in memory — if stolen, damage is time-limited. **Refresh tokens** are long-lived (30 days) and stored in HTTP-only cookies — JavaScript can't access them, protecting against XSS. This is the standard [OAuth 2.0 refresh token pattern](https://oauth.net/2/refresh-tokens/).
:::

### Client Configuration

See [LumenizeClient: Authentication](./lumenize-client#authentication) for configuration options including `accessToken` and `refresh`.

### Handling Login Required

Access token expiration (4401) is handled automatically — the client refreshes via HTTP and reconnects transparently. `onLoginRequired` only fires when the refresh token itself has expired or been revoked (HTTP 401 from the refresh endpoint), meaning the user must re-login:

```typescript @check-example('packages/mesh/test/for-docs/security/index.test.ts')
  onLoginRequired: (error) => {
    // Only fires when refresh fails — user must re-login
    console.log('Login required:', error.code, error.reason);
    // ...
  },
```

### Auth Close Codes

You should never have to deal with these unless you are writing your own custom auth, but the Gateway uses this WebSocket close code for auth issues:

| Code | Meaning | Action |
|------|---------|--------|
| `4401` | Token expired | Refresh and reconnect (automatic) |

Other auth failures (missing identity, invalid signature) are rejected by the auth hooks before the WebSocket is established, resulting in HTTP 401/403 errors rather than WebSocket close codes.

## Access Control

### Three-Layer Access Control Model

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **Class-wide** | `onBeforeCall()` hook | WHO can call (authentication) |
| **Entry Point** | `@mesh()` decorator | WHAT is exposed (method allowlist) |
| **Capability Trust** | Automatic | Returned objects trusted for that chain |

Methods without the `@mesh()` decorator behave as if they don't exist — callers receive a generic error. Errors thrown by guards or `onBeforeCall` pass through unchanged, preserving your domain-specific error types. See [Making Calls: Error Handling](./calls#error-handling) for details.

### Class-Level: `onBeforeCall()`

Override to enforce class-wide policies:

```typescript @check-example('packages/mesh/test/for-docs/security/protected-do.ts')
export class ProtectedDO extends LumenizeDO<Env> {
  onBeforeCall() {
    super.onBeforeCall();

    // Require authentication
    if (!this.lmz.callContext.originAuth?.sub) {
      throw new Error('Authentication required');
    }
  }
  // ...
}
```

### Method-Level: `@mesh(guard)`

Guards receive the instance, providing access to instance state. The correct `lmz.callContext` is also available in the guard. This works for all node types (`LumenizeDO`, `LumenizeWorker`, `LumenizeClient`):

```typescript @check-example('packages/mesh/test/for-docs/security/team-doc-do.ts')
  // Check `callContext.originAuth.claims` to determine access
  @mesh((instance: TeamDocDO) => {
    if (!instance.lmz.callContext.originAuth?.claims?.isAdmin) {
      throw new Error('Admin only');
    }
  })
  adminMethod(): string {
    // Only admins reach here
    // ...
  }
```

```typescript @check-example('packages/mesh/test/for-docs/security/team-doc-do.ts')
  // Check instance state to determine access
  @mesh((instance: TeamDocDO) => {
    const userId = instance.lmz.callContext.originAuth?.sub;
    if (!instance.allowedEditors.has(userId!)) {
      throw new Error('Not an allowed editor');
    }
  })
  updateDocument(changes: DocumentChange): { updated: true; content: string } {
    // Only allowed editors reach here
    // ...
  }
```

### Reusable Guards

Extract common access checks into standalone functions and pass them to `@mesh()`. This `requireSubscriber` guard combines JWT identity (`originAuth.sub`) with instance state (a `subscribers` Set in storage):

```typescript @check-example('packages/mesh/test/for-docs/security/team-doc-do.ts')
function requireSubscriber(instance: TeamDocDO) {
  const sub = instance.lmz.callContext.originAuth?.sub;
  if (!sub || !instance.subscribers.has(sub)) {
    throw new Error('Subscriber access required');
  }
}
```

Then reuse it across multiple methods:

```typescript @check-example('packages/mesh/test/for-docs/security/team-doc-do.ts')
  @mesh(requireSubscriber)
  editDocument(changes: DocumentChange): { edited: true; content: string } {
    // ...
  }

  @mesh(requireSubscriber)
  addComment(comment: string): { commented: true } {
    // ...
  }
```

### State-Based Access

The `callContext.state` object is a mutable `Record<string, unknown>` that:
- Starts **empty** (`{}`) for initial incoming mesh call
- **Persists through the call chain** — method guards and handlers see the same state even when the call chain hops from mesh node to mesh node
- **Propagates back on return** — if DO2 modifies state, DO1's result handler continuation sees those changes
- Is often **populated in `onBeforeCall()`** after verifying authentication, but can be added to by any call in the call chain
- Is **isolated per-request** via AsyncLocalStorage (concurrent calls don't interfere)

Use it to attach computed data (like user records or permissions) so method guards don't need to re-load/re-compute:

```typescript @check-example('packages/mesh/test/for-docs/security/team-doc-do.ts')
  onBeforeCall() {
    super.onBeforeCall();
    const callContext = this.lmz.callContext;
    if (!callContext.originAuth?.sub) throw new Error('Auth required');

    // Populate state for use by method guards
    const session = this.loadSession(callContext.originAuth.sub);
    callContext.state.session = session;
    callContext.state.permissions = this.computePermissions(session);
  }
```

```typescript @check-example('packages/mesh/test/for-docs/security/team-doc-do.ts')
  @mesh((instance: TeamDocDO) => {
    // ...
    if (!permissions?.canEdit) {
      throw new Error('Edit permission required');
    }
  })
  editWithStateCheck(changes: DocumentChange): { edited: true; byUser: string } {
    // ...
  }
```

:::note Per-Request Isolation
Each request gets its own `callContext` instance with its own `state` object, even when multiple requests hit the same DO concurrently. This isolation is provided by AsyncLocalStorage under the hood — you don't need to worry about concurrent requests overwriting each other's state.
:::

## Integrating Alternative Auth (Advanced)

The Gateway reads identity from a verified JWT in the `Authorization: Bearer {jwt}` header — it doesn't care how authentication happens. If you're using Auth0, Clerk, Supabase Auth, Stytch, etc. or a custom solution, your `onBeforeConnect` hook just needs to verify the token and forward it.

### Header Contract

The Gateway requires this header to be set by your `onBeforeConnect` hook:

| Header | Required | Description |
|--------|----------|-------------|
| `Authorization` | Yes | `Bearer {jwt}` — a verified JWT with at least a `sub` claim |

The Gateway decodes the JWT payload (without re-verifying the signature) and extracts:
- **`sub`** (required) — becomes `originAuth.sub`
- **`exp`** — stored for per-message expiration checks
- **Claims** (`emailVerified`, `adminApproved`, `isAdmin`, `act`) — become `originAuth.claims`

If the `Authorization` header is missing or the JWT lacks a `sub` claim, the Gateway rejects the WebSocket upgrade with 401.

Additionally, [`routeDORequest`](/docs/utils/route-do-request) automatically adds routing context headers that the mesh requires:

| Header | Description |
|--------|-------------|
| `X-Lumenize-DO-Binding-Name` | The binding name used to access this DO |
| `X-Lumenize-DO-Instance-Name-Or-Id` | The instance name or ID from the URL path |

These headers allow DOs to know their own identity, which is essential for participating in mesh calls. If you're not using `routeDORequest`, you must set these headers yourself.

:::warning Never trust client-provided tokens
Your `onBeforeConnect` hook must **verify** the JWT before forwarding — never pass through an unverified token. Attackers can send any token they want.
:::

:::note Why it's secure for the Gateway to trust the forwarded JWT
The Gateway doesn't re-verify JWT signatures — it trusts that your auth hooks already did. This is secure because:

1. **Your `onBeforeConnect` hook *verifies then forwards* the token** — Even if an attacker sends a forged JWT, the hook rejects it (returns 401) before it reaches the Gateway
2. **DOs are only reachable through your Worker** — There's no way to bypass the hooks and call a DO binding directly
:::

### How the JWT Maps to callContext

```typescript @skip-check-approved('conceptual - shows mapping between JWT claims and callContext')
// Your onBeforeConnect hook verifies and forwards the JWT
// JWT payload: { sub: 'user-123', emailVerified: true, isAdmin: false, ... }
const enhanced = new Request(request);
enhanced.headers.set('Authorization', `Bearer ${verifiedJwt}`);

// In your mesh handlers, access via callContext
@mesh()
someMethod() {
  const { originAuth } = this.lmz.callContext;
  console.log(originAuth.sub);                       // 'user-123'
  console.log(originAuth.claims.emailVerified);      // true
}
```

### Example: Auth0 Integration

This example shows how to create an `onBeforeConnect` hook for Auth0. It follows the same contract as `@lumenize/auth` — verify the JWT and forward it via `Authorization: Bearer`. Browsers can't set custom headers on WebSocket upgrades, so `LumenizeClient` smuggles the token in the subprotocol header.

```typescript @skip-check-approved('requires Auth0 account to test')
import { jwtVerify, importSPKI } from 'jose';
import type { RouteDORequestHooksContext } from '@lumenize/utils';

async function createAuth0WebSocketHooks(env: Env) {
  const publicKey = await importSPKI(env.AUTH0_PUBLIC_KEY, 'RS256');

  return async (request: Request, context: RouteDORequestHooksContext): Promise<Request | Response> => {
    // Extract token from subprotocol header (e.g., "lmz, lmz.access-token.eyJ...")
    const protocols = request.headers.get('Sec-WebSocket-Protocol')?.split(',').map(p => p.trim()) ?? [];
    const tokenProtocol = protocols.find(p => p.startsWith('lmz.access-token.'));
    const token = tokenProtocol?.replace('lmz.access-token.', '');
    if (!token) return new Response('Unauthorized', { status: 401 });

    try {
      // Verify JWT — ensures sub, exp, and signature are valid
      await jwtVerify(token, publicKey, {
        issuer: `https://${env.AUTH0_DOMAIN}/`,
        audience: env.AUTH0_AUDIENCE
      });

      // Forward the verified JWT — Gateway will decode sub and claims
      const enhanced = new Request(request);
      enhanced.headers.set('Authorization', `Bearer ${token}`);
      return enhanced;
    } catch {
      return new Response('Invalid token', { status: 401 });
    }
  };
}

// Usage in Worker fetch handler
const wsAuth = await createAuth0WebSocketHooks(env);

routeDORequest(request, env, {
  onBeforeConnect: wsAuth
});
```
