---

generated_by: doc-testing

---



# Plain DurableObject Usage

<details>
<summary><strong>ðŸ“˜ Doc-testing</strong> â€“ Why do these examples look like tests?</summary>

This documentation uses **testable code examples** to ensure accuracy and reliability:

- **Guaranteed accuracy**: All examples are real, working code that runs against the actual package(s)
- **Guaranteed latest comparisons**: Further, our release script won't allow us to release a new
  version of Lumenize, without prompting us to update any doc-tested comparison package 
  (e.g. Cap'n Web)
- **Always up-to-date**: When a package changes, the tests fail and the docs must be updated
- **Copy-paste confidence**: What you see is what works - no outdated or broken examples
- **Real-world patterns**: Tests show complete, runnable scenarios, not just snippets

Ignore the test boilerplate (`it()`, `describe()`, etc.) - focus on the code inside.

</details>

The [@cloudflare/actors](https://www.npmjs.com/package/@cloudflare/actors) 
alarms package solves a key limitation: **Cloudflare only allows one native 
alarm per Durable Object instance**. This package uses SQL storage to manage 
multiple scheduled tasks and ensures the single native alarm always fires for 
the next scheduled task.

This guide shows how to use Alarms **without extending Actor** - just a plain 
`DurableObject` with manual `Storage` and `Alarms` setup.

## Imports




```typescript test
import { it, expect, vi } from 'vitest';
// @ts-expect-error - cloudflare:test module types not consistently exported
import { SELF, env, runDurableObjectAlarm } from 'cloudflare:test';
import {
  createRpcClient,
  createWebSocketTransport,
  type RpcAccessible
} from '@lumenize/rpc';
import { getWebSocketShim } from '@lumenize/utils';
import { AlarmDO } from '../src';
```




## Version

This test asserts the installed version and our release script warns if we 
aren't using the latest version published to npm, so this living documentation 
should always be up to date.




```typescript test
import actorsPackage from '../node_modules/@cloudflare/actors/package.json';
it('detects package version', () => {
  expect(actorsPackage.version).toBe('0.0.1-beta.6');
});
```




## Installation

```bash npm2yarn
npm install @cloudflare/actors
```

## Setup Without Actor Base Class

To use the Alarms package with a plain `DurableObject`, your class must:

1. **Manually create `Storage` wrapper** - Import from `@cloudflare/actors/storage`
2. **Manually create `Alarms` instance** - Pass `ctx` and `this`
3. **Implement the `alarm()` method** - This delegates to the Alarms instance

Here's the complete Durable Object and Worker:

```typescript src/index.ts
import { Storage } from "@cloudflare/actors/storage";
import { Alarms, type Schedule } from "@cloudflare/actors/alarms";
import { DurableObject } from "cloudflare:workers";
import { lumenizeRpcDO } from "@lumenize/rpc";
import { routeDORequest } from "@lumenize/utils";

class _AlarmDO extends DurableObject<Env> {
  storage: Storage;
  alarms: Alarms<this>;
  executedAlarms: string[] = [];

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env);
    this.storage = new Storage(ctx.storage);
    this.alarms = new Alarms(ctx, this);
  }

  // Required boilerplate: delegate to Alarms instance
  async alarm() {
    await this.alarms.alarm();
  }

  // Callback for alarms - gets called when an alarm fires
  async handleAlarm(payload: any, schedule: Schedule) {
    const message = `Alarm ${schedule.id} fired: ${JSON.stringify(payload)}`;
    this.executedAlarms.push(message);
  }

  // Method to get executed alarms (for testing)
  getExecutedAlarms(): string[] {
    return this.executedAlarms;
  }
}

// Wrap with RPC support so we can demo in doc-test.
// You can just export the class above directly instead:
//   `export const AlarmDO extends DurableObject<Env>{...}`
export const AlarmDO = lumenizeRpcDO(_AlarmDO);

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Route RPC requests to enable demo in doc-test
    const response = await routeDORequest(request, env, { prefix: '__rpc' });
    if (response) return response;
    
    // Fallback for non-RPC requests
    return new Response('Alarms doc-test worker', { status: 404 });
  },
};


```

The `alarm()` method is **required boilerplate** - Cloudflare's Durable Object 
API requires you to implement this handler method. The Alarms class can't 
automatically inject itself into that lifecycle hook, so you must explicitly 
delegate to it.

**Note**: Unlike extending `Actor` (which auto-creates `this.alarms`), you must 
manually instantiate both `Storage` and `Alarms` in your constructor.

## Scheduling Alarms

The Alarms package supports three types of schedules:

1. **Date-based**: Execute at a specific time
2. **Delay-based**: Execute after N seconds
3. **Cron-based**: Recurring execution using cron expressions




```typescript test
it('schedules multiple alarms with different types', async () => {
  // You don't need this.
  // It allows our test code to magically appear as though we are inside the DO
  using client = createRpcClient<RpcAccessible<InstanceType<typeof AlarmDO>>>({
    transport: createWebSocketTransport('ALARM_DO', 'multi-types', {
      baseUrl: 'https://fake-host.com',
      prefix: '__rpc',
      WebSocketClass: getWebSocketShim(SELF.fetch.bind(SELF)),
    })
  });

  // 1. Schedule with a Date (execute at specific time)
  const futureDate = new Date(Date.now() + 100); // 100ms from now
  const dateSchedule = await client.alarms.schedule(
    futureDate, 
    'handleAlarm', 
    { type: 'date', message: 'Executed at specific time' }
  );
  expect(dateSchedule.type).toBe('scheduled');
  expect(dateSchedule.callback).toBe('handleAlarm');

  // 2. Schedule with delay in seconds
  const delaySchedule = await client.alarms.schedule(
    0.15, // 150ms (0.15 seconds)
    'handleAlarm', 
    { type: 'delay', message: 'Executed after delay' }
  );
  expect(delaySchedule.type).toBe('delayed');

  // 3. Schedule with cron expression (every minute)
  // Note: We won't wait for cron to fire - it would take 60 seconds
  // Cron syntax reference: https://crontab.guru
  const cronSchedule = await client.alarms.schedule(
    '* * * * *', 
    'handleAlarm', 
    { type: 'cron', message: 'Recurring task' }
  );
  expect(cronSchedule.type).toBe('cron');

  // In test environments, alarms don't fire automatically - we need to 
  // manually trigger them using runDurableObjectAlarm()
  const stub = env.ALARM_DO.getByName('multi-types');

  // Wait for alarms to become due, then trigger and verify
  await vi.waitFor(async () => {
    // Trigger any pending alarms (Alarms class auto-reschedules the next one)
    await runDurableObjectAlarm(stub);
    await runDurableObjectAlarm(stub);
    
    // Verify both alarms actually executed
    const executed = await client.getExecutedAlarms();
    expect(executed.length).toBe(2);
    expect(executed.some((msg: string) => msg.includes('date'))).toBe(true);
    expect(executed.some((msg: string) => msg.includes('delay'))).toBe(true);
  });
});
```




## Managing Scheduled Alarms

You can query and cancel scheduled alarms:




```typescript test
it('queries and cancels scheduled alarms', async () => {
  // You don't need this.
  // It allows our test code to magically appear as though we are inside the DO
  using client = createRpcClient<RpcAccessible<InstanceType<typeof AlarmDO>>>({
    transport: createWebSocketTransport('ALARM_DO', 'manage', {
      baseUrl: 'https://fake-host.com',
      prefix: '__rpc',
      WebSocketClass: getWebSocketShim(SELF.fetch.bind(SELF)),
    })
  });

  // Schedule several alarms
  const schedule1 = await client.alarms.schedule(
    10, // 10 seconds
    'handleAlarm',
    { task: 'task-1' }
  );

  const schedule2 = await client.alarms.schedule(
    20, // 20 seconds
    'handleAlarm',
    { task: 'task-2' }
  );

  // Get all scheduled alarms
  const allSchedules = await client.alarms.getSchedules();
  expect(allSchedules.length).toBeGreaterThanOrEqual(2);

  // Get a specific schedule by ID
  const retrieved = await client.alarms.getSchedule(schedule1.id);
  expect(retrieved?.payload).toEqual({ task: 'task-1' });

  // Cancel a schedule
  const cancelled = await client.alarms.cancelSchedule(schedule2.id);
  expect(cancelled).toBe(true);

  // Verify it's gone
  const afterCancel = await client.alarms.getSchedules();
  expect(afterCancel.some((s: any) => s.id === schedule2.id)).toBe(false);
});
```




## wrangler.jsonc

```json wrangler.jsonc
{
  "name": "actors-alarms-plain-usage",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      {
        "name": "ALARM_DO",
        "class_name": "AlarmDO"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["AlarmDO"]
    }
  ]
}


```

## Try it out

To run these tests:

```bash
vitest --run
```

For coverage reports:

```bash
vitest --run --coverage
```