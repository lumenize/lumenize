---
title: ProxyFetch
description: Cost-effective external API calls from Durable Objects using continuation-based callbacks
---

# ProxyFetch

A de‚ú®light‚ú®ful way to make external API calls from Durable Objects without blocking or accumulating wall-clock billing.

**Key Benefits:**
- ‚úÖ **Fire-and-forget** - Returns immediately, result arrives via continuation
- ‚úÖ **Cost-effective** - CPU billing for fetches, minimal DO billing
- ‚úÖ **Type-safe** - Full TypeScript support with OCAN continuations
- ‚úÖ **Timeout monitoring** - Automatic timeout detection via @lumenize/alarms
- ‚úÖ **Simple architecture** - Two-hop design (Origin DO ‚Üí Worker ‚Üí External API)

## Quick Start

```typescript @skip-check
import '@lumenize/proxy-fetch';  // Registers as NADIS service
import '@lumenize/alarms';       // Required for timeout monitoring

class MyDO extends LumenizeBase {
  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env);
    this.lmz.init({ bindingName: 'MY_DO' });
  }

  // Implement alarm handler (required for timeout monitoring)
  async alarm() {
    await this.svc.alarms.alarm();
  }

  fetchUserData(userId: string) {
    // Fire and forget - result comes to handler later
    const reqId = this.svc.proxyFetch(
      `https://api.example.com/users/${userId}`,
      this.ctn().handleResult()  // Result implicitly passed as last parameter
    );
    
    // Returns immediately with reqId (for logging/debugging)
    return reqId;
  }
  
  handleResult(result: ResponseSync | Error) {
    if (result instanceof Error) {
      console.error('Fetch failed:', result);
    } else {
      // ResponseSync provides synchronous body access
      const data = result.json(); // No await needed!
      console.log('User data:', data);
    }
  }
}
```

## Setup

### 1. Install Dependencies

```bash @skip-check
npm install @lumenize/proxy-fetch @lumenize/alarms
```

### 2. Export `FetchExecutorEntrypoint` from your worker

```typescript @skip-check
// src/index.ts
export { FetchExecutorEntrypoint } from '@lumenize/proxy-fetch';
```

### 3. Add service binding in `wrangler.jsonc`

```jsonc @skip-check
{
  "services": [{
    "binding": "FETCH_EXECUTOR",
    "service": "my-worker",
    "entrypoint": "FetchExecutorEntrypoint"
  }]
}
```

### 4. Import to register

```typescript @skip-check
import '@lumenize/proxy-fetch';
import '@lumenize/alarms';
```

### 5. Implement `alarm()` handler in your DO

```typescript @skip-check
class MyDO extends LumenizeBase {
  async alarm() {
    await this.svc.alarms.alarm();
  }
}
```

That's it! Now use `this.svc.proxyFetch()` in any DO extending `LumenizeBase`.

## Basic Usage

### Simple GET Request

```typescript @skip-check
class MyDO extends LumenizeBase {
  fetchWeather(city: string) {
    this.svc.proxyFetch(
      `https://api.weather.com/forecast?city=${city}`,
      this.ctn().handleWeather()
    );
  }
  
  handleWeather(result: ResponseSync | Error) {
    if (result instanceof Error) {
      console.error('Weather fetch failed:', result);
    } else {
      const forecast = result.json();
      console.log('Forecast:', forecast);
    }
  }
}
```

### POST with RequestSync Object

```typescript @skip-check
import { RequestSync } from '@lumenize/structured-clone';

class MyDO extends LumenizeBase {
  createOrder(orderData: any) {
    const request = new RequestSync('https://api.example.com/orders', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(orderData)
    });
    
    this.svc.proxyFetch(
      request,
      this.ctn().handleOrderCreated()
    );
  }
  
  handleOrderCreated(result: ResponseSync | Error) {
    if (result instanceof Error) {
      console.error('Order creation failed:', result);
    } else if (!result.ok) {
      console.error('HTTP error:', result.status, result.text());
    } else {
      const order = result.json();
      console.log('Order created:', order.id);
    }
  }
}
```

## API Reference

### `this.svc.proxyFetch(request, continuation, options?)`

**Parameters:**
- `request`: `string | RequestSync` - URL or RequestSync object
- `continuation`: OCAN continuation created with `this.ctn().handlerMethod()`
- `options?`: Optional configuration

**Returns:** `string` - Request ID (for logging/debugging)

**Options:**
```typescript @skip-check
interface ProxyFetchWorkerOptions {
  /** Request timeout in milliseconds (default: 30000) */
  timeout?: number;
  
  /** Binding name for FetchExecutor service (default: 'FETCH_EXECUTOR') */
  executorBinding?: string;
}
```

### Handler Signature

Your handler receives **either** a `ResponseSync` or `Error`:

```typescript @skip-check
handleResult(result: ResponseSync | Error) {
  if (result instanceof Error) {
    // Network error, timeout, or parsing error
  } else {
    // Success (HTTP 2xx) or HTTP error (4xx, 5xx)
    // Check result.ok or result.status
  }
}
```

### ResponseSync Methods

Since handlers are **synchronous**, `ResponseSync` provides synchronous body access:

```typescript @skip-check
result.json()        // ‚Üí any (parsed JSON, no await)
result.text()        // ‚Üí string (no await)
result.arrayBuffer() // ‚Üí ArrayBuffer (no await)
result.ok            // ‚Üí boolean (2xx status)
result.status        // ‚Üí number (HTTP status code)
result.statusText    // ‚Üí string
result.headers       // ‚Üí Headers
```

## Advanced Usage

### Alternative Syntax (Explicit `$result` Marker)

If you prefer explicit parameter placement:

```typescript @skip-check
class MyDO extends LumenizeBase {
  fetchUserData(userId: string) {
    this.svc.proxyFetch(
      `https://api.example.com/users/${userId}`,
      this.ctn().handleResult(userId, this.ctn().$result)
    );
  }
  
  handleResult(userId: string, result: ResponseSync | Error) {
    console.log(`Result for user ${userId}:`, result);
  }
}
```

### Providing Context to Handler

Pass context as regular parameters (result is last):

```typescript @skip-check
class MyDO extends LumenizeBase {
  fetchUserData(userId: string, requestedBy: string) {
    this.svc.proxyFetch(
      `https://api.example.com/users/${userId}`,
      this.ctn().handleResult({ userId, requestedBy })
    );
  }
  
  handleResult(context: { userId: string, requestedBy: string }, result: ResponseSync | Error) {
    if (result instanceof Error) {
      console.error(`Fetch failed for user ${context.userId} (requested by ${context.requestedBy})`);
    } else {
      const data = result.json();
      console.log(`User ${context.userId} data:`, data);
    }
  }
}
```

### Custom Timeout

```typescript @skip-check
this.svc.proxyFetch(
  'https://slow-api.example.com/data',
  this.ctn().handleResult(),
  { timeout: 60000 } // 60 seconds
);
```

## Retry Logic

The **Origin DO decides retry strategy**. The alarm system only monitors timeouts - it never retries.

**Race condition safety**: Handlers with early returns on errors are naturally safe from duplicate calls. Only add explicit deduplication if you perform destructive actions on both success AND error. See [Race Conditions](/docs/proxy-fetch/architecture-and-failure-modes#race-conditions) for details.

### Sequential Retry Pattern

```typescript @skip-check
class MyDO extends LumenizeBase {
  fetchWithRetry(url: string, attempt: number = 1) {
    this.svc.proxyFetch(
      url,
      this.ctn().handleFetchResult(url, attempt)
    );
  }
  
  handleFetchResult(url: string, attempt: number, result: ResponseSync | Error) {
    const maxAttempts = 3;
    
    if (result instanceof Error) {
      // Network error or timeout
      if (attempt < maxAttempts) {
        console.log(`Attempt ${attempt} failed, retrying...`);
        this.fetchWithRetry(url, attempt + 1);
      } else {
        console.error(`All ${maxAttempts} attempts failed:`, result);
      }
    } else if (!result.ok && result.status >= 500) {
      // Server error - retry
      if (attempt < maxAttempts) {
        console.log(`Server error ${result.status}, retrying...`);
        this.fetchWithRetry(url, attempt + 1);
      } else {
        console.error(`Server error after ${maxAttempts} attempts`);
      }
    } else {
      // Success or client error (4xx) - don't retry
      const data = result.json();
      console.log('Success:', data);
    }
  }
}
```

### Conditional Retry (Business Logic)

```typescript @skip-check
class PaymentDO extends LumenizeBase {
  processPayment(paymentId: string) {
    this.svc.proxyFetch(
      `https://payments.example.com/charge/${paymentId}`,
      this.ctn().handlePaymentResult(paymentId)
    );
  }
  
  handlePaymentResult(paymentId: string, result: ResponseSync | Error) {
    if (result instanceof Error) {
      if (result.message.includes('delivery timeout')) {
        // ‚ö†Ô∏è CRITICAL: Timeout is ambiguous!
        // Payment may have succeeded. Check payment system state.
        console.warn('Timeout - checking payment system...');
        this.verifyPaymentStatus(paymentId);
      } else {
        // Network/parsing error - safe to retry
        console.error('Payment API unreachable, retrying...');
        this.processPayment(paymentId);
      }
    } else if (result.status === 409) {
      // Idempotency key conflict - already processed
      console.log('Payment already processed');
    } else if (result.status >= 500) {
      // Server error - retry
      this.processPayment(paymentId);
    } else {
      // Success or client error
      const payment = result.json();
      console.log('Payment result:', payment);
    }
  }
}
```

## Timeout Behavior

- **User timeout** (`options.timeout`): Controls fetch execution (AbortController) - default 30s
- **Alarm timeout**: Same as user timeout (no buffer needed)
- **Timeout error message**: "Fetch delivery timeout - external fetch may have partially succeeded"

**Important:** If you receive a timeout error for a non-idempotent operation, **check the external system** before retrying!

## Error Categories

| Error Source | Type | Meaning |
|--------------|------|---------|
| Executor | `Error` (network) | API unreachable (DNS, connection refused) |
| Executor | `Error` (abort) | Fetch exceeded timeout (AbortController) |
| Executor | `Error` (parsing) | ResponseSync deserialization failed |
| **Alarm** | **`Error` (timeout)** | ‚ö†Ô∏è **Ambiguous - may have succeeded!** |
| Executor | `ResponseSync` (ok) | HTTP 2xx success |
| Executor | `ResponseSync` (!ok) | HTTP 4xx/5xx error |

**Key distinction:** Only alarm timeout is ambiguous. All Executor errors mean the fetch definitely failed/completed.

## Architecture

For detailed architecture diagrams, failure scenarios, and race condition handling, see:

üëâ **[Architecture & Failure Modes](/docs/proxy-fetch/architecture-and-failure-modes)**

**High-level flow:**
1. Origin DO ‚Üí Schedule alarm with embedded continuation
2. Origin DO ‚Üí Executor: Dispatch fetch via RPC (returns immediately)
3. Executor ‚Üí External API: Perform fetch (CPU billing)
4. Executor ‚Üí Origin DO: Deliver result via `__handleProxyFetchResult()`
5. Origin DO: Cancel alarm atomically, execute user handler synchronously

**Key design:**
- ‚úÖ Origin DO stops billing after quick RPC dispatch
- ‚úÖ Executor uses CPU billing for external fetch
- ‚úÖ Timeout monitoring via @lumenize/alarms (native DO alarm system)
- ‚úÖ Direct delivery via continuation chains (no result storage)
- ‚úÖ Atomic alarm cancellation on result delivery

**Important: Handler Call Guarantee**

**Normal operation**: Handler called exactly once with either `ResponseSync` or `Error`.

**Rare race condition** (DO crash before alarm cancellation persists): Handler may be called twice - first with `ResponseSync` (success), then with `TimeoutError`. Most handlers are naturally safe:

```typescript @skip-check
handleResult(result: ResponseSync | Error) {
  if (result instanceof Error) {
    console.warn('Error:', result.message);
    return; // Early return - safe!
  }
  
  // Only success path performs destructive operations
  const data = result.json();
  this.saveToDatabase(data); // ‚úÖ Only happens once
}
```

This common pattern is safe because destructive operations only happen on the success path (ResponseSync). The second call (TimeoutError) hits the early return.

**Only risky if** you perform destructive actions on BOTH success AND error (e.g., incrementing error counters, sending alerts). In that case, use idempotency keys or check for "delivery timeout" in error messages.

See [Race Conditions](/docs/proxy-fetch/architecture-and-failure-modes#race-conditions) for detailed examples.
