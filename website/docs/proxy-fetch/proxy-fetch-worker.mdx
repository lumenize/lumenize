---
title: 'Proxy Fetch Worker'
description: CPU-billed external fetches with simple HTTP dispatch architecture
---

# Proxy Fetch Worker

De✨light✨ful external API calls from Durable Objects using [continuations](/docs/core/continuations), CPU billing, and a simplified HTTP dispatch architecture.

**`proxyFetchWorker`** is the recommended variant for external API calls, offering the best balance of performance, simplicity, and cost-effectiveness.

## Why Proxy Fetch Worker?

External API calls from Durable Objects can be expensive when billed on wall-clock time. `proxyFetchWorker` solves this by:

1. **CPU billing** - Workers are billed on CPU time, not wall-clock time
2. **Non-blocking** - Origin DO doesn't wait for the fetch to complete
3. **Simple deployment** - Single worker, no service bindings
4. **Low latency** - ~100-200ms overhead (including network)
5. **Type-safe** - Full TypeScript support with continuations

### Architecture

```
Origin DO                    Worker (same deployment)            External API
   │                                 │                                │
   ├─ proxyFetchWorker() ──>│       │                                │
   │  (returns immediately)  │       │                                │
   │                         │       │                                │
   │                    FetchOrchestrator                             │
   │                         │       │                                │
   │                         ├─ HTTP POST /proxy-fetch-execute ─────>│
   │                         │       │  (authenticated)               │
   │                         │       │                                │
   │                         │  Worker Handler                        │
   │                         │       ├──── fetch() ──────────────────>│
   │                         │       │      (CPU-billed!)             │
   │                         │       │<────── response ───────────────┤
   │                         │       │                                │
   │<──────── result ────────┼───────┤                                │
   │  (continuation executes)│       │                                │
```

**Key points**:
- Origin DO returns immediately after queueing
- FetchOrchestrator dispatches via HTTP to same worker
- Worker fetch handler executes the fetch (CPU-billed)
- Result delivered directly to origin DO
- Continuation executes with `Response | Error`

## Features

- **Simple setup** - Single worker, HTTP handler, shared secret
- **CPU billing** - Only pay for CPU time during fetch execution
- **Non-blocking** - Origin DO doesn't wait
- **[Continuations](/docs/core/continuations)** - Type-safe result handlers
- **Error handling** - Network failures and HTTP errors handled automatically
- **Low latency** - ~100-200ms end-to-end (production measurements)
- **Scalable** - Workers auto-scale with load

## Installation

```bash @skip-check
npm install @lumenize/proxy-fetch
```

## Setup

### 1. Add the Handler to Your Worker

```typescript @skip-check
import { handleProxyFetchExecution } from '@lumenize/proxy-fetch';
import { routeDORequest } from '@lumenize/utils';

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Try proxy-fetch handler first
    const proxyFetchResponse = await handleProxyFetchExecution(request, env);
    if (proxyFetchResponse) return proxyFetchResponse;
    
    // Fall through to your routing
    return await routeDORequest(request, env, { prefix: 'agents' });
  }
}
```

:::tip Pattern
This follows the same "check and fall through" pattern as `routeDORequest` - simple and composable!
:::

### 2. Set the Shared Secret

```bash @skip-check
wrangler secret put PROXY_FETCH_SECRET
# Enter a secure random string when prompted
```

The secret authenticates HTTP requests from `FetchOrchestrator` to your worker's fetch handler.

### 3. Configure Worker URL

In your `wrangler.jsonc`:

```jsonc @skip-check
{
  "vars": {
    "WORKER_URL": "https://your-worker.your-subdomain.workers.dev"
  }
}
```

Or pass it per-call via `options.workerUrl`.

### 4. Generate Types

```bash @skip-check
npm run types  # Runs: wrangler types
```

This generates `worker-configuration.d.ts` with your `Env` interface from `wrangler.jsonc`.

## Quick Start

```typescript @skip-check
import { LumenizeBase } from '@lumenize/lumenize-base';
import { proxyFetchWorker } from '@lumenize/proxy-fetch';

class UserDO extends LumenizeBase<Env> {
  async fetch(request: Request): Promise<Response> {
    // Fetch user data from external API
    await proxyFetchWorker(
      this,
      'https://api.example.com/users/123',
      this.ctn().handleUserData(this.ctn().$result),
      { originBinding: 'USER_DO' }
    );
    
    return new Response('Fetching user data...');
  }
  
  // Continuation receives Response | Error
  handleUserData(result: Response | Error) {
    if (result instanceof Error) {
      console.error('Fetch failed:', result);
      return;
    }
    
    // Success - process the response
    const data = await result.json();
    this.ctx.storage.kv.put('user-data', data);
  }
}
```

## Basic Usage

### Simple GET Request

```typescript @skip-check
class MyDO extends LumenizeBase {
  async fetchData(url: string) {
    await proxyFetchWorker(
      this,
      url,  // String URL for simple GET
      this.ctn().handleResponse(this.ctn().$result)
    );
  }
  
  handleResponse(result: Response | Error) {
    if (result instanceof Error) {
      console.error('Network error:', result);
      return;
    }
    
    console.log('Status:', result.status);
    const text = await result.text();
    console.log('Body:', text);
  }
}
```

### POST Request with Body

```typescript @skip-check
class MyDO extends LumenizeBase {
  async createUser(userData: any) {
    const request = new Request('https://api.example.com/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token123'
      },
      body: JSON.stringify(userData)
    });
    
    await proxyFetchWorker(
      this,
      request,  // Full Request object
      this.ctn().handleCreateUser(this.ctn().$result)
    );
  }
  
  handleCreateUser(result: Response | Error) {
    if (result instanceof Error) {
      console.error('Failed to create user:', result);
      return;
    }
    
    if (!result.ok) {
      console.error('HTTP error:', result.status);
      return;
    }
    
    const user = await result.json();
    this.ctx.storage.kv.put(`user:${user.id}`, user);
  }
}
```

## Error Handling

### Network Errors vs HTTP Errors

```typescript @skip-check
class MyDO extends LumenizeBase {
  handleFetchResult(result: Response | Error) {
    if (result instanceof Error) {
      // ❌ Network failure (DNS, timeout, connection refused, etc.)
      console.error('Network error:', result.message);
      
      if (result.message.includes('timeout')) {
        // Handle timeout
      }
      
      return;
    }
    
    // ✅ Response received (but may have HTTP error)
    if (!result.ok) {
      // HTTP error (4xx, 5xx)
      console.error('HTTP error:', result.status, result.statusText);
      
      if (result.status === 404) {
        // Handle not found
      } else if (result.status >= 500) {
        // Handle server error - maybe retry
      }
      
      return;
    }
    
    // Success!
    const data = await result.json();
    this.ctx.storage.kv.put('data', data);
  }
}
```

:::tip HTTP Errors
HTTP errors (404, 500, etc.) return a `Response` object, not an `Error`. Always check `result.ok` or `result.status`.
:::

### Timeout Configuration

```typescript @skip-check
await proxyFetchWorker(
  this,
  'https://slow-api.example.com/data',
  this.ctn().handleResponse(this.ctn().$result),
  {
    timeout: 60000,  // 60 seconds (default: 30000)
    originBinding: 'MY_DO'
  }
);
```

## Advanced Patterns

### Context Preservation

```typescript @skip-check
class OrderDO extends LumenizeBase {
  async fetchOrderDetails(orderId: string, userId: string) {
    const timestamp = Date.now();
    const url = `https://api.example.com/orders/${orderId}`;
    
    await proxyFetchWorker(
      this,
      url,
      // Capture context in continuation
      this.ctn().handleOrderData(orderId, userId, timestamp, this.ctn().$result)
    );
  }
  
  handleOrderData(
    orderId: string,
    userId: string,
    timestamp: number,
    result: Response | Error
  ) {
    if (result instanceof Error) {
      console.error(`Order ${orderId} fetch failed for user ${userId}`);
      return;
    }
    
    const duration = Date.now() - timestamp;
    console.log(`Order ${orderId} fetched in ${duration}ms`);
    
    const order = await result.json();
    this.ctx.storage.kv.put(`order:${orderId}`, {
      order,
      userId,
      fetchedAt: timestamp,
      duration
    });
  }
}
```

### Chaining Operations

```typescript @skip-check
class DataDO extends LumenizeBase {
  async fetchAndProcess(url: string) {
    await proxyFetchWorker(
      this,
      url,
      // Chain: parse → validate → transform → save
      this.ctn()
        .parseResponse(this.ctn().$result)
        .validateData()
        .transformData()
        .saveToStorage()
    );
  }
  
  parseResponse(result: Response | Error) {
    if (result instanceof Error) throw result;
    return result.json();
  }
  
  validateData(data: any) {
    if (!data.id) throw new Error('Invalid data: missing id');
    if (!data.name) throw new Error('Invalid data: missing name');
    return data;
  }
  
  transformData(data: any) {
    return {
      ...data,
      processedAt: Date.now(),
      version: 2
    };
  }
  
  saveToStorage(data: any) {
    this.ctx.storage.kv.put(`data:${data.id}`, data);
    console.log('Saved:', data.id);
  }
}
```

### Parallel Fetches

```typescript @skip-check
class AggregatorDO extends LumenizeBase {
  async fetchFromMultipleSources() {
    // Start all fetches in parallel
    await Promise.all([
      proxyFetchWorker(this, 'https://api-a.example.com/data', 
        this.ctn().handleSourceA(this.ctn().$result)),
      proxyFetchWorker(this, 'https://api-b.example.com/data',
        this.ctn().handleSourceB(this.ctn().$result)),
      proxyFetchWorker(this, 'https://api-c.example.com/data',
        this.ctn().handleSourceC(this.ctn().$result))
    ]);
    
    console.log('All fetches queued!');
  }
  
  #results = new Map<string, any>();
  
  handleSourceA(result: Response | Error) {
    if (result instanceof Error) return;
    const data = await result.json();
    this.#results.set('A', data);
    this.#checkComplete();
  }
  
  handleSourceB(result: Response | Error) {
    if (result instanceof Error) return;
    const data = await result.json();
    this.#results.set('B', data);
    this.#checkComplete();
  }
  
  handleSourceC(result: Response | Error) {
    if (result instanceof Error) return;
    const data = await result.json();
    this.#results.set('C', data);
    this.#checkComplete();
  }
  
  #checkComplete() {
    if (this.#results.size === 3) {
      console.log('All sources complete!');
      this.processAggregatedData(this.#results);
    }
  }
  
  processAggregatedData(results: Map<string, any>) {
    // Combine data from all sources
  }
}
```

### Retry with Backoff

```typescript @skip-check
class ResilientDO extends LumenizeBase {
  async fetchWithRetry(url: string, maxRetries = 3) {
    // Store retry state
    this.ctx.storage.kv.put('retry-state', {
      url,
      attempt: 0,
      maxRetries,
      startTime: Date.now()
    });
    
    await this.#attemptFetch(url);
  }
  
  async #attemptFetch(url: string) {
    await proxyFetchWorker(
      this,
      url,
      this.ctn().handleRetryableResponse(this.ctn().$result)
    );
  }
  
  async handleRetryableResponse(result: Response | Error) {
    const state = this.ctx.storage.kv.get('retry-state') as any;
    
    if (result instanceof Error || !result.ok) {
      // Failure - check if we should retry
      if (state.attempt >= state.maxRetries) {
        console.error('Max retries reached:', result);
        this.ctx.storage.kv.delete('retry-state');
        return;
      }
      
      // Exponential backoff: 2s, 4s, 8s
      const backoffSeconds = Math.pow(2, state.attempt + 1);
      console.log(`Retry ${state.attempt + 1}/${state.maxRetries} in ${backoffSeconds}s`);
      
      // Update state
      state.attempt++;
      this.ctx.storage.kv.put('retry-state', state);
      
      // Schedule retry
      await this.svc.alarms.schedule(
        backoffSeconds,
        this.ctn().#attemptFetch(state.url)
      );
      
      return;
    }
    
    // Success!
    const data = await result.json();
    const duration = Date.now() - state.startTime;
    console.log(`Fetch succeeded on attempt ${state.attempt + 1} (${duration}ms)`);
    
    this.ctx.storage.kv.put('data', data);
    this.ctx.storage.kv.delete('retry-state');
  }
}
```

## Configuration

### Environment Variables

Configure in `wrangler.jsonc`:

```jsonc @skip-check
{
  "vars": {
    "WORKER_URL": "https://your-worker.your-subdomain.workers.dev"
  }
}
```

### Per-Call Options

```typescript @skip-check
await proxyFetchWorker(
  this,
  url,
  continuation,
  {
    timeout: 30000,              // Timeout in ms (default: 30000)
    workerUrl: 'https://...',    // Override env.WORKER_URL
    workerPath: '/custom-path',  // Override path (default: /proxy-fetch-execute)
    originBinding: 'MY_DO'       // Binding name for callbacks (auto-detected)
  }
);
```

## Performance

Production measurements (from SF to Cloudflare edge):

- **Enqueue latency**: 131ms average (includes network round-trip)
- **End-to-end**: 271ms average (for 1s external API delay)
- **Consistency**: 93-520ms range (better than service bindings)

See [experiments/proxy-fetch-latency/MEASUREMENTS.md](https://github.com/transformation/lumenize/blob/main/experiments/proxy-fetch-latency/MEASUREMENTS.md) for detailed measurements.

:::tip Production Performance
In production (within Cloudflare network), the actual DO→Worker overhead is likely &lt;20ms. The measured latency includes client network round-trip.
:::

## Comparison to Other Variants

| Variant | Latency | Setup | Billing | Best For |
|---------|---------|-------|---------|----------|
| **proxyFetchWorker** | ~100-200ms | Simple | CPU | ✅ Recommended |
| proxyFetchDO | ~10-20ms | Simple | Wall-clock | Low latency, short fetches |
| proxyFetchQueue | ~500-2000ms | Complex | CPU | Legacy |

**Recommendation**: Use `proxyFetchWorker` for all new projects. It offers the best balance of simplicity, cost, and performance.

## Best Practices

### ✅ Do

- Check for `Error` first in all continuations
- Check `result.ok` for HTTP errors
- Set reasonable timeouts
- Preserve context by passing it as arguments
- Handle all error cases
- Use `workerUrl` from environment variables

### ❌ Don't

- Don't use `async` in continuations (breaks consistency)
- Don't ignore errors
- Don't pass sensitive data in URLs (use request headers)
- Don't create circular references in arguments
- Don't forget to set `PROXY_FETCH_SECRET`
- Don't hardcode `workerUrl` (use env vars)

## Troubleshooting

### "PROXY_FETCH_SECRET not configured"

Set the secret using wrangler:

```bash @skip-check
wrangler secret put PROXY_FETCH_SECRET
```

### "Worker URL not provided"

Add to `wrangler.jsonc`:

```jsonc @skip-check
{
  "vars": {
    "WORKER_URL": "https://your-worker.your-subdomain.workers.dev"
  }
}
```

Or pass via options:

```typescript @skip-check
await proxyFetchWorker(this, url, continuation, {
  workerUrl: 'https://...'
});
```

### Authentication Failures

If you see 401 errors:

1. Verify `PROXY_FETCH_SECRET` is set: `wrangler secret list`
2. Redeploy after setting secret: `wrangler deploy`
3. Check secret matches in all environments (dev/staging/prod)

### Timeout Issues

If fetches frequently timeout:

1. Increase timeout: `{ timeout: 60000 }`
2. Check external API performance
3. Consider retry with backoff pattern
4. Check if API rate-limiting you

## Security Considerations

### Secret Management

- **Never commit secrets** - Use `wrangler secret put`
- **Rotate secrets** - Update periodically
- **Per-environment** - Use different secrets for dev/prod
- **Access control** - Only workers with the secret can execute fetches

### Request Validation

The `handleProxyFetchExecution` handler automatically:
- ✅ Validates `X-Proxy-Fetch-Secret` header
- ✅ Checks request path
- ✅ Returns 401 for invalid auth
- ✅ Returns 400 for invalid requests

## API Reference

See the [TypeDoc API Reference](/docs/proxy-fetch/api) for complete type information.

## Next Steps

- **[Continuations](/docs/core/continuations)** - Understanding the continuation pattern
- **[Call](/docs/call/index)** - DO-to-DO communication with continuations
- **[Alarms](/docs/alarms/index)** - Scheduled tasks with continuations
- **[Other Variants](/docs/proxy-fetch/index)** - Compare proxy-fetch variants

