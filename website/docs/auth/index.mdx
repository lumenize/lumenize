---
title: Auth
description: Magic link authentication with JWT tokens for Cloudflare Durable Objects
---

# Auth

A de✨light✨ful authentication package for Cloudflare Durable Objects with magic link login, JWT access tokens, and refresh token rotation.

**Key Features:**
- ✅ **Passwordless** - Magic link email login (no passwords to manage)
- ✅ **Secure JWTs** - Ed25519 signed tokens with key rotation support
- ✅ **Refresh token rotation** - Automatic token refresh with revocation
- ✅ **Rate limiting** - Built-in protection against abuse
- ✅ **WebSocket auth** - Token passing via subprotocol headers
- ✅ **Middleware** - Drop-in `routeDORequest` hooks for protected routes

## Quick Start

### 1. Install

```bash @skip-check
npm install @lumenize/auth @lumenize/lumenize-base @lumenize/utils
```

### 2. Generate Ed25519 Key Pair

```bash @skip-check
# Generate private key
openssl genpkey -algorithm ed25519 -out private.pem

# Extract public key
openssl pkey -in private.pem -pubout -out public.pem

# View keys (copy to .dev.vars)
cat private.pem | tr '\n' '\\n' && echo
cat public.pem | tr '\n' '\\n' && echo
```

### 3. Configure Environment Variables

Create `.dev.vars` with your keys:

```bash @skip-check
JWT_PRIVATE_KEY_BLUE="-----BEGIN PRIVATE KEY-----\nMC4CAQAw..."
JWT_PUBLIC_KEY_BLUE="-----BEGIN PUBLIC KEY-----\nMCowBQYD..."
ACTIVE_JWT_KEY="BLUE"
```

### 4. Configure wrangler.jsonc

```jsonc @skip-check
{
  "name": "my-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      { "name": "LUMENIZE_AUTH", "class_name": "LumenizeAuth" },
      { "name": "MY_DO", "class_name": "MyDO" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["LumenizeAuth", "MyDO"] }
  ]
}
```

### 5. Set Up Worker

```typescript @check-example('packages/auth/test/for-docs/quick-start.test.ts')
import { LumenizeAuth, createAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

export { LumenizeAuth };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - no auth middleware (public endpoints)
    const authResponse = await routeDORequest(request, env, {
      prefix: 'auth',
      cors: true
    });
    if (authResponse) return authResponse;

    // Protected routes - with auth middleware
    const authMiddleware = await createAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });
    
    return routeDORequest(request, env, {
      onBeforeRequest: authMiddleware,
      onBeforeConnect: authMiddleware,
      cors: true
    }) ?? new Response('Not Found', { status: 404 });
  }
};
```

## Login Flow

The magic link flow works as follows:

```mermaid @skip-check
sequenceDiagram
    participant User
    participant Worker
    participant AuthDO
    participant Email
    
    User->>Worker: POST /auth/email-magic-link {email}
    Worker->>AuthDO: Forward request
    AuthDO->>Email: Send magic link
    AuthDO->>Worker: {message: "Check email"}
    Worker->>User: Response
    
    Note over User: User clicks email link
    
    User->>Worker: GET /auth/magic-link?token=...&state=...
    Worker->>AuthDO: Validate token
    AuthDO->>Worker: {access_token, Set-Cookie: refresh-token}
    Worker->>User: JWT + refresh cookie
```

### Request Magic Link

```typescript @skip-check
const response = await fetch('https://myapp.com/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: 'user@example.com' })
});
// Returns: { message: "Check your email for the magic link", expires_in: 1800 }
```

### Validate Magic Link

When the user clicks the link, they're directed to `/auth/magic-link?magic-link-token=...&state=...`. The response includes:

```json @skip-check
{
  "access_token": "eyJhbGciOiJFZERTQSIs...",
  "token_type": "Bearer",
  "expires_in": 900
}
```

Plus a `Set-Cookie` header with the refresh token (HttpOnly, Secure, SameSite=Strict).

## Protecting Routes

### HTTP Routes

Use `createAuthMiddleware` with `routeDORequest`:

```typescript @check-example('packages/auth/test/for-docs/middleware.test.ts')
import { createAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

// Create middleware once at startup
const authMiddleware = await createAuthMiddleware({
  publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN],
  audience: 'https://myapp.com',
  issuer: 'https://myapp.com'
});

// Use in routeDORequest
const response = await routeDORequest(request, env, {
  onBeforeRequest: authMiddleware,
  cors: true
});
```

The middleware:
1. Extracts the Bearer token from the `Authorization` header
2. Verifies the JWT signature (tries all provided keys for rotation)
3. Validates expiration, audience, and issuer
4. On success: Enhances request with `X-Auth-User-Id` and `X-Auth-Verified` headers
5. On failure: Returns 401 with `WWW-Authenticate` header

### WebSocket Routes

For WebSocket connections, use `createWebSocketAuthMiddleware`:

```typescript @check-example('packages/auth/test/for-docs/websocket.test.ts')
import { createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

const wsAuthMiddleware = await createWebSocketAuthMiddleware({
  publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
});

const response = await routeDORequest(request, env, {
  onBeforeConnect: wsAuthMiddleware
});
```

**Client-side WebSocket connection:**

```javascript @skip-check
// Pass token via WebSocket subprotocol
const ws = new WebSocket(url, ['lmz', `lmz.access-token.${accessToken}`]);
```

The middleware extracts the token from the `Sec-WebSocket-Protocol` header and verifies it before allowing the connection.

### Verifying Tokens in DO Message Handlers

For WebSocket message handlers (which bypass the Worker), use `verifyWebSocketToken`:

```typescript @skip-check
import { verifyWebSocketToken, WS_CLOSE_CODES } from '@lumenize/auth';

class MyDO extends DurableObject {
  #publicKeys: CryptoKey[] = [];
  #userTokens = new Map<WebSocket, string>(); // Store token from initial connection

  async webSocketMessage(ws: WebSocket, message: string) {
    const token = this.#userTokens.get(ws);
    if (!token) {
      ws.close(WS_CLOSE_CODES.NO_TOKEN, 'No token');
      return;
    }

    const result = await verifyWebSocketToken(token, this.#publicKeys);
    
    if (!result.valid) {
      if (result.expired) {
        ws.close(WS_CLOSE_CODES.TOKEN_EXPIRED, 'Token expired');
      } else {
        ws.close(WS_CLOSE_CODES.UNAUTHORIZED, 'Invalid token');
      }
      return;
    }
    
    // Process message with result.userId
    console.log(`Message from user ${result.userId}:`, message);
  }
}
```

## Token Refresh

Access tokens are short-lived (default 15 minutes). Use the refresh token to get new ones:

```typescript @skip-check
const response = await fetch('https://myapp.com/auth/refresh-token', {
  method: 'POST',
  credentials: 'include' // Important: sends the refresh cookie
});

const { access_token, expires_in } = await response.json();
```

**Refresh token rotation:** Each use of the refresh token invalidates the old one and issues a new one. This limits the damage if a refresh token is stolen.

## Logout

Revoke the refresh token and clear the cookie:

```typescript @skip-check
await fetch('https://myapp.com/auth/logout', {
  method: 'POST',
  credentials: 'include'
});
// Cookie is cleared, refresh token is revoked
```

## Configuration

Configure the Auth DO programmatically:

```typescript @skip-check
// In your DO or via RPC
const stub = env.LUMENIZE_AUTH.getByName('default');
await stub.configure({
  issuer: 'https://myapp.com',
  audience: 'https://api.myapp.com',
  accessTokenTtl: 900,      // 15 minutes (default)
  refreshTokenTtl: 2592000, // 30 days (default)
  magicLinkTtl: 1800,       // 30 minutes (default)
  rateLimitPerHour: 5       // 5 requests per email per hour (default)
});
```

## Key Rotation

The package supports zero-downtime key rotation with BLUE/GREEN keys:

1. **Normal operation:** Sign with BLUE, verify with BLUE
2. **Rotate keys:**
   - Generate new GREEN key pair
   - Add `JWT_PRIVATE_KEY_GREEN` and `JWT_PUBLIC_KEY_GREEN` to secrets
   - Add GREEN public key to middleware: `publicKeysPem: [BLUE, GREEN]`
   - Set `ACTIVE_JWT_KEY="GREEN"` to start signing with GREEN
3. **After all BLUE tokens expire:** Remove BLUE keys from middleware

```typescript @skip-check
// Middleware accepts tokens signed with either key
const middleware = await createAuthMiddleware({
  publicKeysPem: [
    env.JWT_PUBLIC_KEY_BLUE,  // Active key
    env.JWT_PUBLIC_KEY_GREEN  // Fallback during rotation
  ]
});
```

## API Reference

### LumenizeAuth DO

**HTTP Endpoints:**
- `GET /auth/enter` - Returns login instructions
- `POST /auth/email-magic-link` - Request magic link (body: `{email}`)
- `GET /auth/magic-link` - Validate magic link and login
- `POST /auth/refresh-token` - Refresh access token (uses cookie)
- `POST /auth/logout` - Revoke refresh token

**RPC Methods:**
- `getUserById(userId)` - Look up user by ID
- `getUserByEmail(email)` - Look up user by email
- `configure(options)` - Set auth configuration
- `setEmailService(service)` - Set email provider

### Middleware Functions

- `createAuthMiddleware(config)` - HTTP auth middleware (async init)
- `createAuthMiddlewareSync(config)` - HTTP auth middleware (sync, pre-imported keys)
- `createWebSocketAuthMiddleware(config)` - WebSocket auth middleware

### WebSocket Utilities

- `extractWebSocketToken(request)` - Extract token from subprotocol
- `verifyWebSocketToken(token, publicKeys)` - Verify token for messages
- `getTokenTtl(payload)` - Get seconds until expiration
- `WS_CLOSE_CODES` - Standard close codes (`TOKEN_EXPIRED`, `UNAUTHORIZED`, `NO_TOKEN`)

### JWT Utilities

- `signJwt(payload, privateKey, keyId)` - Sign a JWT
- `verifyJwt(token, publicKey)` - Verify JWT signature
- `verifyJwtWithRotation(token, publicKeys)` - Verify with multiple keys
- `importPrivateKey(pem)` - Import PEM private key
- `importPublicKey(pem)` - Import PEM public key
- `parseJwtUnsafe(token)` - Parse without verification (for debugging)

### Email Services

- `ConsoleEmailService` - Logs to console (development)
- `HttpEmailService` - Sends via HTTP POST
- `MockEmailService` - Collects emails in memory (testing)
- `createDefaultEmailService(env)` - Factory for default service

## Security Considerations

1. **Always use HTTPS** - JWTs and cookies require secure transport
2. **Store keys securely** - Use Cloudflare secrets, not wrangler.jsonc
3. **Set appropriate TTLs** - Shorter access tokens = less damage if stolen
4. **Validate audience/issuer** - Prevent token confusion attacks
5. **Handle timeouts carefully** - Ambiguous state requires idempotency

## Test Mode

For development and testing, add `?_test=true` to the magic link request:

```typescript @skip-check
const response = await fetch('/auth/email-magic-link?_test=true', {
  method: 'POST',
  body: JSON.stringify({ email: 'test@example.com' })
});
// Returns: { message: "Magic link generated (test mode)", magic_link: "..." }
```

This returns the magic link directly instead of sending an email. Requires `AUTH_TEST_MODE="true"` in environment.

