---
title: Auth
description: Passwordless authentication with magic links, invites, and JWT tokens, for Cloudflare Durable Objects
---

# Auth

De✨light✨ful passwordless authentication for Cloudflare Durable Objects with magic link login, JWT access tokens, refresh token rotation, and built-in admin role. Serves as the default authentication for Lumenize Mesh but can be used with any Cloudflare Workers project.

| Feature | Description |
|---------|-------------|
| **Passwordless** | Magic link email login (no passwords to manage) |
| **Secure JWTs** | Ed25519 signed tokens with key rotation support |
| **Refresh rotation** | Automatic token refresh with revocation |
| **Two-phase access** | Requires both subject confirmation (`emailVerified`) and admin approval (`adminApproved`) |
| **Admin role bootstrapped** | First `isAdmin` bootstrapped via environment variable |
| **Delegation** | RFC 8693 `act` claim for delegated access (agents, services, impersonation) |
| **Rate limiting** | Cloudflare DDoS + Turnstile (magic link) + Worker-level rate limiting binding (authenticated routes) |
| **WebSocket auth** | Token passing via subprotocol headers |
| **Hooks** | Drop-in `routeDORequest` hooks for protected routes |

:::note Why "subject" instead of "user"?
These docs use **subject** — the [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519) term for the entity a JWT describes. A subject could be a person, an AI agent, a service account, or any authenticated entity. The standard `sub` claim carries this meaning, so we use "subject" everywhere rather than "user" to avoid implying the principal is always human.
:::

## Getting Started

:::note Lumenize Mesh/Utils used to illustrate
In these docs, `@lumenize/mesh` and `@lumenize/utils` are used to illustrate Lumenize Auth, but `@lumenize/auth` will work with any Cloudflare Workers/Durable Object system. The integration surface is the standard `Authorization` header: the auth hooks verify the JWT and forward it to your DO in the `Authorization: Bearer <jwt>` header — for both HTTP requests and WebSockets. See [Integrating Alternative Auth](/docs/mesh/security#integrating-alternative-auth-advanced) for the exact header contract.
:::

For a complete setup walkthrough including key generation, environment configuration, and Worker setup, see [Lumenize Mesh: Getting Started](/docs/mesh/getting-started#step-5-set-up-authentication).

## Installation

```bash
npm install @lumenize/auth
```

## Bootstrap: Your First Admin

Before anyone can log in with admin privileges, you need to designate a bootstrap admin. Set the `LUMENIZE_AUTH_BOOTSTRAP_EMAIL` environment variable:

```bash
# In .dev.vars or wrangler.jsonc (local development)
LUMENIZE_AUTH_BOOTSTRAP_EMAIL=you@example.com

# In production (no `wrangler variable` command exists, so use `wrangler secret` or the dashboard)
wrangler secret put LUMENIZE_AUTH_BOOTSTRAP_EMAIL
```

When this email address logs in, LumenizeAuth automatically grants `isAdmin: true`, `emailVerified: true`, and `adminApproved: true`. This check is idempotent — it runs on every login, so the bootstrap admin is restored even after a DO reset or if the environment variable is added after the subject already exists. No database seeding required. The bootstrap admin can then approve other subjects and promote them to admin via the [subject management APIs](/docs/auth/api-reference#subject-management-endpoints).

The bootstrap subject has special protection: it cannot be demoted or deleted via API. To change the bootstrap admin, update the environment variable and deploy.

## Access Flows

Two-phase access requires both `emailVerified` (subject clicked link) and `adminApproved` (admin granted access). These can happen in either order via two flows. 

### Self-Signup Flow

Subject initiates signup, then waits for admin approval:

```mermaid
sequenceDiagram
    box Browser
        participant Subject
        participant Admin
    end
    participant Worker
    participant AuthDO

    rect rgba(200, 220, 240, 0.3)
        Note over Subject,AuthDO: 1. Subject requests magic link
        Subject->>Worker: POST /auth/email-magic-link {email}
        Worker->>AuthDO: Forward request
        Note over AuthDO: Send magic link email
        AuthDO->>Worker: { message: "Check email" }
        Worker->>Subject: Response
    end

    rect rgba(240, 220, 200, 0.3)
        Note over Subject,AuthDO: 2. Subject clicks link → { emailVerified: true }
        Subject->>Worker: GET /auth/magic-link?one_time_token=...
        Worker->>AuthDO: Validate token, set emailVerified: true
        Note over AuthDO: Send approval request to admins
        AuthDO->>Worker: Set-Cookie + 302 redirect
        Worker->>Subject: Redirect (refresh_token cookie set)
    end

    rect rgba(255, 220, 220, 0.3)
        Note over Subject,AuthDO: 3. Access blocked until approved
        Subject->>Worker: POST /auth/refresh-token (cookie)
        Worker->>AuthDO: Get access token
        AuthDO->>Worker: { access_token } (emailVerified: true, adminApproved: false)
        Note over Subject: Token valid but hooks return 403
    end

    rect rgba(220, 255, 220, 0.3)
        Note over Admin,AuthDO: 4. Admin approves → { adminApproved: true }
        Admin->>Worker: GET /auth/approve/:id (from admin email)
        Worker->>AuthDO: Set adminApproved: true
        Note over AuthDO: Send "You're approved" email to subject
        AuthDO->>Worker: Confirmation
        Worker->>Admin: Response
    end

    rect rgba(200, 240, 200, 0.3)
        Note over Subject,AuthDO: 5. Subject now has access
        Subject->>Worker: POST /auth/refresh-token (cookie)
        Worker->>AuthDO: Get access token
        AuthDO->>Worker: { access_token } (emailVerified: true, adminApproved: true)
        Worker->>Subject: Full access granted
    end
```

### Admin Invite Flow

Invite from admin pre-approves subjects, then subjects confirm via email:

```mermaid
sequenceDiagram
    box Browser
        participant Admin
        participant Subject
    end
    participant Worker
    participant AuthDO

    rect rgba(220, 220, 255, 0.3)
        Note over Admin,AuthDO: 1. Admin invites subjects → { adminApproved: true }
        Admin->>Worker: POST /auth/invite {emails: [...]}
        Worker->>AuthDO: Create subjects with adminApproved: true
        Note over AuthDO: Send invite email to each subject
        AuthDO->>Worker: { invited: [...] }
        Worker->>Admin: Response
    end

    rect rgba(240, 220, 200, 0.3)
        Note over Subject,AuthDO: 2. Subject clicks invite link → { emailVerified: true }
        Subject->>Worker: GET /auth/accept-invite?invite_token=...
        Worker->>AuthDO: Validate token, set emailVerified: true
        AuthDO->>Worker: Set-Cookie + 302 redirect
        Worker->>Subject: Redirect (refresh_token cookie set)
    end

    rect rgba(200, 240, 200, 0.3)
        Note over Subject,AuthDO: 3. Subject has immediate access
        Note over Subject: Both flags true from the start
    end
```

### Tokens

| Token | Query param / storage | Lifetime | Reusable? | Purpose |
|-------|----------------------|----------|-----------|---------|
| **One-time login token** | `?one_time_token=...` | 30 min | No (deleted on use) | Magic link self-signup |
| **Invite token** | `?invite_token=...` | 7 days | Yes (valid until expiry) | Admin invite acceptance |
| **Refresh token** | HttpOnly cookie | 30 days | No (rotated on use) | Obtain new access tokens |
| **Access token** | Memory (JS) | 15 min | N/A (stateless JWT) | Authenticate requests, carries claims |

### Request Magic Link

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: 'user@example.com' })
});
// Returns: { message: "Check your email for the magic link", expires_in: 1800 }
```

### Exchange One-time Login Token for Refresh Token Cookie

When the subject clicks the magic link, the server validates the one-time login token, sets the refresh token cookie, and returns a 302 redirect to the [`LUMENIZE_AUTH_REDIRECT`](/docs/auth/api-reference#auth-config) URL.

### Get Access Token with Role Claims

**With LumenizeClient**: token management is automatic. `LumenizeClient` handles retrieving the access token using the refresh token cookie, transparent access token refresh, reconnection, and a callback for you to re-route to a login page when necessary. See [LumenizeClient: Authentication](/docs/mesh/lumenize-client#authentication).

**Manual token management** (for non-Lumenize Mesh use):

```typescript @skip-check-approved('conceptual')
// On app load, get access token using the refresh token cookie
const response = await fetch('/auth/refresh-token', { method: 'POST' });
if (response.status === 401) {
  window.location.href = '/login';       // Refresh token expired or missing
} else if (response.status === 403) {
  window.location.href = '/pending';     // Authenticated but not yet approved
} else {
  const { access_token } = await response.json();
  // access_token contains claims: { sub, isAdmin, ... }
}
```

### Logout

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
await fetch('/auth/logout', { method: 'POST' });
// Refresh token cookie is cleared
```

## JWT Claims

Access tokens contain standard JWT claims plus status and role information:

```typescript @check-example('packages/auth/src/types.ts')
interface JwtPayload {
  // Standard claims (RFC 7519)
  iss: string;          // Issuer
  aud: string;          // Audience
  sub: string;          // Subject (UUID of the principal)
  exp: number;          // Expiration time
  iat: number;          // Issued at
  jti: string;          // JWT ID

  // Status flags (both required for access)
  emailVerified: boolean;   // Subject clicked magic link
  adminApproved: boolean;   // Admin granted access

  // Role flag
  isAdmin?: boolean;

  // Delegation (RFC 8693)
  act?: ActClaim;
}
```

The `act` claim enables delegation — one authenticated subject acting on behalf of another. It's recursive per [RFC 8693](https://datatracker.ietf.org/doc/html/rfc8693): each layer records who delegated to whom. Guards check `sub` for authorization; the `act` chain is recorded for audit trails.

Admins can delegate as any subject. Non-admin actors must be explicitly listed in the principal's `authorizedActors`. The actor must be an authenticated subject; the principal must be a valid subject (exists in the database). Service account and AI agent authentication (API keys, service tokens) is planned for a future release. See [API Reference: Delegation](/docs/auth/api-reference#delegation) for the full delegation API, including how to authorize actors and request delegated tokens.

## Server-Side Token Verification

Use `createRouteDORequestAuthHooks` to create hooks that verify access tokens and enforce two-phase access control. The hooks:

1. Validate the JWT signature against your public keys
2. Verify `emailVerified && adminApproved` (admins pass implicitly)
3. Enforce the `LUMENIZE_AUTH_RATE_LIMITER` binding (keyed on `sub`)
4. Return 401 (invalid/missing token), 403 (not approved), or 429 (rate limited)
5. Forward the verified JWT to the DO in the standard `Authorization: Bearer` header

```typescript @check-example('packages/auth/test/for-docs/middleware.test.ts')
import { createRouteDORequestAuthHooks } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

// Create hooks (reads JWT_PUBLIC_KEY_BLUE/GREEN from env automatically)
const { onBeforeRequest, onBeforeConnect } = await createRouteDORequestAuthHooks(env);

// Use in routeDORequest
const response = await routeDORequest(request, env, {
  onBeforeRequest,
  onBeforeConnect,
  // ...
});
```

**WebSocket token delivery** (if not using LumenizeClient): Smuggle the token via the subprotocol list:

```javascript @skip-check-approved('conceptual')
// Client-side
const ws = new WebSocket(url, ['lmz', `lmz.access-token.${accessToken}`]);
```

## How the JWT Reaches Your DO

After `createRouteDORequestAuthHooks` verifies the JWT, it forwards the original token to your Durable Object in the standard `Authorization: Bearer <jwt>` header. This works for both HTTP requests and WebSocket upgrades.

The WebSocket case is worth noting: browsers don't allow custom headers on WebSocket connections, so the token arrives via the subprotocol list (see [above](#server-side-token-verification)). The hooks extract and verify it at the Worker level, then set the `Authorization: Bearer <jwt>` header on the upgrade request before forwarding to the DO. Your DO code sees a consistent header regardless of transport.

Your DO can then decode the JWT payload and authorize however you like — role checks, ownership guards, audit logging, etc. Ed25519 verification is a local `crypto.subtle.verify()` call (no network round trip, sub-millisecond), so DOs that want defense-in-depth can cheaply re-verify. DOs that trust the Worker hooks can simply base64url-decode the payload section. For a concrete example using `@lumenize/mesh` guards, see [Security: Reusable Guards](/docs/mesh/security#reusable-guards).

## Key Rotation

The BLUE/GREEN pattern enables zero-downtime key rotation. Tokens are verified against each public key until one succeeds.

### Secrets and Variables

**Secrets** - Generate two key pairs with:
```bash
# Generate and display private key (copy for next step)
openssl genpkey -algorithm ed25519 | tee /dev/stderr | openssl pkey -pubout
```

Set in the dashboard or via command line:

```bash
# Primary key pair (signs new tokens)
wrangler secret put JWT_PRIVATE_KEY_BLUE
wrangler secret put JWT_PUBLIC_KEY_BLUE

# Secondary key pair (verifies old tokens during rotation)
wrangler secret put JWT_PRIVATE_KEY_GREEN
wrangler secret put JWT_PUBLIC_KEY_GREEN
```

Paste each key (including `-----BEGIN/END-----` lines) when prompted.

**Variable** - Set `PRIMARY_JWT_KEY` to `BLUE` in the dashboard or wrangler.jsonc/wrangler.toml

### Key Rotation Procedure

Every 3 months for 6 month lifetime:
1. **Generate new key pair** for the secondary slot (GREEN if BLUE is primary)
2. **Switch primary** - change `PRIMARY_JWT_KEY` (to GREEN if BLUE is primary)
3. **Deploy** - environment variables/secrets only become active on deploy

## Rate Limiting

Rate limiting runs at the Worker level, not in the LumenizeAuth DO. This keeps the singleton DO focused on business logic and leverages Worker horizontal scaling.

### Cloudflare DDoS/Bot Protection

Fingerprint-reputation filtering handles volumetric attacks automatically. No configuration needed.

### Magic-Link Endpoint: Turnstile

The unauthenticated `POST {prefix}/email-magic-link` endpoint needs abuse protection. [Cloudflare Turnstile](https://developers.cloudflare.com/turnstile/) proves the requester is human before the request reaches your Worker — it's free, GDPR-compliant, and requires no CAPTCHA interaction. `createAuthRoutes` requires `TURNSTILE_SECRET_KEY` in your environment and throws at creation time if missing.

Your frontend embeds the [Turnstile widget](https://developers.cloudflare.com/turnstile/get-started/client-side-rendering/) and includes the resulting token as `cf-turnstile-response` in the JSON body alongside `email`:

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    email: 'user@example.com',
    'cf-turnstile-response': turnstileToken  // from the Turnstile widget callback
  })
});
```

`createAuthRoutes` extracts `cf-turnstile-response` from the body and verifies it with Cloudflare before forwarding to the DO. Returns 403 if verification fails.

### Authenticated Routes: Rate Limiter

`LUMENIZE_AUTH_RATE_LIMITER` protects all authenticated routes handled by `createRouteDORequestAuthHooks`, keyed on `sub` from the decoded JWT. Uses Cloudflare's [Rate Limiting binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/). `createRouteDORequestAuthHooks` **requires** this binding and throws at creation time if missing.

### Setup

Add the rate limiting binding to your `wrangler.jsonc`:

```jsonc
{
  "rate_limits": [
    { "binding": "LUMENIZE_AUTH_RATE_LIMITER", "namespace_id": "1001", "simple": { "limit": 100, "period": 60 } }
  ]
}
```

Add the Turnstile secret key:

```bash
# Local development (.dev.vars)
TURNSTILE_SECRET_KEY=0x4AAAAAAA...

# Use wrangler or dashboard for production
wrangler secret put TURNSTILE_SECRET_KEY
```

Both functions read all configuration from `env` automatically — `TURNSTILE_SECRET_KEY`, `LUMENIZE_AUTH_RATE_LIMITER`, and all [auth config](/docs/auth/api-reference#auth-config) variables (see [Worker Setup](#worker-setup)).

### Rate Limiting Caveats

The rate limiting binding is **per Cloudflare location** (not globally consistent) and **eventually consistent**. It is designed for abuse prevention, not precise accounting. This is fine for auth rate limiting — the goal is to stop floods, not enforce exact quotas.

## Test Mode

For development, add `?_test=true` to get links directly instead of sending emails. This works for both magic link and invite endpoints:

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/email-magic-link?_test=true', {
  method: 'POST',
  body: JSON.stringify({ email: 'test@example.com' })
});
// Returns: { message: "Magic link generated (test mode)", magic_link: "..." }
```

The [invite endpoint](/docs/auth/api-reference#invite-subjects) supports the same pattern — `POST {prefix}/invite?_test=true` returns invite links in the response instead of sending emails. A dedicated test helper for invite flows may be added in a future release.

:::info Recommendation: Put LUMENIZE_AUTH_TEST_MODE in vitest config
`LUMENIZE_AUTH_TEST_MODE="true"` must be set as an environment variable for test mode to work, but putting it in `wrangler.jsonc` risks accidentally deploying it — which would let anyone obtain magic links without email delivery. Instead, inject it via `miniflare.bindings` in your `vitest.config.js`, which only exists during test runs and is never deployed:

```javascript @skip-check-approved('config')
// vitest.config.js
export default defineWorkersProject({
  test: {
    poolOptions: {
      workers: {
        wrangler: { configPath: './wrangler.jsonc' },
        miniflare: {
          bindings: { LUMENIZE_AUTH_TEST_MODE: 'true' },
        },
      },
    },
  },
});
```
:::

For testing with specific roles, use `testLoginWithMagicLink`. The `browser` parameter is required — it provides a cookie jar that preserves the refresh token across the multi-step login flow:

```typescript @check-example('packages/auth/test/for-docs/test-helpers.test.ts')
import { testLoginWithMagicLink } from '@lumenize/auth';
import { Browser } from '@lumenize/testing';

const browser = new Browser();

// Login as approved regular subject
const { accessToken, sub } = await testLoginWithMagicLink(browser, 'alice@test.com', {
  subjectData: { adminApproved: true }  // emailVerified is set automatically
});

// Login as admin
const adminBrowser = new Browser();
const { accessToken: adminToken } = await testLoginWithMagicLink(adminBrowser, 'admin@test.com', {
  subjectData: { isAdmin: true }  // Admins implicitly have adminApproved
});

// Login with delegation — alice is the principal, the actor acts on her behalf
const actorBrowser = new Browser();
const { accessToken: actorToken } = await testLoginWithMagicLink(actorBrowser, 'actor@test.com', {
  subjectData: { adminApproved: true }
});
const aliceBrowser = new Browser();
const { accessToken: delegatedToken } = await testLoginWithMagicLink(aliceBrowser, 'alice@test.com', {
  subjectData: { adminApproved: true },
  actorAccessToken: actorToken  // actor's access token for delegation
});
```

## Worker Setup

Use `createAuthRoutes` to expose auth endpoints and `createRouteDORequestAuthHooks` to protect your DOs over HTTP (`onBeforeRequest`) or WebSockets (`onBeforeConnect`). Both integrate with [`routeDORequest`](/docs/utils/route-do-request). All auth configuration — including the URL prefix (default `/auth`), redirect URL, token TTLs, and issuer/audience — is read from [environment variables](/docs/auth/api-reference#auth-config):

```typescript @check-example('packages/auth/test/for-docs/quick-start.test.ts')
import { LumenizeAuth, createAuthRoutes, createRouteDORequestAuthHooks } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

export { LumenizeAuth };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - public endpoints
    const authRoutes = createAuthRoutes(env);
    const authResponse = await authRoutes(request);
    if (authResponse) return authResponse;

    // Protected routes - with auth hooks
    const authHooks = await createRouteDORequestAuthHooks(env);

    const response = await routeDORequest(request, env, {
      ...authHooks,
      cors: true
    });
    return response ?? new Response('Not Found', { status: 404 });
  }
};
```

## Audit Logging

All authentication and subject management operations produce structured JSON log entries via [`@lumenize/debug`](/docs/debug). These are emitted to `console.debug` and captured by Cloudflare's observability pipeline — no additional tables, endpoints, or retention logic needed.

Every audit entry includes a hierarchical namespace (`auth.LumenizeAuth.{category}.{action}`), a level (`info` or `warn`), a message, and a `data` object with fields like `targetSub`, `actorSub`, and action-specific details. Security-relevant events (failed logins, access denials, token revocations, subject deletions) use `warn` level; normal operational events (subject creation, logins, invites) use `info`.

Filter in the Cloudflare dashboard by namespace and level:

- `auth.LumenizeAuth` — all auth audit events
- `auth.LumenizeAuth.login` — login successes and failures
- `auth.LumenizeAuth:warn` — security-relevant events only

Audit logging is always active when `DEBUG` includes `auth` (or `*`). In production, set `DEBUG=auth` as an environment variable. In tests, inject it via `miniflare.bindings` in your `vitest.config.js`.

## API Reference

See the [API Reference](/docs/auth/api-reference) for endpoints, environment variables, function signatures, the [subject record](/docs/auth/api-reference#subject-record) schema, subject management, and delegation.
