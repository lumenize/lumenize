---
title: API Reference
description: Auth endpoints, environment variables, functions, subject management, and delegation
---

# API Reference

All endpoints use the configured `prefix` (default: `/auth`).

## Endpoints

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| [`{prefix}/email-magic-link`](#request-magic-link) | POST | None | Request magic link (self-signup) |
| [`{prefix}/magic-link`](#validate-magic-link) | GET | None | Validate magic link → `emailVerified`, notify admins |
| [`{prefix}/invite`](#invite-subjects) | POST | Admin | Invite subjects (bulk) → `adminApproved`, send invite emails |
| [`{prefix}/accept-invite`](#accept-invite) | GET | None | Accept invite → `emailVerified` |
| [`{prefix}/approve/:id`](#approve-subject) | GET | Admin | Approve subject → `adminApproved` (from admin notification email) |
| [`{prefix}/delegated-token`](#request-delegated-token) | POST | Bearer | Request token to act on behalf of another subject |
| [`{prefix}/refresh-token`](#refresh-token) | POST | Cookie | Exchange refresh token for access token |
| [`{prefix}/logout`](#logout) | POST | Cookie | Clear refresh token cookie |
| [`{prefix}/subjects`](#list-subjects) | GET | Admin | List subjects |
| [`{prefix}/subject/:id`](#get-subject) | GET | Admin | Get subject |
| [`{prefix}/subject/:id`](#update-subject) | PATCH | Admin | Update subject |
| [`{prefix}/subject/:id`](#delete-subject) | DELETE | Admin | Delete subject |

## Environment Variables

| Variable | Type | Required | Read By | Description |
|----------|------|----------|---------|-------------|
| `LUMENIZE_AUTH_BOOTSTRAP_EMAIL` | Secret | Yes | Auth DO | Email auto-promoted to admin on first login |
| `LUMENIZE_AUTH` | DO binding | Yes | `createAuthRoutes` | Durable Object namespace for `LumenizeAuth` |
| `JWT_PRIVATE_KEY_BLUE` | Secret | Yes¹ | Auth DO | Ed25519 private key (BLUE slot) |
| `JWT_PUBLIC_KEY_BLUE` | Secret | Yes¹ | Auth DO, hooks | Ed25519 public key (BLUE slot) |
| `JWT_PRIVATE_KEY_GREEN` | Secret | No² | Auth DO | Ed25519 private key (GREEN slot) |
| `JWT_PUBLIC_KEY_GREEN` | Secret | No² | Auth DO, hooks | Ed25519 public key (GREEN slot) |
| `PRIMARY_JWT_KEY` | Variable | Yes | Auth DO | Active signing slot: `"BLUE"` or `"GREEN"` |
| `TURNSTILE_SECRET_KEY` | Secret | Yes | `createAuthRoutes` | [Cloudflare Turnstile](https://developers.cloudflare.com/turnstile/) server-side secret |
| `LUMENIZE_AUTH_RATE_LIMITER` | Rate Limit binding | Yes | Hooks | [Rate Limiting binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/) keyed on `sub` |
| `LUMENIZE_AUTH_TEST_MODE` | Variable | No | Auth DO | Set to `"true"` to enable [test mode](/docs/auth/#test-mode) — **never deploy to production** |

¹ At least one key pair (BLUE or GREEN) is required. ² Second slot needed only during [key rotation](/docs/auth/#key-rotation).

**Naming convention**: `LUMENIZE_AUTH_*` for Lumenize-specific config, `JWT_*` for industry-standard key material (shared across packages), vendor prefix (e.g., `TURNSTILE_*`) for third-party services.

## Functions

### createAuthRoutes

Creates a request handler for all auth endpoints. Call once at module level.

```typescript @skip-check
const authRoutes = createAuthRoutes(env, {
  redirect: string,              // Required: redirect destination after magic link
  prefix?: string,               // Default: '/auth'
  gatewayBindingName?: string,   // Default: 'LUMENIZE_AUTH'
  instanceName?: string,         // Default: 'default'
  cors?: CorsConfig,             // Optional: CORS configuration
  // JWT and token options (passed to Auth DO)
  issuer?: string,               // Default: 'https://lumenize.local'
  audience?: string,             // Default: 'https://lumenize.local'
  accessTokenTtl?: number,       // Default: 900 (15 minutes)
  refreshTokenTtl?: number,      // Default: 2592000 (30 days)
  magicLinkTtl?: number,         // Default: 1800 (30 minutes)
});
// Throws if env.TURNSTILE_SECRET_KEY is not set
```

### createRouteDORequestAuthHooks

Creates hooks for [`routeDORequest`](/docs/utils/route-do-request) that verify JWTs and enforce [two-phase access control](/docs/auth/#access-flows):

```typescript @skip-check
const { onBeforeRequest, onBeforeConnect } = createRouteDORequestAuthHooks(env, {
  // All optional — defaults read from env
  audience?: string,                 // Default: 'https://lumenize.local'
  issuer?: string,                   // Default: 'https://lumenize.local'
  rateLimiterBinding?: RateLimit,    // Default: env.LUMENIZE_AUTH_RATE_LIMITER
});
// Options object is optional — createRouteDORequestAuthHooks(env) uses all defaults
// Public keys always read from env.JWT_PUBLIC_KEY_BLUE / env.JWT_PUBLIC_KEY_GREEN
```

Both hooks:
- Validate JWT signature against provided public keys (tries each until one succeeds)
- Verify `emailVerified && adminApproved` (admins pass implicitly)
- Return 401 for invalid/missing tokens
- Return 403 for valid tokens that fail the access check
- Return 429 when the rate limit is exceeded
- Forward the verified JWT in the `Authorization: Bearer <jwt>` header (see [How the JWT Reaches Your DO](/docs/auth/#how-the-jwt-reaches-your-do))

## Authentication Endpoints

### Request Magic Link

`POST {prefix}/email-magic-link` — No auth required

Sends a magic link email to the given address. Creates the subject record if it doesn't exist. Requires a valid [Turnstile](https://developers.cloudflare.com/turnstile/) token in the body.

```typescript @skip-check
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    email: 'user@example.com',
    'cf-turnstile-response': turnstileToken  // from the Turnstile widget callback
  })
});
// 200: { message: "Check your email for the magic link", expires_in: 1800 }
// 403: Turnstile verification failed
// 429: Rate limited
```

In [test mode](/docs/auth/#test-mode), append `?_test=true` to get the magic link directly without email delivery:

```typescript @skip-check
// 200: { message: "Magic link generated (test mode)", magic_link: "..." }
```

### Validate Magic Link

`GET {prefix}/magic-link?token=...` — No auth required

Called when the subject clicks the magic link. Validates the one-time token, sets `emailVerified: true`, creates a refresh token, and redirects. If the subject is not yet admin-approved, sends a notification email to all admins.

```
302 → redirect destination (configured in createAuthRoutes)
Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict
```

### Accept Invite

`GET {prefix}/accept-invite?token=...` — No auth required

Called when an invited subject clicks the invite link. Validates the token, sets `emailVerified: true` (subject already has `adminApproved: true` from the invite), creates a refresh token, and redirects. The subject has immediate access since both flags are now true.

```
302 → redirect destination (configured in createAuthRoutes)
Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict
```

Invite tokens expire after 7 days (configurable via `inviteTtl` on `createAuthRoutes`).

### Refresh Token

`POST {prefix}/refresh-token` — Cookie auth (refresh token)

Exchanges the refresh token cookie for a new access token. The access token JWT contains all [claims](/docs/auth/#jwt-claims) including status flags and role.

```typescript @skip-check
const response = await fetch('/auth/refresh-token', { method: 'POST' });
// 200: { access_token: "eyJ..." }
// 401: Refresh token expired, revoked, or missing
// 403: Subject has emailVerified but not adminApproved (pending approval)
```

### Logout

`POST {prefix}/logout` — Cookie auth (refresh token)

Revokes the refresh token and clears the cookie.

```typescript @skip-check
await fetch('/auth/logout', { method: 'POST' });
// 200: { message: "Logged out" }
```

## Subject Management Endpoints

Admin-only. You don't need to check `emailVerified` or `adminApproved` in your DO guards — subjects without both flags are blocked at the Worker level before any DO code runs. Your guards only need to check application-level concerns like `isAdmin` or resource ownership.

### List Subjects

`GET {prefix}/subjects` — Admin auth required

```typescript @skip-check
const response = await fetch('/auth/subjects', {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
const { subjects } = await response.json();
// subjects: [{ sub, email, emailVerified, adminApproved, isAdmin, createdAt, lastLoginAt, metadata }, ...]
```

Query parameters:

| Parameter | Type | Description |
|-----------|------|-------------|
| `limit` | number | Max subjects to return (default: 100, max: 1000) |
| `offset` | number | Skip this many subjects (for pagination) |
| `role` | string | Filter by role: `admin` or `none` |

```typescript @skip-check
// Get first 50 admins
const response = await fetch('/auth/subjects?role=admin&limit=50', {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
```

### Get Subject

`GET {prefix}/subject/:id` — Admin auth required

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
const { subject } = await response.json();
// subject: { sub, email, emailVerified, adminApproved, isAdmin, createdAt, lastLoginAt, metadata }
```

### Update Subject

`PATCH {prefix}/subject/:id` — Admin auth required

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    isAdmin: true,
    metadata: { department: 'Engineering' }
  })
});
const { subject } = await response.json();
```

Updatable fields: `isAdmin`, `adminApproved`, `metadata`, `authorizedActors`.

**Rules:**
- Cannot demote yourself (prevents lockout)
- Cannot demote or modify the [bootstrap admin](/docs/auth/#bootstrap-your-first-admin)

### Delete Subject

`DELETE {prefix}/subject/:id` — Admin auth required

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'DELETE',
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
// 200: { message: "Subject deleted" }
```

**Rules:**
- Cannot delete yourself
- Cannot delete the [bootstrap admin](/docs/auth/#bootstrap-your-first-admin)

### Invite Subjects

`POST {prefix}/invite` — Admin auth required

Pre-approves subjects by sending invite emails:

```typescript @skip-check
const response = await fetch('/auth/invite', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    emails: ['alice@example.com', 'bob@example.com']
  })
});
const { invited, errors } = await response.json();
// invited: ['alice@example.com', 'bob@example.com']
// errors: [] (or [{email, error}] for failures)
```

Creates subject records with `adminApproved: true`, `emailVerified: false` and sends invite emails. When subjects click the invite link ([Accept Invite](#accept-invite)), `emailVerified` is set to `true` and they gain immediate access.

**Behavior:**
- If email already exists and subject has `emailVerified: true` — skips (already active)
- If email already exists and subject has `emailVerified: false` — re-sends invite
- Invite links expire after 7 days (configurable via `inviteTtl`)

In [test mode](/docs/auth/#test-mode), append `?_test=true` to get invite links in the response instead of sending emails.

### Approve Subject

`GET {prefix}/approve/:id?token=...` — Admin auth (via token in URL)

Called from the admin notification email sent during [self-signup](/docs/auth/#self-signup-flow). Sets `adminApproved: true` and sends a "You've been approved" email to the subject.

Approval can also be done programmatically via [Update Subject](#update-subject):

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ adminApproved: true })
});
```

## Delegation

Delegation allows one authenticated subject to act on behalf of another (e.g., admin impersonation for support). The principal's permissions apply; the actor's identity is recorded for audit. See [JWT Claims: Delegation](/docs/auth/#jwt-claims) for the `act` claim format.

:::note Non-human actors (coming soon)
Currently, delegation requires both the actor and principal to be authenticated subjects who logged in via magic link. Service account and AI agent authentication (API keys, service tokens) is planned for a future release.
:::

**Flow:**

1. **Admin authorizes actor** — adds the actor's `sub` to the target subject's `authorizedActors` list via [Update Subject](#update-subject)
2. **Actor authenticates normally** — logs in via magic link, gets their own access token
3. **Actor requests delegated token** — calls [Request Delegated Token](#request-delegated-token) with their access token and the target subject's `sub`
4. **Auth verifies and issues token** — checks that the actor is in the target's `authorizedActors` list and is a valid subject. Token has `sub` = principal, `act.sub` = actor
5. **Actor makes calls** — guards check `sub` (principal's permissions), logs show `act.sub`

### Authorize an Actor

Use [Update Subject](#update-subject) to set the `authorizedActors` list (actor IDs must be valid subject IDs):

```typescript @skip-check
const response = await fetch(`/auth/subject/${targetSub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${adminAccessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    authorizedActors: [actorSub1, actorSub2]
  })
});
```

### Request Delegated Token

`POST {prefix}/delegated-token` — Bearer auth required

The actor uses their own access token and specifies who to act for:

```typescript @skip-check
const response = await fetch('/auth/delegated-token', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${actorAccessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    actFor: targetSub  // Subject ID to act on behalf of
  })
});
const { access_token } = await response.json();
// Token claims: { sub: targetSub, act: { sub: actorSub }, ... }
```

**Fails if:** (1) the actor's `sub` is not in the target's `authorizedActors` list, or (2) the actor's `sub` doesn't correspond to a valid subject.

### Using Delegated Tokens

Delegated tokens work like regular tokens. Your DO reads the JWT from the `Authorization: Bearer` header (see [How the JWT Reaches Your DO](/docs/auth/#how-the-jwt-reaches-your-do)) and checks `sub` for authorization. The `act` chain is available for audit logging:

```typescript @skip-check
// Guard checks sub (principal's permissions)
if (claims.sub !== ownerId) throw new Error('Forbidden');

// Audit logging includes actor if present
const actor = claims.act ? `${claims.act.sub} for ` : '';
console.log(`Document updated by ${actor}${claims.sub}`);
```

### Delegation in Tests

Use `testLoginWithMagicLink` with the `actAs` parameter:

```typescript @skip-check
import { testLoginWithMagicLink } from '@lumenize/auth';

// Authorize actorSub to act on behalf of targetSub
await authStub.authorizeActor(targetSub, actorSub);

// Get delegated token — actAs takes the actor's subject ID
const { accessToken } = await testLoginWithMagicLink(env, {
  email: 'alice@test.com',
  actAs: actorSub
});
// Token has sub = alice's sub, act.sub = actorSub
```

## RPC Methods

The same operations are available as methods on the Auth DO, for server-to-server calls or mesh-internal use:

```typescript @skip-check
const authStub = env.LUMENIZE_AUTH.getByName('default');

// List subjects
const subjects = await authStub.listSubjects({ limit: 50, role: 'admin' });

// Get subject
const subject = await authStub.getSubjectById(sub);

// Update subject
const updated = await authStub.updateSubject(sub, { isAdmin: true });

// Delete subject
await authStub.deleteSubject(sub);

// Delegation
await authStub.authorizeActor(targetSub, actorSub);
await authStub.revokeActor(targetSub, actorSub);
```

RPC methods require the caller to have appropriate permissions (passed via `originAuth` in the mesh context).

## Subject Record

```typescript @skip-check
interface Subject {
  sub: string;                   // Subject ID (UUID, per RFC 7519)
  email: string;                 // Email address (unique)
  createdAt: number;             // Unix timestamp
  lastLoginAt: number | null;    // Unix timestamp of last login

  // Status flags (both required for access)
  emailVerified: boolean;        // Subject clicked magic link or invite link
  adminApproved: boolean;        // Admin granted access (or subject is admin)

  // Role flag (implicitly satisfies adminApproved)
  isAdmin?: boolean;             // Full admin access

  // Delegation
  authorizedActors?: string[];   // Actor IDs authorized to act for this subject

  // Extensible metadata
  metadata?: Record<string, unknown>;
}
```

The `metadata` field is for application-specific data. For roles beyond the built-in `isAdmin`, store custom role data in `metadata` and check it in your guards.

## Security Rules

- **Self-modification prevention**: Subjects cannot demote or delete themselves (prevents lockout)
- **Bootstrap protection**: The subject matching `LUMENIZE_AUTH_BOOTSTRAP_EMAIL` cannot be demoted or deleted via API
- **Audit trail**: All subject management operations log who (`sub`, optionally `act.sub`), what changed, and when
