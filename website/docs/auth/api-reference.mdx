---
title: API Reference
description: Auth endpoints, environment variables, functions, subject management, and delegation
---

# API Reference

All endpoints use the configured `prefix` (default: `/auth`). Authenticated endpoints accept either an `Authorization: Bearer <access_token>` header or a `refresh_token` cookie — whichever is present. This means email links (which can only carry cookies) and JS-initiated requests (which use Bearer) both work without special cases.

## Endpoints

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| [`{prefix}/email-magic-link`](#request-magic-link) | POST | None | Request magic link (self-signup) |
| [`{prefix}/magic-link`](#validate-magic-link) | GET | None | Validate magic link → `emailVerified`, notify admins |
| [`{prefix}/accept-invite`](#accept-invite) | GET | None | Accept invite → `emailVerified` |
| [`{prefix}/refresh-token`](#refresh-token) | POST | Cookie | Exchange refresh token for access token |
| [`{prefix}/logout`](#logout) | POST | Cookie | Clear refresh token cookie |
| [`{prefix}/approve/:id`](#approve-subject) | GET | Admin | Approve subject → `adminApproved` (from admin notification email) |
| [`{prefix}/invite`](#invite-subjects) | POST | Admin | Invite subjects (bulk) → `adminApproved`, send invite emails |
| [`{prefix}/delegated-token`](#request-delegated-token) | POST | Auth | Request token to act on behalf of another subject |
| [`{prefix}/subjects`](#list-subjects) | GET | Admin | List subjects |
| [`{prefix}/subject/:id`](#get-subject) | GET | Admin | Get subject |
| [`{prefix}/subject/:id`](#update-subject) | PATCH | Admin | Update subject flags |
| [`{prefix}/subject/:id`](#delete-subject) | DELETE | Admin | Delete subject |
| [`{prefix}/subject/:id/actors`](#add-authorized-actor) | POST | Admin | Add an authorized actor for delegation |
| [`{prefix}/subject/:id/actors/:actorId`](#remove-authorized-actor) | DELETE | Admin | Remove an authorized actor |

**Cookie** = refresh token cookie. **Auth** = Bearer token or refresh token cookie. **Admin** = Auth + `isAdmin` required.

## Environment Variables

### Auth Config

The Auth DO and Worker hooks read configuration from environment variables. This eliminates the need for RPC config delivery and ensures config survives DO eviction.

| Variable | Type | Required | Default | Read By | Description |
|----------|------|----------|---------|---------|-------------|
| `LUMENIZE_AUTH_REDIRECT` | Variable | Yes | — | Auth DO | [302 `Location`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location) after magic link / invite — relative (`/app`) or absolute (`https://example.com/app`) |
| `LUMENIZE_AUTH_ISSUER` | Variable | No | `'https://lumenize.local'` | Auth DO, hooks | JWT `iss` claim |
| `LUMENIZE_AUTH_AUDIENCE` | Variable | No | `'https://lumenize.local'` | Auth DO, hooks | JWT `aud` claim |
| `LUMENIZE_AUTH_ACCESS_TOKEN_TTL` | Variable | No | `900` (15 min) | Auth DO | Access token expiration in seconds |
| `LUMENIZE_AUTH_REFRESH_TOKEN_TTL` | Variable | No | `2592000` (30 days) | Auth DO | Refresh token expiration in seconds |
| `LUMENIZE_AUTH_MAGIC_LINK_TTL` | Variable | No | `1800` (30 min) | Auth DO | One-time login token expiration in seconds |
| `LUMENIZE_AUTH_INVITE_TTL` | Variable | No | `604800` (7 days) | Auth DO | Invite token expiration in seconds (reusable until expiry) |
| `LUMENIZE_AUTH_PREFIX` | Variable | No | `'/auth'` | Auth DO, `createAuthRoutes` | URL prefix for all auth endpoints. `createAuthRoutes` uses it for route matching; the Auth DO uses it to compose links in emails |
| `LUMENIZE_AUTH_BOOTSTRAP_EMAIL` | Variable | No | — | Auth DO | Email idempotently promoted to admin on every login. Without this, no bootstrap admin is created — you'll need another mechanism to create the first admin |

### Bindings and Keys

| Variable | Type | Required | Read By | Description |
|----------|------|----------|---------|-------------|
| `JWT_PRIVATE_KEY_BLUE` | Secret | Yes¹ | Auth DO | Ed25519 private key (BLUE slot) |
| `JWT_PUBLIC_KEY_BLUE` | Secret | Yes¹ | Auth DO, hooks | Ed25519 public key (BLUE slot) |
| `JWT_PRIVATE_KEY_GREEN` | Secret | No² | Auth DO | Ed25519 private key (GREEN slot) |
| `JWT_PUBLIC_KEY_GREEN` | Secret | No² | Auth DO, hooks | Ed25519 public key (GREEN slot) |
| `PRIMARY_JWT_KEY` | Variable | Yes | Auth DO | Active signing slot: `"BLUE"` or `"GREEN"` |
| `TURNSTILE_SECRET_KEY` | Secret | Yes | `createAuthRoutes` | [Cloudflare Turnstile](https://developers.cloudflare.com/turnstile/) server-side secret |
| `LUMENIZE_AUTH_RATE_LIMITER` | Rate Limit binding | Yes | Hooks | [Rate Limiting binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/) keyed on `sub` |
| `LUMENIZE_AUTH_TEST_MODE` | Variable | No | Auth DO | Set to `"true"` to enable [test mode](/docs/auth/#test-mode) — **never deploy to production** |

¹ At least one key pair (BLUE or GREEN) is required. ² Second slot needed only during [key rotation](/docs/auth/#key-rotation).

**Naming convention**: `LUMENIZE_AUTH_*` for Lumenize-specific config, `JWT_*` for industry-standard key material (shared across packages), vendor prefix (e.g., `TURNSTILE_*`) for third-party services.

## Functions

### createAuthRoutes

Creates a request handler for all auth endpoints. Call once at module level. All auth configuration (redirect, TTLs, issuer, audience, prefix) is read from [environment variables](#auth-config) — only Worker-level routing options are passed here.

```typescript @skip-check-approved('conceptual')
const authRoutes = createAuthRoutes(env, options);
// Options object is optional — createAuthRoutes(env) uses all defaults
```

Options interface:

```typescript @check-example('packages/auth/src/types.ts')
interface AuthRoutesOptions {
  cors?: CorsOptions;
  authBindingName?: string;
  authInstanceName?: string;
}
```

For `CorsOptions`, see [CORS Support](/docs/utils/cors-support).

### createRouteDORequestAuthHooks

Creates hooks for [`routeDORequest`](/docs/utils/route-do-request) that verify JWTs and enforce [two-phase access control](/docs/auth/#access-flows). Reads `issuer`, `audience`, public keys, and rate limiter binding from [environment variables](#auth-config).

```typescript @skip-check-approved('conceptual')
const { onBeforeRequest, onBeforeConnect } = await createRouteDORequestAuthHooks(env, options);
// Options object is optional — createRouteDORequestAuthHooks(env) uses all defaults
```

Options interface:

```typescript @check-example('packages/auth/src/hooks.ts')
interface RouteDORequestAuthHooksOptions {
  rateLimiterBindingName?: string;
}
```

Both hooks:
- Validate JWT signature against provided public keys (tries each until one succeeds)
- Verify `emailVerified && adminApproved` (admins pass implicitly)
- Return 401 for invalid/missing tokens
- Return 403 for valid tokens that fail the access check
- Return 429 when the rate limit is exceeded
- Forward the verified JWT in the `Authorization: Bearer <jwt>` header (see [How the JWT Reaches Your DO](/docs/auth/#how-the-jwt-reaches-your-do))

## Authentication Endpoints

### Request Magic Link

`POST {prefix}/email-magic-link` — No auth required

Sends a magic link email to the given address. Creates the subject record if it doesn't exist. Requires a valid [Turnstile](https://developers.cloudflare.com/turnstile/) token in the body.

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    email: 'user@example.com',
    'cf-turnstile-response': turnstileToken  // from the Turnstile widget callback
  })
});
```

Response (200):

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
{
  message: "Check your email for the magic link",
  expires_in: 1800
}
```

Returns `403` if Turnstile verification fails.

In [test mode](/docs/auth/#test-mode), Turnstile validation is skipped entirely. Append `?_test=true` to get the magic link directly without email delivery. Response (200):

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
{
  message: "Magic link generated (test mode)"
}
```

### Validate Magic Link

`GET {prefix}/magic-link?one_time_token=...` — No auth required

Called when the subject clicks the magic link. Validates the one-time login token (single use — deleted after validation), sets `emailVerified: true`, creates a refresh token, and redirects. If the subject is not yet admin-approved, sends a notification email to all admins.

- **Valid token**: `302 → LUMENIZE_AUTH_REDIRECT` with `Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict`
- **Invalid/expired token**: `302 → LUMENIZE_AUTH_REDIRECT?error=invalid_token`

### Accept Invite

`GET {prefix}/accept-invite?invite_token=...` — No auth required

Called when an invited subject clicks the invite link. Validates the invite token (reusable until expiry), sets `emailVerified: true` (subject already has `adminApproved: true` from the invite), creates a refresh token, and redirects. The subject has immediate access since both flags are now true.

- **Valid token**: `302 → LUMENIZE_AUTH_REDIRECT` with `Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict`
- **Invalid/expired token**: `302 → LUMENIZE_AUTH_REDIRECT?error=invalid_token`

### Refresh Token

`POST {prefix}/refresh-token` — Auth required

Exchanges the refresh token cookie for a new access token. The access token JWT contains all [claims](/docs/auth/#jwt-claims) including status flags and role.

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/refresh-token', { method: 'POST' });
// 200: { access_token: "eyJ..." }
// 401: Refresh token expired, revoked, or missing
// 403: Subject has emailVerified but not adminApproved (pending approval)
```

### Logout

`POST {prefix}/logout` — Auth required

Revokes the refresh token and clears the cookie.

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
await fetch('/auth/logout', { method: 'POST' });
```

Response (200):

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
{
  message: "Logged out"
}
```

## Subject Management Endpoints

Admin-only. You don't need to check `emailVerified` or `adminApproved` in your DO guards — subjects without both flags are blocked at the Worker level before any DO code runs. Your guards only need to check application-level concerns like `isAdmin` or resource ownership.

### List Subjects

`GET {prefix}/subjects` — Admin required

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/subjects', {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
const { subjects } = await response.json();
// subjects: Subject[] (see Subject Record below)
```

Query parameters:

| Parameter | Type | Description |
|-----------|------|-------------|
| `limit` | number | Max subjects to return (default: 50, max: 200) |
| `offset` | number | Skip this many subjects (for pagination) |
| `role` | string | Filter by role: `admin` or `none` |

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
// Get first 50 admins
const response = await fetch('/auth/subjects?role=admin&limit=50', {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
```

### Get Subject

`GET {prefix}/subject/:id` — Admin required

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch(`/auth/subject/${sub}`, {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
const { subject } = await response.json();
// subject: Subject (see Subject Record below)
```

### Update Subject

`PATCH {prefix}/subject/:id` — Admin required

Updates `isAdmin` and/or `adminApproved` flags. Use [Add Authorized Actor](#add-authorized-actor) / [Remove Authorized Actor](#remove-authorized-actor) to manage delegation — `authorizedActors` in the PATCH body is rejected with `400`.

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    isAdmin: true
  })
});
const { subject } = await response.json();
```

**Rules:**
- Cannot modify yourself (prevents lockout)
- Cannot modify the [bootstrap admin](/docs/auth/#bootstrap-your-first-admin)

### Delete Subject

`DELETE {prefix}/subject/:id` — Admin required

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'DELETE',
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
```

Returns `204 No Content` on success.

**Rules:**
- Cannot delete yourself
- Cannot delete the [bootstrap admin](/docs/auth/#bootstrap-your-first-admin)

### Invite Subjects

`POST {prefix}/invite` — Admin required

Pre-approves subjects by sending invite emails:

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/invite', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    emails: ['alice@example.com', 'bob@example.com']
  })
});
const { invited, errors } = await response.json();
// invited: ['alice@example.com', 'bob@example.com']
// errors: [] (or [{email, error}] for failures)
```

Creates subject records with `adminApproved: true`, `emailVerified: false` and sends invite emails. When subjects click the invite link ([Accept Invite](#accept-invite)), `emailVerified` is set to `true` and they gain immediate access.

**Behavior:**
- If email already exists and subject has `emailVerified: true` — sets `adminApproved: true` and sends invite email
- If email already exists and subject has `emailVerified: false` — re-sends invite

In [test mode](/docs/auth/#test-mode), append `?_test=true` to get invite links in the response instead of sending emails.

### Approve Subject

`GET {prefix}/approve/:id` — Admin required

Linked from the admin notification email sent during [self-signup](/docs/auth/#self-signup-flow). Works from email links because the DO accepts the refresh token cookie (no Bearer header needed).

- **Authenticated admin**: Sets `adminApproved: true`, sends a "You've been approved" email to the subject, redirects to `LUMENIZE_AUTH_REDIRECT`.
- **Not authenticated**: Redirects to `LUMENIZE_AUTH_REDIRECT?error=login_required` so the app can prompt login and redirect back.

Equivalent to `PATCH /subject/:id` with `{ adminApproved: true }` — this endpoint exists as a GET so it works as an email link.

## Delegation

Delegation allows one authenticated subject to act on behalf of another (e.g., admin impersonation for support). The principal's permissions apply; the actor's identity is recorded for audit. See [JWT Claims: Delegation](/docs/auth/#jwt-claims) for the `act` claim format.

:::note Non-human actors (coming soon)
Currently, the actor must be an authenticated subject and the principal must be a valid subject (exists in the database). Service account and AI agent authentication (API keys, service tokens) is planned for a future release.
:::

**Admin delegation:** Admins can delegate as any subject — no setup needed. Authenticate, request a delegated token, done.

**Non-admin delegation flow:**

1. **Authorize actor** — an admin adds the actor via [Add Authorized Actor](#add-authorized-actor)
2. **Actor authenticates normally** — logs in via magic link or invite, gets their own access token
3. **Actor requests delegated token** — calls [Request Delegated Token](#request-delegated-token) with their access token and the principal's `sub`
4. **Auth verifies and issues token** — checks that the actor is authorized for the principal. Token has `sub` = principal, `act.sub` = actor
5. **Actor makes calls** — guards check `sub` (principal's permissions), logs show `act.sub`

### Add Authorized Actor

`POST {prefix}/subject/:id/actors` — Admin required

Adds an actor to a subject's authorized delegation list. The actor must be a valid subject ID. Idempotent — adding the same actor twice is a no-op.

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch(`/auth/subject/${targetSub}/actors`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${adminAccessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ actorSub: actorSubId })
});
const { subject } = await response.json();
// subject.authorizedActors now includes actorSubId
```

### Remove Authorized Actor

`DELETE {prefix}/subject/:id/actors/:actorId` — Admin required

Removes an actor from a subject's authorized delegation list. Idempotent — removing an actor that isn't authorized is a no-op.

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch(`/auth/subject/${targetSub}/actors/${actorSubId}`, {
  method: 'DELETE',
  headers: { 'Authorization': `Bearer ${adminAccessToken}` }
});
const { subject } = await response.json();
// subject.authorizedActors no longer includes actorSubId
```

### Request Delegated Token

`POST {prefix}/delegated-token` — Auth required

The actor uses their own access token and specifies who to act for:

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
const response = await fetch('/auth/delegated-token', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${actorAccessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    actFor: targetSub  // Subject ID to act on behalf of
  })
});
const { access_token } = await response.json();
// Token claims: { sub: targetSub, act: { sub: actorSub }, ... }
```

**Fails if:** the actor is not an admin and has not been [authorized](#add-authorized-actor) for the principal.

### Using Delegated Tokens

Delegated tokens work like regular tokens. Your DO reads the JWT from the `Authorization: Bearer` header (see [How the JWT Reaches Your DO](/docs/auth/#how-the-jwt-reaches-your-do)) and checks `sub` for authorization. The `act` chain is available for audit logging.

:::note Delegated token refresh
LumenizeClient auto-refreshes regular access tokens using the refresh token cookie. Delegated tokens require a separate refresh flow: the actor must first refresh their own access token, then call `/auth/delegated-token` again. LumenizeClient does not currently auto-refresh delegated tokens — your application is responsible for re-requesting them when they expire.
:::

```typescript @check-example('packages/auth/test/for-docs/endpoints.test.ts')
// Guard checks sub (principal's permissions)
if (claims.sub !== ownerId) throw new Error('Forbidden');

// Audit logging includes actor if present
const actor = claims.act ? `${claims.act.sub} for ` : '';
console.log(`Document updated by ${actor}${claims.sub}`);
```

### Delegation in Tests

Use `testLoginWithMagicLink` with the `actorAccessToken` parameter. The `browser` parameter provides a cookie jar for the multi-step login flow. First authorize the actor via the [Add Authorized Actor](#add-authorized-actor) endpoint, then login the principal with the actor's access token:

```typescript @check-example('packages/auth/test/for-docs/test-helpers.test.ts')
import { testLoginWithMagicLink } from '@lumenize/auth';
import { Browser } from '@lumenize/testing';

const adminBrowser = new Browser();
const { accessToken: adminToken } = await testLoginWithMagicLink(adminBrowser, 'admin@test.com', {
  subjectData: { isAdmin: true }
});

// Login the actor
const actorBrowser = new Browser();
const { accessToken: actorToken, sub: actorSub } = await testLoginWithMagicLink(
  actorBrowser, 'actor@test.com', { subjectData: { adminApproved: true } }
);

// Authorize actorSub to act on behalf of targetSub
await fetch(`/auth/subject/${targetSub}/actors`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ actorSub })
});

// Login alice with delegation — actor acts on her behalf
const aliceBrowser = new Browser();
const { accessToken, sub } = await testLoginWithMagicLink(aliceBrowser, 'alice@test.com', {
  subjectData: { adminApproved: true },
  actorAccessToken: actorToken  // actor's access token for delegation
});
// sub = alice's sub, parseJwtUnsafe(accessToken).payload.act.sub = actorSub
```

## Subject Record

| Field | Type | Updatable | Description |
|-------|------|-----------|-------------|
| `sub` | `string` | No | Subject ID (UUID, per RFC 7519) |
| `email` | `string` | No | Email address (unique) |
| `emailVerified` | `boolean` | No | Subject clicked magic link or invite link |
| `adminApproved` | `boolean` | Yes | Admin granted access (or subject is admin) |
| `isAdmin` | `boolean` | Yes | Full admin access (implicitly satisfies `adminApproved`) |
| `authorizedActors` | `string[]` | [POST/DELETE](#add-authorized-actor) | Actor IDs authorized to act for this subject ([Delegation](#delegation)) |
| `createdAt` | `number` | No | Unix timestamp |
| `lastLoginAt` | `number \| null` | No | Unix timestamp of last login |

## Security Rules

- **Self-modification prevention**: Admins cannot modify or delete themselves (prevents lockout). PATCH returns `403 "Cannot modify own admin status"`, DELETE returns `403 "Cannot delete yourself"`.
- **Bootstrap protection**: The subject matching `LUMENIZE_AUTH_BOOTSTRAP_EMAIL` cannot be modified or deleted via API. Returns `403 "Cannot modify bootstrap admin"`.
- **Actor validation**: [Add Authorized Actor](#add-authorized-actor) verifies the actor ID exists before creating the relationship. Returns `400 "Actor ID not found: {id}"` if invalid. Deleting a subject automatically removes all their delegation relationships (both as principal and actor) via cascading delete.
