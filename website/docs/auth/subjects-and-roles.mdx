---
title: Subjects and Roles
description: Role hierarchy, subject management APIs, and delegation in LumenizeAuth
---

# Subjects and Roles

LumenizeAuth provides a built-in role system and subject management APIs so you can start with working authorization out of the box.

## Access Control Model

LumenizeAuth uses two-phase access control: subjects need both **subject confirmation** and **admin approval** to access protected resources.

### Status Flags

| Flag | Purpose |
|------|---------|
| **`emailVerified`** | Subject has clicked the magic link (subject confirmation) |
| **`adminApproved`** | Admin has granted access (admin approval) |

Both flags must be `true` for a subject to access protected resources. This ensures:
- Subjects prove they control their email address
- Admins explicitly grant access (no automatic sign-up)

### Role Flag

| Flag | Purpose |
|------|---------|
| **`isAdmin`** | Full admin access. Can list, view, update, and delete subjects. Can promote/demote other admins and approve subjects. |

Admins implicitly satisfy `adminApproved`. Regular subjects must be explicitly approved.

### Flag Precedence

Admins implicitly satisfy `adminApproved`, so you only need `isAdmin: true`:

```typescript @skip-check
// Admin (has admin permissions, implicitly approved)
{ emailVerified: true, isAdmin: true }

// Regular subject with access (both flags required)
{ emailVerified: true, adminApproved: true }

// Subject signed up but not yet approved (blocked at Worker level)
{ emailVerified: true, adminApproved: false }

// Admin invited subject, subject hasn't clicked link yet (blocked)
{ emailVerified: false, adminApproved: true }
```

### Checking Flags in Guards

Note: You don't need to check `emailVerified` or `adminApproved` in guardsâ€”subjects without both are blocked at the Worker level before any DO code runs.

```typescript @skip-check
import { mesh } from '@lumenize/mesh';

class AdminDO {
  // Admin only
  @mesh({ guard: (auth) => auth.isAdmin })
  manageSubjects() { /* ... */ }

  // Owner or admin
  @mesh({
    guard: (auth, args, ctx) => {
      const resource = ctx.storage.kv.get('resource');
      return resource?.ownerId === auth.sub || auth.isAdmin;
    }
  })
  updateResource(data: ResourceUpdate) { /* ... */ }
}
```

### Custom Roles

For application-specific roles beyond the built-in admin roles, use the `metadata` field on subject records to store custom role data, then check those values in your guards.

## Subject Management APIs

Admins can manage subjects via HTTP endpoints or RPC methods.

### HTTP Endpoints

All endpoints use the configured `prefix` (default: `/auth`).

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `{prefix}/subjects` | GET | Admin | List all subjects |
| `{prefix}/subject/:id` | GET | Admin | Get subject by ID |
| `{prefix}/subject/:id` | PATCH | Admin | Update subject |
| `{prefix}/subject/:id` | DELETE | Admin | Delete subject |
| `{prefix}/invite` | POST | Admin | Invite subjects (sets `adminApproved`, sends emails) |
| `{prefix}/approve/:id` | GET | Admin | Approve subject (from admin notification email) |

### List Subjects

```typescript @skip-check
const response = await fetch('/auth/subjects', {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
const { subjects } = await response.json();
// subjects: [{ sub, email, emailVerified, adminApproved, isAdmin, createdAt, lastLoginAt, metadata }, ...]
```

Query parameters:

| Parameter | Type | Description |
|-----------|------|-------------|
| `limit` | number | Max subjects to return (default: 100, max: 1000) |
| `offset` | number | Skip this many subjects (for pagination) |
| `role` | string | Filter by role: `admin` or `none` |

```typescript @skip-check
// Get first 50 admins
const response = await fetch('/auth/subjects?role=admin&limit=50', {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
```

### Get Subject

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
const { subject } = await response.json();
// subject: { sub, email, isAdmin, createdAt, lastLoginAt, metadata }
```

### Update Subject

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    isAdmin: true,
    metadata: { department: 'Engineering' }
  })
});
const { subject } = await response.json();
```

**Update rules:**
- Admins can update `isAdmin` and `metadata`
- Cannot demote yourself (prevents lockout)
- Cannot demote the bootstrap admin

### Delete Subject

```typescript @skip-check
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'DELETE',
  headers: { 'Authorization': `Bearer ${accessToken}` }
});
// Returns: { message: "Subject deleted" }
```

**Delete rules:**
- Only admins can delete subjects
- Cannot delete yourself
- Cannot delete the bootstrap admin

### Invite Subjects

Admins can pre-approve subjects by inviting them via email:

```typescript @skip-check
const response = await fetch('/auth/invite', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    emails: ['alice@example.com', 'bob@example.com']
  })
});
const { invited, errors } = await response.json();
// invited: ['alice@example.com', 'bob@example.com']
// errors: [] (or [{email, error}] for failures)
```

This creates subject records with `adminApproved: true` and sends invite emails. When subjects click the invite link, their `emailVerified` is set to `true` and they gain immediate access.

**Invite behavior:**
- Creates new subjects with `adminApproved: true`, `emailVerified: false`
- If email already exists and subject has `emailVerified: true`, skips (already active)
- If email already exists and subject has `emailVerified: false`, re-sends invite
- Invite links expire after 7 days (configurable via `inviteTtl`)

### Approve Subject

When subjects self-sign-up, admins receive a notification email with an approval link. Clicking the link sets `adminApproved: true`:

```typescript @skip-check
// The approval link in the admin notification email:
// GET /auth/approve/:sub?token=...

// Or approve programmatically:
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ adminApproved: true })
});
```

When a subject is approved, they receive a "You've been approved" email and can now access the system.

### RPC Methods

If you prefer RPC over HTTP, the same operations are available as methods on the Auth DO:

```typescript @skip-check
const authStub = env.LUMENIZE_AUTH.getByName('default');

// List subjects
const subjects = await authStub.listSubjects({ limit: 50, role: 'admin' });

// Get subject
const subject = await authStub.getSubjectById(sub);

// Update subject
const updated = await authStub.updateSubject(sub, { isAdmin: true });

// Delete subject
await authStub.deleteSubject(sub);
```

RPC methods require the caller to have appropriate permissions (passed via `originAuth` in the mesh context).

## Delegation

Delegation allows something to act on behalf of a subject. The actor could be an AI agent, a service account, a scheduled job, or another human (e.g., admin impersonation). The principal's permissions apply; the actor's identity is recorded for audit.

### How It Works

1. **Subject authorizes actor** - Add the actor to the subject's `authorizedActors` list
2. **Actor requests delegated token** - Provides its ID and the subject's `sub`
3. **Auth issues token** - Token has `sub` = principal, `act.sub` = actor
4. **Actor makes calls** - Guards check `sub` (principal's permissions), logs show `act.sub`

### Authorize an Actor

Subjects can authorize actors to act on their behalf:

```typescript @skip-check
// Subject authorizes actor via PATCH
const response = await fetch(`/auth/subject/${sub}`, {
  method: 'PATCH',
  headers: {
    'Authorization': `Bearer ${subjectAccessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    authorizedActors: ['agent-123', 'agent-456']
  })
});
```

Or programmatically:

```typescript @skip-check
const authStub = env.LUMENIZE_AUTH.getByName('default');
await authStub.authorizeActor(sub, 'agent-123');
await authStub.revokeActor(sub, 'agent-123');
```

### Request a Delegated Token

Actors request tokens specifying who they're acting for:

```typescript @skip-check
const response = await fetch('/auth/delegated-token', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${agentAccessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    actFor: 'abc-456'  // Subject ID to act on behalf of
  })
});
const { access_token } = await response.json();
// Token claims: { sub: "abc-456", act: { sub: "agent-123" }, ... }
```

**Authorization check:** The request fails if `agent-123` is not in subject `abc-456`'s `authorizedActors` list.

### Using Delegated Tokens

Delegated tokens work like regular tokens. Guards check the `sub` claim (the principal):

```typescript @skip-check
@mesh({
  guard: (auth) => auth.sub === ownerId  // Checks principal, not actor
})
updateDocument(content: string) {
  // Actor can update if principal owns the document
}
```

For audit logging, check for the `act` claim:

```typescript @skip-check
@mesh({
  guard: (auth) => auth.sub === ownerId,
  onSuccess: (auth, args, result) => {
    const actor = auth.act ? `${auth.act.sub} for ` : '';
    console.log(`Document updated by ${actor}${auth.sub}`);
  }
})
updateDocument(content: string) { /* ... */ }
```

### Delegation in Tests

Use `testLoginWithMagicLink` with the `actAs` parameter:

```typescript @skip-check
import { testLoginWithMagicLink } from '@lumenize/auth';

// First, create and authorize the agent
await authStub.authorizeActor('abc-456', 'agent-123');

// Get delegated token
const { accessToken } = await testLoginWithMagicLink(env, {
  email: 'alice@test.com',
  actAs: 'agent-123'
});
// Token has sub="abc-456", act.sub="agent-123"
```

## Subject Record Structure

The full subject record stored in LumenizeAuth:

```typescript @skip-check
interface Subject {
  sub: string;                   // Subject ID (UUID, per RFC 7519)
  email: string;                 // Email address (unique)
  createdAt: number;             // Unix timestamp
  lastLoginAt: number | null;    // Unix timestamp of last login

  // Status flags (both required for access)
  emailVerified: boolean;        // Subject clicked magic link or invite link
  adminApproved: boolean;        // Admin granted access (or subject is admin)

  // Role flag (implicitly satisfies adminApproved)
  isAdmin?: boolean;             // Full admin access

  // Delegation
  authorizedActors?: string[];   // Actor IDs authorized to act for this subject

  // Extensible metadata
  metadata?: Record<string, unknown>;
}
```

The `metadata` field is for application-specific data like custom roles, preferences, or profile information.

## Security Considerations

### Bootstrap Protection

The email in `LUMENIZE_AUTH_BOOTSTRAP_EMAIL` receives special protection:
- Automatically gets `isAdmin: true` and `adminApproved: true` on first login
- Cannot have `isAdmin` revoked via API
- Cannot be deleted via API

This protection is identity-based (tied to the email address), not role-based. To change the bootstrap admin, update the environment variable and deploy.

### Self-Modification Prevention

Subjects cannot:
- Demote themselves (prevents accidental lockout)
- Delete themselves

### Audit Trail

All subject management operations are logged with:
- Who made the change (`sub` and optionally `act.sub`)
- What changed
- Timestamp

Access logs via the Auth DO's storage or your logging infrastructure.
