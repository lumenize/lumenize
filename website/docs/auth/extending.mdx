---
title: Extending Auth
description: Customize LumenizeAuth with custom user fields, routes, and behavior via subclassing
---

# Extending Auth

LumenizeAuth handles common authentication and authorization patterns. For application-specific needs, extend it via subclassing.

## When to Extend

Extend LumenizeAuth when you need:
- **Custom user fields** - Additional profile data, application-specific roles
- **Custom routes** - Additional auth endpoints
- **Custom behavior** - Override login hooks, validation, or token creation

For simple metadata storage, use the built-in `metadata` field instead of subclassing.

## Custom User Fields

Add type-safe custom fields that flow into JWT claims.

### Define Your User Type

```typescript @skip-check
import { LumenizeAuth, User } from '@lumenize/auth';

// Extend the base User type
interface MyUser extends User {
  organizationId: string;
  role: 'viewer' | 'editor' | 'owner';
  preferences: {
    theme: 'light' | 'dark';
    notifications: boolean;
  };
}

export class MyAuth extends LumenizeAuth<MyUser> {
  // Custom fields are now type-safe throughout
}
```

### Populate Custom Fields

Override `onUserCreate` to set default values for new users:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected onUserCreate(email: string): Partial<MyUser> {
    return {
      role: 'viewer',
      preferences: {
        theme: 'light',
        notifications: true
      }
    };
  }
}
```

### Include Fields in JWT Claims

By default, only `sub`, `isSuperAdmin`, and `isAdmin` appear in JWT claims. Override `getClaimsForUser` to include custom fields:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected getClaimsForUser(user: MyUser): Record<string, unknown> {
    return {
      ...super.getClaimsForUser(user),
      organizationId: user.organizationId,
      role: user.role
      // Don't include preferences - not needed for authorization
    };
  }
}
```

Now guards can check custom claims:

```typescript @skip-check
@mesh({
  guard: (auth) => auth.organizationId === targetOrgId && auth.role !== 'viewer'
})
editDocument() { /* ... */ }
```

### Validate Custom Fields on Update

Override `validateUserUpdate` to enforce constraints:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected validateUserUpdate(
    currentUser: MyUser,
    updates: Partial<MyUser>,
    updater: { sub: string; isAdmin?: boolean; isSuperAdmin?: boolean }
  ): void {
    // Call parent validation first
    super.validateUserUpdate(currentUser, updates, updater);

    // Only admins can change roles
    if (updates.role && !updater.isAdmin && !updater.isSuperAdmin) {
      throw new Error('Only admins can change user roles');
    }

    // Validate role value
    if (updates.role && !['viewer', 'editor', 'owner'].includes(updates.role)) {
      throw new Error('Invalid role');
    }

    // Organization changes require super-admin
    if (updates.organizationId && !updater.isSuperAdmin) {
      throw new Error('Only super-admins can change organization');
    }
  }
}
```

## Custom Routes

Add application-specific auth endpoints.

### Add New Endpoints

Override `getCustomRoutes` to register additional routes:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected getCustomRoutes(): Map<string, (request: Request) => Promise<Response>> {
    const routes = super.getCustomRoutes();

    // Add custom endpoint
    routes.set('POST /auth/update-preferences', async (request) => {
      const auth = this.requireAuth(request);
      const body = await request.json();

      const user = this.getUserById(auth.sub);
      if (!user) {
        return Response.json({ error: 'User not found' }, { status: 404 });
      }

      await this.updateUser(auth.sub, {
        preferences: { ...user.preferences, ...body }
      });

      return Response.json({ message: 'Preferences updated' });
    });

    // Add organization invite endpoint
    routes.set('POST /auth/invite', async (request) => {
      const auth = this.requireAuth(request);
      if (!auth.isAdmin && !auth.isSuperAdmin) {
        return Response.json({ error: 'Forbidden' }, { status: 403 });
      }

      const { email, role } = await request.json();
      await this.createInvite(email, role, auth.organizationId);

      return Response.json({ message: 'Invite sent' });
    });

    return routes;
  }

  private async createInvite(email: string, role: string, orgId: string) {
    // Implementation...
  }
}
```

### Override Existing Endpoints

Override specific route handlers to customize behavior:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected async handleMagicLinkRequest(request: Request): Promise<Response> {
    const { email } = await request.json();

    // Custom validation: only allow company emails
    if (!email.endsWith('@mycompany.com')) {
      return Response.json(
        { error: 'Only company email addresses allowed' },
        { status: 400 }
      );
    }

    // Delegate to parent implementation
    return super.handleMagicLinkRequest(request);
  }
}
```

## Custom Behavior

### Login Hooks

Execute code before or after login:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected async onBeforeLogin(user: MyUser): Promise<void> {
    // Check if user is suspended
    if (user.metadata?.suspended) {
      throw new Error('Account suspended');
    }

    // Check organization status
    const org = await this.getOrganization(user.organizationId);
    if (org?.status === 'inactive') {
      throw new Error('Organization inactive');
    }
  }

  protected async onAfterLogin(user: MyUser): Promise<void> {
    // Update login analytics
    await this.recordLoginEvent(user.id);

    // Sync with external system
    await this.syncUserToExternalSystem(user);
  }
}
```

### Custom Token Creation

Override token creation to add custom claims or logic:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected async createAccessToken(
    user: MyUser,
    actor?: { sub: string }
  ): Promise<string> {
    // Add time-based claims
    const claims = {
      ...this.getClaimsForUser(user),
      loginTime: Date.now()
    };

    // Add actor if delegated
    if (actor) {
      claims.act = actor;
    }

    return this.signToken(claims);
  }
}
```

### Custom Email Templates

Override the email service to customize magic link emails:

```typescript @skip-check
export class MyAuth extends LumenizeAuth<MyUser> {
  protected getEmailService(): EmailService {
    return {
      send: async (to: string, magicLinkUrl: string) => {
        // Use your email provider
        await sendEmail({
          to,
          subject: 'Sign in to MyApp',
          html: `
            <h1>Welcome to MyApp</h1>
            <p>Click below to sign in:</p>
            <a href="${magicLinkUrl}">Sign In</a>
            <p>This link expires in 30 minutes.</p>
          `
        });
      }
    };
  }
}
```

## Registering Your Custom Auth

Update your wrangler.jsonc to use your extended class:

```jsonc @skip-check
{
  "durable_objects": {
    "bindings": [
      {
        "name": "LUMENIZE_AUTH",
        "class_name": "MyAuth"
      }
    ]
  }
}
```

Export from your worker:

```typescript @skip-check
// src/index.ts
export { MyAuth } from './my-auth';
```

## TypeScript Integration

### Typed Claims in Guards

Create a typed guard helper:

```typescript @skip-check
import { mesh, OriginAuth } from '@lumenize/mesh';

// Define your claims type
interface MyClaims extends OriginAuth {
  organizationId: string;
  role: 'viewer' | 'editor' | 'owner';
}

// Typed guard helper
function guard<T extends unknown[]>(
  fn: (auth: MyClaims, args: T) => boolean
) {
  return fn as (auth: OriginAuth, args: T) => boolean;
}

// Use in decorators
class DocumentDO {
  @mesh({
    guard: guard((auth, [docId]) =>
      auth.role !== 'viewer' && auth.organizationId === this.orgId
    )
  })
  editDocument(docId: string) { /* ... */ }
}
```

### Typed RPC Methods

When calling your custom Auth DO via RPC:

```typescript @skip-check
import type { MyAuth } from './my-auth';

// Get typed stub
const authStub = env.LUMENIZE_AUTH.getByName('default') as DurableObjectStub<MyAuth>;

// Type-safe method calls
const user = await authStub.getUserById(userId);
// user is typed as MyUser
```

## Migration from Default Auth

If you started with default LumenizeAuth and want to add custom fields:

1. **Create your extended class** with new fields as optional
2. **Deploy** - existing users work, new fields are undefined
3. **Backfill** - update existing users with default values if needed
4. **Make fields required** - once all users have values

```typescript @skip-check
// Step 1: Optional new fields
interface MyUser extends User {
  organizationId?: string;  // Optional during migration
  role?: 'viewer' | 'editor' | 'owner';
}

// Step 3: Backfill script
async function backfillUsers(authStub: DurableObjectStub<MyAuth>) {
  const users = await authStub.listUsers({ limit: 1000 });
  for (const user of users) {
    if (!user.organizationId) {
      await authStub.updateUser(user.id, {
        organizationId: 'default-org',
        role: 'viewer'
      });
    }
  }
}
```
