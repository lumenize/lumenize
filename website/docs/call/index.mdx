---
title: '@lumenize/call'
description: DO-to-DO communication with continuations and synchronous API
---

# @lumenize/call

De✨light✨ful DO-to-DO communication using [continuations](/docs/core/continuations) and `blockConcurrencyWhile`.

**`@lumenize/call`** enables type-safe, non-blocking communication between Durable Objects with automatic result delivery via continuations.

## Features

- **Synchronous API** - `call()` returns immediately (void)
- **Type-safe** - Full TypeScript support with OCAN
- **Continuation-based** - Results delivered to handler methods
- **Error handling** - Errors delivered as `Error` objects to continuation
- **Proven performance** - Equivalent to raw Workers RPC (validated in production)
- **Simple** - No alarms, no queues, just `blockConcurrencyWhile`

## Installation

```bash @skip-check
npm install @lumenize/call
```

## Quick Start

```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
import '@lumenize/call';
import { LumenizeBase } from '@lumenize/lumenize-base';

class OriginDO extends LumenizeBase<Env> {
  async exampleBasicCall(userId: string) {
    const userData = this.ctn<RemoteDO>().getUserData(userId);
    const handlerCtn = this.ctn().handleUserDataResult(userData, userId);
    this.svc.call('REMOTE_DO', 'remote-1', userData, handlerCtn);
  }

  handleUserDataResult(result: any, userId: string) {
    if (result instanceof Error) {
      // ...
    } else {
      // ...
    }
  }
}
```

## How It Works

`@lumenize/call` uses Cloudflare's `blockConcurrencyWhile` to achieve a synchronous API:

```
Origin DO                  Remote DO
   │                          │
   ├─ call() ─────────────────>│ Workers RPC
   │  returns immediately      │
   │                          │
   │  blockConcurrencyWhile   ├─ execute operation
   │  (async work in bg)      ├─ return result
   │                          │
   ├─ handler executed        │
   │  with result             │
```

**Key points**:
- `call()` returns void immediately
- Remote operation executes via Workers RPC
- `blockConcurrencyWhile` ensures handler completes before new requests
- Both DOs maintain transactional consistency

## Basic Usage

### Making a Call

Three equivalent syntaxes for calling remote methods:

**Recommended: 3-line format**
```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
const userData = this.ctn<RemoteDO>().getUserData(userId);
const handlerCtn = this.ctn().handleUserDataResult(userData, userId);
this.svc.call('REMOTE_DO', 'remote-1', userData, handlerCtn);
```

**Alternative: Inline with variable reference**
```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
const userData = this.ctn<RemoteDO>().getUserData(userId);
this.svc.call(
  'REMOTE_DO',
  'remote-1',
  userData,
  this.ctn().handleUserDataResult(userData, userId)
);
```

**Alternative: Inline with $result marker**
```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
this.svc.call(
  'REMOTE_DO',
  'remote-1',
  this.ctn<RemoteDO>().getUserData(userId),
  // @ts-expect-error - $result is a special marker added by the continuation proxy
  this.ctn().handleUserDataResult(this.ctn().$result, userId)
);
```

### Receiving Calls

Remote DOs automatically receive and execute calls - no special setup required:

```typescript @skip-check
class RemoteDO extends LumenizeBase<Env> {
  getUserData(userId: string) {
    return {
      userId,
      name: 'Test User',
      // ... more fields
    };
  }
  
  add(a: number, b: number): number {
    return a + b;
  }
}
```

## Error Handling

Errors are automatically caught and delivered to your continuation as `Error` objects:

```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
await origin.exampleErrorHandling('Something went wrong!');
```

In your continuation handler:

```typescript @skip-check
handleUserDataResult(result: any, userId: string) {
  if (result instanceof Error) {
    console.error('Call failed:', result.message);
    return;
  }
  
  // Success - use result
  console.log('Got user data:', result);
}
```

### Types of Errors

- **Network errors**: Remote DO unreachable
- **Execution errors**: Remote method threw an error
- **Validation errors**: Invalid operation chain

## Advanced Patterns

### Nested Operations

OCAN supports nested operations that execute in a single round trip:

```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
await origin.exampleNestedOperations();
```

Implementation:

```typescript @skip-check
async exampleNestedOperations() {
  const op1 = this.ctn<RemoteDO>().add(1, 10);
  const op2 = this.ctn<RemoteDO>().add(100, 1000);
  const finalOp = this.ctn<RemoteDO>().add(op1, op2);
  const handlerCtn = this.ctn().handleMathResult(finalOp);
  this.svc.call('REMOTE_DO', 'remote-1', finalOp, handlerCtn);
}
```

Result: `1111` (from `(1+10) + (100+1000)`) in **one round trip**!

### Direct Storage Access

You can access storage directly in both remote operation and handler:

```typescript @check-example('packages/call/test/for-docs/basic-usage.test.ts')
await origin.exampleStorageAccessDirect('remote-storage');
```

Implementation:

```typescript @skip-check
const remoteStorageOp = this.ctn<Unprotected<RemoteDO>>()
  .ctx.storage.kv.get('__lmz_do_instance_name');

const handlerCtn = this.ctn()
  .ctx.storage.kv.put('__lmz_fetched_remote_name', remoteStorageOp);

this.svc.call('REMOTE_DO', remoteInstanceId, remoteStorageOp, handlerCtn);
```

### Context Preservation

Pass additional context to your handler by including extra parameters:

```typescript @skip-check
class SessionDO extends LumenizeBase<Env> {
  async processRequest(userId: string, requestId: string, data: any) {
    const timestamp = Date.now();
    
    this.svc.call(
      'PROCESSOR_DO',
      'global',
      this.ctn<ProcessorDO>().process(data),
      // Capture context in continuation (handler can accept multiple params!)
      this.ctn().handleProcessed(userId, requestId, timestamp, this.ctn().$result)
    );
  }
  
  handleProcessed(
    userId: string, 
    requestId: string, 
    timestamp: number, 
    result: any | Error
  ) {
    if (result instanceof Error) {
      console.error(`Request ${requestId} failed for user ${userId}`);
      return;
    }
    
    const duration = Date.now() - timestamp;
    console.log(`Request ${requestId} completed in ${duration}ms`);
    
    this.ctx.storage.kv.put(`user:${userId}:request:${requestId}`, {
      result,
      timestamp,
      duration
    });
  }
}
```

## Configuration

### Per-Call Options

```typescript @skip-check
this.svc.call(
  'REMOTE_DO',
  'instance-id',
  this.ctn<RemoteDO>().remoteMethod(),
  this.ctn().handleResult(this.ctn().$result),
  {
    timeout: 15000,  // Timeout in ms (default: 30000)
  }
);
```

**Note**: Timeout support is defined in the API but not yet fully implemented in V4. Timeouts will be added in a future release.

## Best Practices

### ✅ Do

- Always check for `Error` in continuation handlers
- Use the 3-line format for clarity (separate remote op, handler, call)
- Keep remote methods synchronous (no `async`)
- Preserve context by passing it as extra parameters to handlers
- Use nested operations to reduce round trips

### ❌ Don't

- Don't `await` the call (it returns `void`)
- Don't ignore errors in continuations
- Don't use `async` in remote methods (breaks consistency)
- Don't pass non-serializable data (functions, symbols, etc.)

## Comparison to Other Approaches

### vs Direct Workers RPC

```typescript @skip-check
// ❌ Direct RPC - blocks the origin DO until complete
const stub = env.REMOTE_DO.get(id);
const result = await stub.someMethod(arg); // Blocks entire DO!
this.ctx.storage.kv.put('result', result);

// ✅ Call - non-blocking with continuation
this.svc.call(
  'REMOTE_DO',
  'instance-id',
  this.ctn<RemoteDO>().someMethod(arg),
  this.ctn().handleResult(this.ctn().$result)
);
// Returns immediately! Handler called with result when ready
```

**Performance**: Equivalent to direct RPC (validated in production - see `experiments/call-vs-rpc`)

### vs Cloudflare Queues

- **Call**: Direct RPC with continuations, ~20ms latency
- **Queues**: Separate worker overhead, ~500-2000ms latency

### vs Alarms

- **Call**: For DO-to-DO communication
- **Alarms**: For time-based scheduling

## Troubleshooting

### "Cannot use call() from a DO that doesn't know its own binding name"

Make sure you've initialized your DO with `__lmzInit`:

```typescript @skip-check
class MyDO extends LumenizeBase<Env> {
  async fetch(request: Request) {
    // Initialize on first request
    await this.__lmzInit({ doBindingName: 'MY_DO' });
    
    // Now you can use call()
    this.svc.call(...);
  }
}
```

### "Invalid continuation"

Ensure you're using `this.ctn()` to create continuations:

```typescript @skip-check
// ❌ Wrong
this.svc.call('DO', 'id', { method: 'test' }, ...)

// ✅ Correct
this.svc.call('DO', 'id', this.ctn<RemoteDO>().test(), ...)
```

## Implementation Details

### Under the Hood

`@lumenize/call` uses a simple, proven pattern:

1. **Preprocess** operation chain for transmission (handle nested operations, continuations)
2. **Send** via Workers RPC to `__executeOperation` on remote DO
3. **Execute** operation chain on remote DO, return result
4. **Inject** result into handler continuation (replacing placeholder)
5. **Execute** handler locally

All within `blockConcurrencyWhile` to ensure:
- Caller returns immediately
- Handler completes before new requests
- Transactional consistency maintained

Performance validated to be equivalent to raw Workers RPC in production testing.

## API Reference

See the [TypeDoc API Reference](/docs/call/api) for complete type information.

## Next Steps

- **[Continuations](/docs/core/continuations)** - Understanding the continuation pattern
- **[OCAN](/docs/core/ocan)** - Operation chaining for type-safe remote calls
- **[Proxy Fetch](/docs/proxy-fetch/proxy-fetch-worker)** - External API calls with continuations
