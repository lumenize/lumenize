---
title: "@lumenize/structured-clone"
description: "Zero-dependency serialization for Cloudflare Workers with full type support"
---

# @lumenize/structured-clone

A zero-dependency fork of `@ungap/structured-clone` with Lumenize-specific enhancements for Cloudflare Workers. Provides full-fidelity serialization for complex JavaScript types including Errors, Web API objects, and special numbers.

## Why This Package?

When building RPC systems or storing data in Cloudflare Workers, you need to serialize complex JavaScript objects. JSON alone isn't enough:

- **Lost Types**: JSON loses `Date`, `Map`, `Set`, `Error` objects
- **No Circulars**: JSON can't handle circular references
- **No Special Numbers**: JSON converts `NaN` and `Infinity` to `null`
- **No Web API Objects**: JSON can't serialize `Request`, `Response`, `Headers`, `URL`

This package solves all of these problems while maintaining a single, efficient object traversal.

## Installation

```bash @skip-check
npm install @lumenize/structured-clone
```

## Basic Usage

### Simple Objects and Arrays

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
import { stringify, parse } from '@lumenize/structured-clone';

const user = {
  name: 'Alice',
  age: 30,
  active: true
};

const serialized = await stringify(user);
const restored = await parse(serialized);

expect(restored.name).toBe('Alice');
// ...
```

### Arrays and Nested Structures

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
const data = {
  users: ['Alice', 'Bob', 'Charlie'],
  metadata: {
    count: 3,
    timestamp: Date.now()
  }
};

const restored = await parse(await stringify(data));

expect(restored.users).toEqual(['Alice', 'Bob', 'Charlie']);
// ...
```

## Complex Types

### Dates, Maps, and Sets

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
const event = {
  title: 'Meeting',
  scheduledFor: new Date('2025-06-15T10:00:00Z')
};

const restored = await parse(await stringify(event));

expect(restored.scheduledFor).toBeInstanceOf(Date);
// ...
```

### Maps and Sets

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
const cache = new Map([
  ['key1', 'value1'],
  ['key2', 'value2']
]);
const tags = new Set(['javascript', 'typescript', 'cloudflare']);

const data = { cache, tags };
const restored = await parse(await stringify(data));

expect(restored.cache).toBeInstanceOf(Map);
expect(restored.cache.get('key1')).toBe('value1');
// ...
```

## Special Numbers

Unlike JSON, `@lumenize/structured-clone` preserves `NaN`, `Infinity`, and `-Infinity`:

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
const stats = {
  average: NaN,
  maximum: Infinity,
  minimum: -Infinity
};

const restored = await parse(await stringify(stats));

expect(restored.average).toBeNaN();
expect(restored.maximum).toBe(Infinity);
// ...
```

## Circular References

Handles circular references automatically:

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
const node: any = {
  id: 1,
  data: 'root'
};
node.self = node;

const restored: any = await parse(await stringify(node));

expect(restored.id).toBe(1);
expect(restored.self).toBe(restored);
```

## Error Handling

### Basic Error Serialization

Full-fidelity Error serialization with stack traces:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const error = new Error('Database connection failed');

const restored = await parse(await stringify(error));

expect(restored).toBeInstanceOf(Error);
expect(restored.message).toBe('Database connection failed');
expect(restored.stack).toBeDefined();
```

### Error Subclasses

Preserves Error subclass types:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const error = new TypeError('Invalid user ID');

const restored = await parse(await stringify(error));

expect(restored).toBeInstanceOf(TypeError);
// ...
```

### Error Chains

Supports Error chaining with `cause`:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const networkError = new Error('Connection timeout');
const appError = new Error('Failed to fetch user data', { 
  cause: networkError 
});

const restored = await parse(await stringify(appError));

expect(restored.message).toBe('Failed to fetch user data');
expect(restored.cause).toBeInstanceOf(Error);
expect(restored.cause.message).toBe('Connection timeout');
```

### Custom Error Properties

Custom properties on Errors are preserved:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const apiError: any = new Error('API request failed');
apiError.statusCode = 500;
apiError.endpoint = '/api/users';

const restored: any = await parse(await stringify(apiError));

expect(restored.message).toBe('API request failed');
expect(restored.statusCode).toBe(500);
// ...
```

### Errors in Data Structures

Errors work seamlessly in response objects:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const response = {
  success: false,
  error: new Error('Validation failed'),
  timestamp: Date.now()
};

const restored = await parse(await stringify(response));

expect(restored.success).toBe(false);
expect(restored.error).toBeInstanceOf(Error);
// ...
```

## Web API Objects

Essential for Cloudflare Workers: serializes `Request`, `Response`, `Headers`, and `URL` objects.

### Request Serialization

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const request = new Request('https://api.example.com/users', {
  method: 'GET',
  headers: { 'Authorization': 'Bearer token123' }
});

const restored = await parse(await stringify(request));

expect(restored).toBeInstanceOf(Request);
expect(restored.url).toBe('https://api.example.com/users');
// ...
```

### Request Bodies

Request bodies are fully preserved:

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const userData = JSON.stringify({ name: 'Alice', email: 'alice@example.com' });
const request = new Request('https://api.example.com/users', {
  method: 'POST',
  body: userData,
  headers: { 'content-type': 'application/json' }
});

const restored = await parse(await stringify(request));

expect(restored.method).toBe('POST');
const bodyText = await restored.text();
// ...
```

### Response Serialization

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const response = new Response('User created successfully', {
  status: 201,
  headers: { 'content-type': 'text/plain' }
});

const restored = await parse(await stringify(response));

expect(restored).toBeInstanceOf(Response);
expect(restored.status).toBe(201);
// ...
```

### Headers and URL

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const headers = new Headers({
  'content-type': 'application/json',
  'cache-control': 'max-age=3600'
});

const restored = await parse(await stringify(headers));

expect(restored).toBeInstanceOf(Headers);
// ...
```

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const url = new URL('https://api.example.com/search?q=test&limit=10');

const restored = await parse(await stringify(url));

expect(restored).toBeInstanceOf(URL);
expect(restored.hostname).toBe('api.example.com');
// ...
```

### Cloudflare Workers Use Case

Perfect for serializing Worker request/response pairs:

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const workerData = {
  incomingRequest: new Request('https://worker.example.com/api', {
    method: 'POST',
    body: 'request data'
  }),
  outgoingResponse: new Response('response data', {
    status: 200
  }),
  timestamp: Date.now()
};

const restored = await parse(await stringify(workerData));

expect(restored.incomingRequest).toBeInstanceOf(Request);
// ...
```

## API Reference

### `stringify(value, baseOperationChain?): Promise<string>`

Converts a value to a JSON string with full type support.

- **Parameters**:
  - `value`: Any serializable value
  - `baseOperationChain` (optional): Base operation chain for RPC function markers
- **Returns**: Promise resolving to JSON string
- **Throws**: `TypeError` if value contains symbols

### `parse(value): Promise<any>`

Restores a value from a JSON string created by `stringify()`.

- **Parameters**:
  - `value`: JSON string to parse
- **Returns**: Promise resolving to restored value with all types

### `preprocess(value, baseOperationChain?): Promise<any>`

Preprocesses a value for serialization without converting to string. Useful when you need control between processing and stringification.

- **Parameters**:
  - `value`: Any serializable value
  - `baseOperationChain` (optional): Base operation chain for RPC function markers
- **Returns**: Promise resolving to processed object (not stringified)
- **Throws**: `TypeError` if value contains symbols

### `postprocess(value): Promise<any>`

Restores a value from a preprocessed object. Inverse of `preprocess()`.

- **Parameters**:
  - `value`: Preprocessed object
- **Returns**: Promise resolving to restored value with all types

## Supported Types

- **Primitives**: `string`, `number`, `boolean`, `null`, `undefined`, `bigint`
- **Special Numbers**: `NaN`, `Infinity`, `-Infinity`
- **Native Types**: `Date`, `RegExp`, `Map`, `Set`, `Array`, `Object`
- **Typed Arrays**: `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`, `Int32Array`, `Uint32Array`, `Float32Array`, `Float64Array`, `BigInt64Array`, `BigUint64Array`
- **Binary Types**: `ArrayBuffer`, `DataView`
- **Errors**: `Error`, `TypeError`, `RangeError`, `ReferenceError`, `SyntaxError`, `URIError`, `EvalError` (with stack traces, cause chains, and custom properties)
- **Web API**: `Request`, `Response`, `Headers`, `URL`
- **Circular References**: Automatically handled
- **Wrapper Types**: `Boolean`, `Number`, `String`, `BigInt` objects

## Limitations

- **Symbols**: Cannot be serialized (throws `TypeError`)
- **Functions**: Converted to markers (for RPC integration)
- **Signed Zero**: `-0` becomes `+0` (JSON limitation)
- **Error Subclass Types**: Some edge cases may convert to base `Error`
- **Request/Response Bodies**: Consumed during serialization (streams become strings)

## Differences from @ungap/structured-clone

This package is a fork of `@ungap/structured-clone` with these enhancements:

1. **Zero runtime dependencies**: No external packages
2. **Function markers**: Functions converted to RPC-compatible markers
3. **Special number support**: NaN, Infinity, -Infinity preserved
4. **Full Error fidelity**: Stack traces, cause chains, custom properties
5. **Web API objects**: Request, Response, Headers, URL serialization
6. **Strict symbol handling**: Always throws on symbols
7. **Async API**: All methods async for Request/Response body reading
8. **Single object walk**: All enhancements integrated into one traversal

## License

ISC License (from @ungap/structured-clone)

Lumenize extensions © 2025

## Attribution

Forked from [`@ungap/structured-clone`](https://github.com/ungap/structured-clone) by Andrea Giammarchi.

See [ATTRIBUTIONS.md](https://github.com/lumenize/lumenize/blob/main/ATTRIBUTIONS.md) for full attribution details.

