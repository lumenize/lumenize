---
title: "@lumenize/structured-clone"
description: "Zero-dependency serialization for Cloudflare Workers with full type support"
---

# @lumenize/structured-clone

A zero-dependency fork of `@ungap/structured-clone` with Lumenize-specific enhancements for Cloudflare Workers. Provides full-fidelity serialization for complex JavaScript types including Errors, Web API objects, and special numbers.

## Why This Package?

When building RPC systems or storing data in Cloudflare Workers, you need to serialize complex JavaScript objects. JSON alone isn't enough:

- **Lost Types**: JSON loses `Date`, `Map`, `Set`, `Error` objects
- **No Circulars**: JSON can't handle circular references
- **No Special Numbers**: JSON converts `NaN` and `Infinity` to `null`
- **No Web API Objects**: JSON can't serialize `Request`, `Response`, `Headers`, `URL`

This package solves all of these problems while maintaining a single, efficient object traversal.

## Installation

```bash @skip-check
npm install @lumenize/structured-clone
```

## Basic Usage

The core API is simple: `stringify()` to serialize, `parse()` to deserialize.

```typescript @check-example packages/structured-clone/test/for-docs/basic-usage.test.ts
import { stringify, parse } from '@lumenize/structured-clone';

const user = {
  name: 'Alice',
  age: 30,
  active: true
};

const serialized = await stringify(user);
const restored = await parse(serialized);

expect(restored.name).toBe('Alice');
// ...
```

This works with complex nested structures, arrays, and all types shown in the comparison table below.

## Key Features with Examples

### Error Chains with `cause`

Error chaining is fully preserved, including nested causes:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const networkError = new Error('Connection timeout');
const appError = new Error('Failed to fetch user data', { 
  cause: networkError 
});

const restored = await parse(await stringify(appError));

expect(restored.message).toBe('Failed to fetch user data');
expect(restored.cause).toBeInstanceOf(Error);
expect(restored.cause.message).toBe('Connection timeout');
```

### Custom Error Properties

Add arbitrary properties to Errors—they're all preserved:

```typescript @check-example packages/structured-clone/test/for-docs/errors.test.ts
const apiError: any = new Error('API request failed');
apiError.statusCode = 500;
apiError.endpoint = '/api/users';

const restored: any = await parse(await stringify(apiError));

expect(restored.message).toBe('API request failed');
expect(restored.statusCode).toBe(500);
// ...
```

### Cloudflare Workers Use Case

Perfect for serializing Worker request/response pairs:

```typescript @check-example packages/structured-clone/test/for-docs/web-api.test.ts
const workerData = {
  incomingRequest: new Request('https://worker.example.com/api', {
    method: 'POST',
    body: 'request data'
  }),
  outgoingResponse: new Response('response data', {
    status: 200
  }),
  timestamp: Date.now()
};

const restored = await parse(await stringify(workerData));

expect(restored.incomingRequest).toBeInstanceOf(Request);
// ...
```

**Note:** Request/Response bodies are consumed during serialization (streams become strings).

## API Reference

### `stringify(value, baseOperationChain?): Promise<string>`

Converts a value to a JSON string with full type support.

- **Parameters**:
  - `value`: Any serializable value
  - `baseOperationChain` (optional): Base operation chain for RPC function markers
- **Returns**: Promise resolving to JSON string
- **Throws**: `TypeError` if value contains symbols

### `parse(value): Promise<any>`

Restores a value from a JSON string created by `stringify()`.

- **Parameters**:
  - `value`: JSON string to parse
- **Returns**: Promise resolving to restored value with all types

### `preprocess(value, baseOperationChain?): Promise<any>`

Preprocesses a value for serialization without converting to string. Useful when you need control between processing and stringification.

- **Parameters**:
  - `value`: Any serializable value
  - `baseOperationChain` (optional): Base operation chain for RPC function markers
- **Returns**: Promise resolving to processed object (not stringified)
- **Throws**: `TypeError` if value contains symbols

### `postprocess(value): Promise<any>`

Restores a value from a preprocessed object. Inverse of `preprocess()`.

- **Parameters**:
  - `value`: Preprocessed object
- **Returns**: Promise resolving to restored value with all types

## Supported Types

`@lumenize/structured-clone` powers both `@lumenize/rpc` and can be used directly for storage serialization. Here's how it compares to other Cloudflare serialization systems:

import TypeSupportTable from '@site/docs/_partials/_type-support-table.mdx';

<TypeSupportTable />

### Key Highlights

- **Full Type Support**: All primitives, special numbers (`NaN`, `Infinity`, `-Infinity`), built-in types (`Date`, `RegExp`, `Map`, `Set`), typed arrays, and Web API objects
- **Error Fidelity**: Preserves stack traces, `cause` chains, custom properties, and subclass types
- **Circular References**: Automatically handled without errors
- **Workers-Optimized**: Native support for `Request`, `Response`, `Headers`, `URL`

### What Lumenize Adds

Compared to Workers RPC and DO Storage:
- **Workers RPC** [plans to remove cycles/aliases](https://github.com/cloudflare/capnweb/tree/main#cloudflare-workers-rpc-interoperability) — Lumenize keeps them
- **DO Storage** can't serialize Web API objects — Lumenize can
- **Cap'n Web** lacks Maps, Sets, special numbers — Lumenize has full support

## Limitations

- **Symbols**: Cannot be serialized (throws `TypeError`)
- **Functions**: Converted to markers (for RPC integration only)
- **Signed Zero**: `-0` becomes `+0` (JSON limitation)
- **Streams**: `ReadableStream`/`WritableStream` not supported (use WebSockets for streaming)

## Differences from @ungap/structured-clone

This package is a fork of `@ungap/structured-clone` with these enhancements:

1. **Zero runtime dependencies**: No external packages
2. **Function markers**: Functions converted to RPC-compatible markers
3. **Special number support**: NaN, Infinity, -Infinity preserved
4. **Full Error fidelity**: Stack traces, cause chains, custom properties
5. **Web API objects**: Request, Response, Headers, URL serialization
6. **Strict symbol handling**: Always throws on symbols
7. **Async API**: All methods async for Request/Response body reading
8. **Single object walk**: All enhancements integrated into one traversal

## License

ISC License (from @ungap/structured-clone)

Lumenize extensions © 2025

## Attribution

Forked from [`@ungap/structured-clone`](https://github.com/ungap/structured-clone) by Andrea Giammarchi.

See [ATTRIBUTIONS.md](https://github.com/lumenize/lumenize/blob/main/ATTRIBUTIONS.md) for full attribution details.

