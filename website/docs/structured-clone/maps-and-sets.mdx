---
description: "Understanding Map and Set serialization behavior with primitive and object keys"
---

# Map and Set Behavior

When serializing `Map` and `Set` objects with `@lumenize/structured-clone`, it's important to understand how keys and values behave after deserialization, especially when using objects as Map keys or Set values.

## TL;DR

- ‚úÖ **Primitive keys/values** (strings, numbers, booleans) work as expected
- ‚ö†Ô∏è **Object keys/values** behavior depends on **serialization boundaries**:
  - ‚úÖ **Identity preserved** within a single `stringify()`/`parse()` or RPC call
  - ‚ùå **Identity lost** across separate storage operations or multiple calls
- üîç Best practice: **return objects and their Map/Set together** in same call/serialization

## Primitive Keys - Work as Expected

### Strings, Numbers, Booleans

Primitive values are compared by **value**, so they work exactly as you'd expect:

```typescript
// Sender side
const map = new Map([
  ["user123", { name: "Alice" }],
  [42, { count: 100 }],
  [true, { active: true }]
]);

const serialized = await stringify(map);

// Receiver side
const restored = await parse(serialized);

console.log(restored.get("user123"));  // ‚úÖ { name: "Alice" }
console.log(restored.get(42));         // ‚úÖ { count: 100 }
console.log(restored.get(true));       // ‚úÖ { active: true }
```

**Why it works:** JavaScript compares primitives by value, so `"user123" === "user123"` is always true.

## Object Keys - Reconstructed but Different Identity

### The Challenge

When you use an object as a Map key or Set value, JavaScript uses **reference equality** (`===`), not structural equality:

```typescript
// Native JavaScript behavior
const key1 = { userId: 123 };
const key2 = { userId: 123 };

console.log(key1 === key2);  // ‚ùå false - different objects!

const map = new Map();
map.set(key1, "value");
console.log(map.get(key1));  // ‚úÖ "value"
console.log(map.get(key2));  // ‚ùå undefined - different reference!
```

### After Serialization

The structured-clone package **preserves this exact behavior**. Object keys are fully reconstructed with all their properties, but they're **new object instances**:

```typescript
// Sender side
const keyObj = { userId: 123, role: "admin" };
const map = new Map([[keyObj, "user data"]]);

const serialized = await stringify(map);

// Receiver side
const restored = await parse(serialized);

// The key is fully reconstructed...
const keys = Array.from(restored.keys());
console.log(keys[0]);  // { userId: 123, role: "admin" } ‚úÖ

// All properties are preserved...
console.log(keys[0].userId);  // 123 ‚úÖ
console.log(keys[0].role);    // "admin" ‚úÖ

// BUT it's a new object with different identity...
const newKey = { userId: 123, role: "admin" };
console.log(restored.get(newKey));  // ‚ùå undefined - different reference!

// You must use the reconstructed key object:
console.log(restored.get(keys[0]));  // ‚úÖ "user data"
```

## Finding Object Keys After Deserialization

Since you can't construct a new object to look up values, you need to **search through the reconstructed keys** to find the one you want:

### Pattern 1: Search by Property Match

```typescript
// Sender side
const user1Key = { userId: 123, type: "user" };
const user2Key = { userId: 456, type: "user" };
const adminKey = { userId: 789, type: "admin" };

const map = new Map([
  [user1Key, { name: "Alice", email: "alice@example.com" }],
  [user2Key, { name: "Bob", email: "bob@example.com" }],
  [adminKey, { name: "Admin", email: "admin@example.com" }]
]);

const serialized = await stringify(map);

// Receiver side
const restored = await parse(serialized);

// Find the key for userId 456
const targetKey = Array.from(restored.keys()).find(
  key => key.userId === 456
);

if (targetKey) {
  console.log(restored.get(targetKey));
  // ‚úÖ { name: "Bob", email: "bob@example.com" }
}
```

### Pattern 2: Helper Function for Deep Equality

For more complex key matching:

```typescript
// Helper to check if two objects match structurally
function keysMatch(key: any, template: any): boolean {
  if (typeof key !== 'object' || typeof template !== 'object') {
    return key === template;
  }
  
  // Check all template properties exist and match in key
  for (const prop in template) {
    if (key[prop] !== template[prop]) {
      return false;
    }
  }
  return true;
}

// Receiver side
const restored = await parse(serialized);

// Find key matching a template
const targetKey = Array.from(restored.keys()).find(
  key => keysMatch(key, { userId: 456, type: "user" })
);

if (targetKey) {
  const value = restored.get(targetKey);
  console.log(value);  // ‚úÖ { name: "Bob", email: "bob@example.com" }
}
```

### Pattern 3: Store Keys Separately

The most reliable pattern is to **explicitly share the key objects** in your data structure:

```typescript
// Sender side
const keyObj = { userId: 123, role: "admin" };

const data = {
  map: new Map([[keyObj, "user data"]]),
  keyToLookup: keyObj  // ‚úÖ Share the key explicitly!
};

const serialized = await stringify(data);

// Receiver side
const restored = await parse(serialized);

// Now you can access the map using the shared key!
console.log(restored.map.get(restored.keyToLookup));
// ‚úÖ "user data"

// The key references are preserved:
console.log(restored.keyToLookup === Array.from(restored.map.keys())[0]);
// ‚úÖ true - same reconstructed object!
```

## Set Behavior with Objects

The same principles apply to `Set`:

### Primitive Values - Work as Expected

```typescript
const set = new Set(["apple", "banana", 123, true]);
const restored = await parse(await stringify(set));

console.log(restored.has("apple"));  // ‚úÖ true
console.log(restored.has(123));      // ‚úÖ true
```

### Object Values - Search Required

```typescript
// Sender side
const obj1 = { id: 1, name: "Alice" };
const obj2 = { id: 2, name: "Bob" };
const set = new Set([obj1, obj2]);

const serialized = await stringify(set);

// Receiver side
const restored = await parse(serialized);

// Can't check with new object
console.log(restored.has({ id: 1, name: "Alice" }));  // ‚ùå false

// Must search through values
const hasAlice = Array.from(restored).some(
  item => item.id === 1 && item.name === "Alice"
);
console.log(hasAlice);  // ‚úÖ true

// Or store references separately
const data = {
  set: new Set([obj1, obj2]),
  aliceRef: obj1
};

const restoredData = await parse(await stringify(data));
console.log(restoredData.set.has(restoredData.aliceRef));  // ‚úÖ true
```

## Aliases and Identity Preservation

One powerful feature: **if the same object appears multiple times** in your data structure, it's reconstructed as the **same object reference**:

### Map with Shared Keys

```typescript
// Sender side
const sharedKey = { category: "users" };

const map1 = new Map([[sharedKey, "data1"]]);
const map2 = new Map([[sharedKey, "data2"]]);

const data = { map1, map2, theKey: sharedKey };

const serialized = await stringify(data);

// Receiver side
const restored = await parse(serialized);

// All references point to the same reconstructed object!
console.log(restored.map1.get(restored.theKey));  // ‚úÖ "data1"
console.log(restored.map2.get(restored.theKey));  // ‚úÖ "data2"

// Verify they're the same object
const key1 = Array.from(restored.map1.keys())[0];
const key2 = Array.from(restored.map2.keys())[0];
console.log(key1 === key2);           // ‚úÖ true
console.log(key1 === restored.theKey); // ‚úÖ true
```

### Set with Shared Values

```typescript
// Sender side
const sharedObj = { config: { theme: "dark" } };

const set1 = new Set([sharedObj]);
const set2 = new Set([sharedObj]);

const data = { set1, set2, theObj: sharedObj };

const serialized = await stringify(data);

// Receiver side
const restored = await parse(serialized);

// All references are the same reconstructed object
console.log(restored.set1.has(restored.theObj));  // ‚úÖ true
console.log(restored.set2.has(restored.theObj));  // ‚úÖ true

// Modifying via one reference affects all
const obj = Array.from(restored.set1)[0];
obj.config.theme = "light";
console.log(restored.theObj.config.theme);  // "light"
```

## RPC and Serialization Boundaries

The same identity preservation behavior applies when using **`@lumenize/rpc`**. Within a single RPC call, object identity is preserved:

```typescript
// Server-side DO
export class MyDO extends LumenizeBase {
  getData() {
    const keyObj = { userId: 123 };
    const map = new Map([[keyObj, "user data"]]);
    
    // Return both the map and the key in the same response
    return {
      map,
      key: keyObj  // ‚úÖ Identity preserved!
    };
  }
}

// Client-side
const stub = env.MY_DO.get(id);
const data = await stub.getData();  // Single RPC call

// The key reference works because it was returned together!
console.log(data.map.get(data.key));  // ‚úÖ "user data"
console.log(data.key === Array.from(data.map.keys())[0]);  // ‚úÖ true
```

### Understanding Serialization Boundaries

**Identity preserved (single boundary):**
- ‚úÖ Single RPC method call: `await stub.method()` returns object with map + key
- ‚úÖ Single `stringify()`/`parse()`: One serialization cycle
- ‚úÖ Native `structuredClone()`: One clone operation

**Identity lost (separate boundaries):**
- ‚ùå Separate RPC calls: Call 1 returns map, Call 2 returns key
- ‚ùå DO Storage: `put(map)` then later `get()` and use original key
- ‚ùå Separate `stringify()` calls: Serialize map and key independently

```typescript
// ‚ùå Won't work: Separate RPC calls
const map = await stub.getMap();      // Call 1
const key = await stub.getKey();      // Call 2
console.log(map.get(key));            // ‚ùå undefined - different boundaries!

// ‚úÖ Will work: Single RPC call
const data = await stub.getMapAndKey();  // One call returns both
console.log(data.map.get(data.key));     // ‚úÖ Works!
```

### Storage vs RPC

The warning symbols (‚ö†Ô∏è) in the [type support table](/docs/structured-clone/type-support#support-table) reflect these different boundaries:

| System | Boundary | Object Identity |
|--------|----------|----------------|
| `@lumenize/structured-clone` | Per `stringify()`/`parse()` | ‚úÖ Preserved |
| `@lumenize/rpc` | Per RPC method call | ‚úÖ Preserved |
| Workers RPC | Per RPC method call | ‚úÖ Preserved |
| DO Storage | Per `put()`/`get()` operation | ‚ùå Lost |

This is why DO Storage shows ‚ö†Ô∏è for Map/Set - you can't use the original key after storing and retrieving. But RPC preserves identity within a call!

## Best Practices

### ‚úÖ DO: Use Primitive Keys When Possible

```typescript
// Good: Use user IDs as keys
const userMap = new Map([
  ["user123", { name: "Alice", email: "alice@example.com" }],
  ["user456", { name: "Bob", email: "bob@example.com" }]
]);
```

### ‚úÖ DO: Store Key References Separately

```typescript
// Good: Explicitly share keys you'll need to look up
const keyObj = { category: "admin", level: 5 };
const data = {
  permissions: new Map([[keyObj, { canEdit: true, canDelete: true }]]),
  adminKey: keyObj  // ‚úÖ Can use this to look up later
};
```

### ‚úÖ DO: Search Keys by Properties

```typescript
// Good: Find keys by searching
const targetKey = Array.from(map.keys()).find(
  key => key.userId === targetUserId
);
if (targetKey) {
  const value = map.get(targetKey);
}
```

### ‚ùå DON'T: Expect New Objects to Match

```typescript
// Bad: This won't work
const restored = await parse(serialized);
const value = restored.get({ userId: 123 });  // ‚ùå undefined!
```

### ‚ùå DON'T: Use Complex Objects as Keys Without a Lookup Strategy

```typescript
// Bad: No way to find the right key later
const map = new Map();
map.set({ complexStructure: { nested: { deep: true } } }, "value");
// How will you find this key after deserialization? ü§î
```

## Why This Behavior is Correct

This behavior **exactly matches JavaScript's native semantics**:

1. **JavaScript compares objects by reference**, not structure
2. **Serialization creates new objects** (just like cloning)
3. **The package preserves structure and relationships**, not physical memory addresses

If you need structural equality for keys, consider:
- Using primitive keys (strings/numbers)
- Creating a unique string representation as the key
- Storing keys separately for explicit lookup

## Summary

| Key/Value Type | After Deserialization | How to Access |
|---------------|----------------------|---------------|
| String, Number, Boolean | Works identically | Use the same value: `map.get("key")` |
| Object (reconstructed from serialization) | Fully reconstructed, new identity | Use the reconstructed object: `map.get(keys[0])` |
| Object (shared in data structure) | Same identity preserved | Use the shared reference: `map.get(data.keyRef)` |

Understanding these semantics ensures you can confidently use Maps and Sets with `@lumenize/structured-clone` across serialization boundaries!

