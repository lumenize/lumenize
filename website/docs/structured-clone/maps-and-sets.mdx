---
description: "Understanding Map and Set serialization behavior with primitive and object keys"
---

# Map and Set Behavior

When serializing `Map` and `Set` objects with `@lumenize/structured-clone`, it's important to understand how keys and values behave after deserialization, especially when using objects as Map keys or Set values.

## TL;DR

- ‚úÖ **Primitive keys/values** (strings, numbers, booleans) work as expected
- ‚ö†Ô∏è **Object as Map keys or Set values** behavior depends on **serialization boundaries**:
  - ‚úÖ **Identity preserved** within a single `stringify()`/`parse()` or RPC call
  - ‚ùå **Identity lost** across separate storage operations or multiple calls
- üîç Best practice: **return objects and their Map/Set together** in same call/serialization

## Primitive Keys - Work as Expected

### Strings, Numbers, Booleans

Primitive values are compared by **value**, so they work exactly as you'd expect:

```typescript
// Sender side
const map = new Map([
  ["user123", { name: "Alice" }],
  [42, { count: 100 }],
  [true, { active: true }]
]);

const serialized = await stringify(map);

// Receiver side
const restored = await parse(serialized);

console.log(restored.get("user123"));  // ‚úÖ { name: "Alice" }
console.log(restored.get(42));         // ‚úÖ { count: 100 }
console.log(restored.get(true));       // ‚úÖ { active: true }
```

**Why it works:** JavaScript compares primitives by value, so `"user123" === "user123"` is always true.

## Object Keys - Reconstructed but Different Identity

### The Challenge

When you use an object as a Map key or Set value, JavaScript uses **reference equality** (`===`), not structural equality:

```typescript
// Native JavaScript behavior
const key1 = { userId: 123 };
const key2 = { userId: 123 };

console.log(key1 === key2);  // ‚ùå false - different objects!

const map = new Map();
map.set(key1, "value");
console.log(map.get(key1));  // ‚úÖ "value"
console.log(map.get(key2));  // ‚ùå undefined - different reference!
```

### After Serialization

The structured-clone package **preserves this exact behavior**. Object keys are fully reconstructed with all their properties, but they're **new object instances**:

```typescript
// Sender side
const keyObj = { userId: 123, role: "admin" };
const map = new Map([[keyObj, "user data"]]);

const serialized = await stringify(map);

// Receiver side
const restored = await parse(serialized);

// The key is fully reconstructed...
const keys = Array.from(restored.keys());
console.log(keys[0]);  // { userId: 123, role: "admin" } ‚úÖ

// All properties are preserved...
console.log(keys[0].userId);  // 123 ‚úÖ
console.log(keys[0].role);    // "admin" ‚úÖ

// BUT it's a new object with different identity...
const newKey = { userId: 123, role: "admin" };
console.log(restored.get(newKey));  // ‚ùå undefined - different reference!

// You must use the reconstructed key object:
console.log(restored.get(keys[0]));  // ‚úÖ "user data"
```

## Finding Object Keys After Deserialization

Since you can't construct a new object to look up values, you need to **search through the reconstructed keys** to find the one you want:

### Pattern 1: Search by Property Match

```typescript
// Sender side
const user1Key = { userId: 123, type: "user" };
const user2Key = { userId: 456, type: "user" };
const adminKey = { userId: 789, type: "admin" };

const map = new Map([
  [user1Key, { name: "Alice", email: "alice@example.com" }],
  [user2Key, { name: "Bob", email: "bob@example.com" }],
  [adminKey, { name: "Admin", email: "admin@example.com" }]
]);

const serialized = await stringify(map);

// Receiver side
const restored = await parse(serialized);

// Find the key for userId 456
const targetKey = Array.from(restored.keys()).find(
  key => key.userId === 456
);

if (targetKey) {
  console.log(restored.get(targetKey));
  // ‚úÖ { name: "Bob", email: "bob@example.com" }
}
```

### Pattern 2: Store Keys Separately

The most reliable pattern is to **explicitly share the key objects** in your data structure:

```typescript
// Sender side
const keyObj = { userId: 123, role: "admin" };

const data = {
  map: new Map([[keyObj, "user data"]]),
  keyToLookup: keyObj  // ‚úÖ Share the key explicitly!
};

const serialized = await stringify(data);

// Receiver side
const restored = await parse(serialized);

// Now you can access the map using the shared key!
console.log(restored.map.get(restored.keyToLookup));
// ‚úÖ "user data"

// The key references are preserved:
console.log(restored.keyToLookup === Array.from(restored.map.keys())[0]);
// ‚úÖ true - same reconstructed object!
```

## Set Behavior with Objects

The same principles apply to `Set` - primitive values work as expected, while object values follow the same identity rules as Map keys:

```typescript
// Primitive values work fine
const set = new Set(["apple", "banana", 123]);
const restored = await parse(await stringify(set));
console.log(restored.has("apple"));  // ‚úÖ true

// Object values: can't use new objects, must search or store reference
const obj = { id: 1, name: "Alice" };
const data = { set: new Set([obj]), aliceRef: obj };
const restored = await parse(await stringify(data));
console.log(restored.set.has(restored.aliceRef));  // ‚úÖ true
```

## Aliases and Identity Preservation

If the same object appears multiple times in your data structure, it's reconstructed as the **same object reference**:

```typescript
const sharedKey = { category: "users" };
const map1 = new Map([[sharedKey, "data1"]]);
const map2 = new Map([[sharedKey, "data2"]]);
const data = { map1, map2, theKey: sharedKey };

const restored = await parse(await stringify(data));

// All references point to the same reconstructed object!
console.log(restored.map1.get(restored.theKey));  // ‚úÖ "data1"
console.log(restored.map2.get(restored.theKey));  // ‚úÖ "data2"

const key1 = Array.from(restored.map1.keys())[0];
const key2 = Array.from(restored.map2.keys())[0];
console.log(key1 === key2 && key1 === restored.theKey);  // ‚úÖ true
```

## RPC and Serialization Boundaries

The same identity preservation behavior applies when using **`@lumenize/rpc`**. Within a single RPC call, object identity is preserved:

```typescript
// Server-side DO
export class MyDO extends LumenizeBase {
  getData() {
    const keyObj = { userId: 123 };
    const map = new Map([[keyObj, "user data"]]);
    
    // Return both the map and the key in the same response
    return {
      map,
      key: keyObj  // ‚úÖ Identity preserved!
    };
  }
}

// Client-side
const stub = env.MY_DO.get(id);
const data = await stub.getData();  // Single RPC call

// The key reference works because it was returned together!
console.log(data.map.get(data.key));  // ‚úÖ "user data"
console.log(data.key === Array.from(data.map.keys())[0]);  // ‚úÖ true
```

### Understanding Serialization Boundaries

**Identity preserved (single boundary):**
- ‚úÖ Single RPC method call: `await stub.method()` returns object with map + key
- ‚úÖ Single `stringify()`/`parse()`: One serialization cycle
- ‚úÖ Native `structuredClone()`: One clone operation

**Identity lost (separate boundaries):**
- ‚ùå Separate RPC calls: Call 1 returns map, Call 2 returns key
- ‚ùå DO Storage: `put(map)` then later `get()` and use original key
- ‚ùå Separate `stringify()` calls: Serialize map and key independently

```typescript
// ‚ùå Won't work: Separate RPC calls
const map = await stub.getMap();      // Call 1
const key = await stub.getKey();      // Call 2
console.log(map.get(key));            // ‚ùå undefined - different boundaries!

// ‚úÖ Will work: Single RPC call
const data = await stub.getMapAndKey();  // One call returns both
console.log(data.map.get(data.key));     // ‚úÖ Works!
```

### Storage vs RPC

The warning symbols (‚ö†Ô∏è) in the type support documentation reflect these different boundaries:

| System | Boundary | Object Identity |
|--------|----------|----------------|
| `@lumenize/structured-clone` | Per `stringify()`/`parse()` | ‚úÖ Preserved |
| `@lumenize/rpc` | Per RPC method call | ‚úÖ Preserved |
| Workers RPC | Per RPC method call | ‚úÖ Preserved |
| DO Storage | Per `put()`/`get()` operation | ‚ùå Lost |

This is why DO Storage shows ‚ö†Ô∏è for Map/Set - you can't use the original key after storing and retrieving. But RPC preserves identity within a call!

## Best Practices

**‚úÖ DO:**
- Use primitive keys (strings, numbers) when possible
- Store key/value references separately in your data structure so they're returned together
- Return Maps and their object keys together in a single RPC call or serialization
- Search through reconstructed keys using property matching when needed

**‚ùå DON'T:**
- Expect new objects to match: `map.get({ userId: 123 })` won't work after deserialization
- Use complex objects as keys without a clear lookup strategy

## Summary

| Key/Value Type | After Deserialization | How to Access |
|---------------|----------------------|---------------|
| String, Number, Boolean | Works identically | Use the same value: `map.get("key")` |
| Object (reconstructed from serialization) | Fully reconstructed, new identity | Use the reconstructed object: `map.get(keys[0])` |
| Object (shared in data structure) | Same identity preserved | Use the shared reference: `map.get(data.keyRef)` |

Understanding these semantics ensures you can confidently use Maps and Sets with `@lumenize/structured-clone` and `@lumenize/rpc` across serialization boundaries!

