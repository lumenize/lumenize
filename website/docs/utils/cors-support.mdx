---
title: CORS Support
description: Cross-Origin Resource Sharing support for routeDORequest
---

# CORS Support for Request Routing

The `routeDORequest` function includes comprehensive CORS (Cross-Origin Resource Sharing) support, allowing you to control which origins can access your Durable Objects.

## Overview

When CORS is enabled and an origin is allowed:
- Sets `Access-Control-Allow-Origin: <origin>` (reflects the request's origin)
- Sets `Vary: Origin` header
- Does NOT set `Access-Control-Allow-Credentials` (not supported)

### HTTP vs WebSocket CORS Behavior

**Critical Difference**: This implementation uses **non-standard server-side CORS enforcement** that differs from typical CORS implementations (like Cloudflare's `routeAgentRequest`).

#### Standard CORS Behavior (Other Implementations)
Most CORS implementations (including `routeAgentRequest` from the Cloudflare `agents` package) follow the standard browser-enforced pattern:
- **Server forwards ALL requests** to the backend, regardless of origin
- Server adds (or omits) CORS headers in the response
- **Browser enforces blocking** - prevents JavaScript from accessing the response if headers don't match
- Backend processes every request, even from disallowed origins

**Problem**: The backend (Durable Object) still processes requests from unwanted origins, wasting resources and potentially exposing it to attacks.

#### Non-Standard (Enhanced) Behavior - This Implementation

This implementation provides **server-side rejection** for both HTTP and WebSocket requests:

**HTTP Requests (GET, POST, etc.)**
- Server validates origin BEFORE forwarding to Durable Object
- **Returns 403 Forbidden** for disallowed origins (request never reaches DO)
  - Note: The browser performs CORS checks on 403 responses (per WHATWG Fetch spec)
  - Since the 403 lacks CORS headers, the browser treats it as a CORS failure (network error)
  - JavaScript sees the same error as standard CORS violation - no difference from the browser's perspective
- Only forwards allowed requests to Durable Object
- Adds CORS headers to allowed responses
- **Result**: Browser compatibility maintained while providing defense-in-depth

**WebSocket Upgrade Requests**
- **Browsers DO NOT enforce** `Access-Control-Allow-Origin` for WebSocket upgrades ([MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API))
- **Server MUST enforce** origin validation (WebSocket spec delegates security to server)
- **Returns 403 Forbidden** for disallowed origins BEFORE upgrading connection
- Only upgrades to WebSocket if origin is allowed (or CORS is disabled)

#### Why Non-Standard is Better

**Benefits:**
1. **More secure**: Eliminates the possibility that a CORS invalid request can change the state of the server
2. **Reduced latency**: No round-trip to Durable Object for blocked requests
3. **Cost savings**: Fewer DO invocations and CPU time
4. **Consistency**: "Standard" behavior is different between HTTP and WebSockets upgrade request (which are also, ironically, HTTP) while with this approach they are the same

**Browser Compatibility:**
The 403 response appears identical to standard CORS from the browser's perspective:
- Browser sees network-level failure (can't access response)
- JavaScript gets same error as standard CORS violation
- Developer console shows similar CORS error message

**Comparison:**

```typescript
// Standard CORS (routeAgentRequest from cloudflare/agents)
// 1. Request arrives with Origin: https://evil.com
// 2. Server forwards to Durable Object
// 3. DO processes request (wastes resources and potentially changes state)
// 4. Server omits CORS headers
// 5. Browser blocks response from reaching client-side JavaScript
// PROBLEM: DO still did the work!

// Non-standard (this implementation)
// 1. Request arrives with Origin: https://evil.com
// 2. Server validates origin, sees it's not allowed
// 3. Returns 403 Forbidden immediately
// 4. DO never invoked (resources saved and state uneffected)
// 5. Browser sees network error (same as CORS failure)
// BENEFIT: DO protected, resources saved, browser behavior preserved!
```

**Note**: This non-standard server-side rejection provides better security than RFC-compliant CORS. The array and validator function modes prevent unwanted origins from ever reaching your Durable Object.

**Alternative: Use `onBeforeRequest` for Custom CORS**: If you need traditional browser-only CORS enforcement (or any other custom CORS behavior), you can implement it in the [`onBeforeRequest` hook](/docs/utils/route-do-request#onbeforerequest). This gives you complete control - you can add CORS headers, forward to the DO, and return responses however you like. See [Custom CORS with Hooks](#custom-cors-with-hooks) below.

### Configuration Modes

The `cors` option supports three modes:

- **`false`** (default): No CORS headers are added
- **`true`** (permissive): Reflects any request's Origin header
- **`{ origin: string[] | (origin: string, request: Request) => boolean }`**: Custom validation

## Basic Usage

### Permissive Mode (Allow All Origins)

```typescript
await routeDORequest(request, env, {
  cors: true
});
```

### Whitelist Specific Origins

```typescript
await routeDORequest(request, env, {
  cors: {
    origin: ['https://app.example.com', 'https://admin.example.com']
  }
});
```

### Custom Validation Function

```typescript
await routeDORequest(request, env, {
  cors: {
    origin: (origin, request) => {
      // Check origin domain
      if (!origin.endsWith('.example.com')) {
        return false;
      }
      
      // Also inspect the request for additional validation
      const apiKey = request.headers.get('X-API-Key');
      if (!apiKey || apiKey !== 'trusted-key') {
        return false;
      }
      
      // Block certain HTTP methods
      if (request.method === 'DELETE') {
        return false;
      }
      
      // Check user agent to block bots
      const userAgent = request.headers.get('User-Agent');
      if (userAgent?.toLowerCase().includes('bot')) {
        return false;
      }
      
      return true;
    }
  }
});
```

The validator function receives both the `origin` string and the full `Request` object, allowing you to implement sophisticated CORS policies based on multiple request attributes.

## Preflight Request Handling

CORS automatically handles OPTIONS (preflight) requests:

- **When origin is allowed**: Returns `204 No Content` with CORS headers (short-circuits before hooks)
- **When no Origin header present OR origin not allowed**: Passes through to Durable Object

```typescript
// Example preflight flow:
// 1. Browser sends: OPTIONS /my-do/instance with Origin: https://app.example.com
// 2. If origin allowed: Returns 204 with CORS headers immediately
// 3. If origin not allowed: Forwards to DO (which may return 404 or handle it)
```

## Integration with Hooks

CORS headers are automatically added to responses from:
- The Durable Object itself
- `onBeforeConnect` hook responses
- `onBeforeRequest` hook responses

Only adds headers when the origin is allowed:

```typescript
await routeDORequest(request, env, {
  cors: { origin: ['https://app.example.com'] },
  onBeforeRequest: async (request, context) => {
    const token = request.headers.get('Authorization');
    if (!token) {
      return new Response('Unauthorized', { status: 401 });
      // CORS headers will be added to this response if origin is allowed
    }
  }
});
```

## Advanced Use Cases

### Multi-Factor CORS Validation

The function validator's access to the full `Request` object enables sophisticated CORS policies:

```typescript
await routeDORequest(request, env, {
  cors: {
    origin: (origin, request) => {
      // 1. Check origin whitelist
      const trustedOrigins = ['https://app.example.com', 'https://admin.example.com'];
      const trustedDomains = ['.example.com', '.example.dev'];
      
      const isOriginTrusted = 
        trustedOrigins.includes(origin) ||
        trustedDomains.some(domain => origin.endsWith(domain));
      
      if (!isOriginTrusted) return false;
      
      // 2. Additional request-based checks
      
      // Check authentication token for sensitive operations
      if (request.method !== 'GET') {
        const authToken = request.headers.get('Authorization');
        if (!authToken?.startsWith('Bearer ')) return false;
      }
      
      // Block known bad user agents
      const userAgent = request.headers.get('User-Agent') || '';
      const blockedAgents = ['badbot', 'scraper'];
      if (blockedAgents.some(agent => userAgent.toLowerCase().includes(agent))) {
        return false;
      }
      
      // Rate limiting hint - check for rate limit headers
      const rateLimitRemaining = request.headers.get('X-RateLimit-Remaining');
      if (rateLimitRemaining && parseInt(rateLimitRemaining) === 0) {
        return false;
      }
      
      return true;
    }
  }
});
```

### Environment-Specific CORS

```typescript
// Different CORS policies per environment
const getCorsConfig = (env: Env): CorsOptions => {
  if (env.ENVIRONMENT === 'production') {
    return {
      origin: (origin, request) => {
        // Strict validation in production
        const allowedOrigins = ['https://app.example.com'];
        if (!allowedOrigins.includes(origin)) return false;
        
        // Require API key in production
        const apiKey = request.headers.get('X-API-Key');
        return apiKey === env.PRODUCTION_API_KEY;
      }
    };
  }
  
  if (env.ENVIRONMENT === 'staging') {
    return {
      // Whitelist for staging
      origin: ['https://staging.example.com', 'https://preview.example.com']
    };
  }
  
  // Development - allow all
  return true;
};

await routeDORequest(request, env, {
  cors: getCorsConfig(env)
});
```

### Method-Specific CORS

```typescript
await routeDORequest(request, env, {
  cors: {
    origin: (origin, request) => {
      // Allow GET/HEAD from any subdomain
      if (request.method === 'GET' || request.method === 'HEAD') {
        return origin.endsWith('.example.com');
      }
      
      // Only allow POST/PUT/DELETE from specific origins
      const writeOrigins = ['https://app.example.com', 'https://admin.example.com'];
      return writeOrigins.includes(origin);
    }
  }
});
```

### Custom CORS with Hooks

For complete control over CORS behavior (including traditional browser-only enforcement), use the `onBeforeRequest` hook to manually call the DO and add CORS headers:

```typescript
import { getDOStub } from '@lumenize/utils';
//...

await routeDORequest(request, env, {
  // Disable built-in CORS
  cors: false,
  
  onBeforeRequest: async (request, context) => {
    const origin = request.headers.get('Origin');
    const allowedOrigins = ['https://app.example.com', 'https://admin.example.com'];
    
    // Handle preflight
    if (request.method === 'OPTIONS') {
      if (origin && allowedOrigins.includes(origin)) {
        return new Response(null, {
          status: 204,
          headers: {
            'Access-Control-Allow-Origin': origin,
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Vary': 'Origin'
          }
        });
      }
      // Let DO handle unallowed preflight
      return undefined;
    }
    
    // For traditional CORS: call DO manually and add headers based on origin
    const doStub = getDOStub(context.doNamespace, context.doInstanceNameOrId);
    const response = await doStub.fetch(request);
    
    // Add CORS headers if origin is allowed
    if (origin && allowedOrigins.includes(origin)) {
      const headers = new Headers(response.headers);
      headers.set('Access-Control-Allow-Origin', origin);
      headers.set('Vary', 'Origin');
      
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    
    // Return response without CORS headers for unallowed origins
    return response;
  }
});
```

This approach gives you complete flexibility:
- **Traditional CORS**: Forward all requests to DO, add/omit headers based on origin (DO always processes the request)
- **Custom validation**: Check any request properties before forwarding
- **Direct DO access**: Use `context.doNamespace` and `context.doInstanceNameOrId` to call the DO yourself
- **Custom responses**: Return any response from the hook

## Type Definition

```typescript
export type CorsOptions = 
  | false  // No CORS headers
  | true   // Permissive: echo any Origin
  | {
      origin: string[] | ((origin: string, request: Request) => boolean);
    };
```

## Security Considerations

1. **Browser-only protection**: CORS (including this non-standard server-side implementation) **only protects against browser-based attacks**. Malicious non-browser clients can set any `Origin` header they want, bypassing origin validation entirely. CORS is not a substitute for proper authentication and authorization - always validate API keys, tokens, or other credentials for sensitive operations.

2. **No credentials support**: This implementation does not set `Access-Control-Allow-Credentials`, meaning cookies and authorization headers won't be sent cross-origin even if the origin is allowed.

3. **Origin validation**: Always validates the Origin header when CORS is enabled - never allows requests without proper origin validation in whitelist/function modes.

4. **Vary header**: Always sets `Vary: Origin` to ensure proper caching behavior with CDNs and browsers.

## See Also

- [Request Routing](/docs/utils/route-do-request) - Main `routeDORequest` documentation
- [API Reference - routeDORequest](/docs/utils/api/functions/routeDORequest)
- [API Reference - getDOStub](/docs/utils/api/functions/getDOStub)
