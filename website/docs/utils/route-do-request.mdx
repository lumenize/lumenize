---
title: Request Routing
description: Route HTTP and WebSocket requests to Durable Objects with authentication hooks
---

# Request Routing with `routeDORequest`

The `routeDORequest` function provides intelligent routing of HTTP and WebSocket requests to Durable Objects with support for authentication hooks and prefix matching. It's a near drop-in replacement for Cloudflare's `routeAgentRequest` and PartyKit's `routePartyRequest`, but uses standard Cloudflare naming conventions (no "party", "room", "agent") and has many useful upgrades.

## Installation

```bash npm2yarn
npm install @lumenize/utils
```

## Basic Usage

```typescript
import { routeDORequest } from '@lumenize/utils';

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Try to route to DOs first
    const doResponse = await routeDORequest(request, env);
    if (doResponse) return doResponse;
    
    // Fallback for non-DO requests
    return new Response("Not Found", { status: 404 });
  }
};
```

## URL Format

Requests must follow this format:
```
[/${prefix}]/${doBindingName}/${doInstanceNameOrId}[/path...]
```

## Instance ID Handling

The function automatically detects 64-character hex strings (from `newUniqueId().toString()`) and uses `idFromString()` instead of `getByName()`:

- Named instance
  - Path: `/my-do/lobby`
  - Resolves to: `env.MY_DO.getByName('lobby')`

- Unique ID (64â€‘char hex)
  - Path: `/my-do/8aa7a69131efa8902661702e701295f168aa5806045ec15d01a2f465bd5f3b99`
  - Resolves to: `env.MY_DO.get(env.MY_DO.idFromString('8aa7...'))`

- Named instance with prefix
  - Path: `/agents/user-do/john`
  - With config: `{ prefix: '/agents' }`
  - Resolves to: `env.USER_DO.getByName('john')`

## Supported Case Conversions for `doBindingName`

The function intelligently converts URL path segments to match various binding naming conventions:

| URL Path Segment | Matches Binding Names |
|------------------|----------------------|
| `/my-do/...` | `MY_DO`, `MyDO`, `MyDo`, `myDo`, `my-do` |
| `/user-session/...` | `USER_SESSION`, `UserSession`, `userSession`, `user-session` |
| `/my-d-o/...` | `MY_D_O`, `MyDO`, `MyDO`, `myDO`, `my-d-o` |
| `/api-handler/...` | `API_HANDLER`, `ApiHandler`, `apiHandler`, `api-handler` |

## Hooks

### onBeforeRequest

`onBeforeRequest` runs for HTTP requests before they reach your Durable Object. Use it to:

- reject requests early by returning a `Response` (e.g., 401/403),
- modify the `Request` (return a new `Request`), or
- continue unchanged by returning `undefined`.

This hook does not run for WebSocket upgrade requests.

### onBeforeConnect

`onBeforeConnect` runs only for WebSocket upgrade requests (`Upgrade: websocket`). Use it to validate or enrich the request before the upgrade. Return a `Response` to block, a modified `Request` to continue with changes, or `undefined` to proceed as-is.

### Examples

Use hooks to validate or modify requests before they reach your Durable Objects:

```typescript
const response = await routeDORequest(request, env, {
  // Hook for WebSocket connections
  onBeforeConnect: async (request, { doNamespace, doInstanceNameOrId }) => {
    const token = request.headers.get('Authorization');
    if (!token || !await validateToken(token)) {
      return new Response('Unauthorized', { status: 401 });
    }
    
    // Add user info to headers
    const modifiedRequest = new Request(request);
    modifiedRequest.headers.set('X-User-ID', await getUserId(token));
    return modifiedRequest;
  },
  
  // Hook for HTTP requests
  onBeforeRequest: async (request, { doNamespace, doInstanceNameOrId }) => {
    console.log(`Request to instance: ${doInstanceNameOrId}`);
    
    const apiKey = request.headers.get('X-API-Key');
    if (request.method !== 'GET' && !apiKey) {
      return Response.json(
        { error: 'API key required' }, 
        { status: 403 }
      );
    }
  }
});
```

## Prefix Matching

Use the `prefix` option to scope routing to a specific URL path:

```typescript
// Only route URLs starting with /api/
const response = await routeDORequest(request, env, {
  prefix: '/api'
});

// Now only /api/my-do/instance123 routes, not /my-do/instance123
```

`routeDORequest` will short-circuit return undefined if the Request.url doesn't match the prefix.

## CORS Support

The most common cross-origin resource sharing (CORS) configuration and our recommendation 90% of the time is a simple whitelist.

```typescript
// Whitelist specific origins
await routeDORequest(request, env, {
  cors: {
    origin: ['https://app.example.com', 'https://admin.example.com']
  }
});
```

The following examples match the behavior of `routeAgentRequest` using the same configuration but we recommend against their use particularly if your DOs use WebSockets with a browser because the browser does not natively provide CORS protection for WebSocket use.

```typescript
await routeDORequest(request, env, { cors: true }); // Allow all origins (permissive)
await routeDORequest(request, env ); // Default, only allow `fetch` on this origin
// Note, the default ('false') allows WebSocket access for ALL origins
```

`routeDORequest` CORS support goes way beyond what is supported by `routeAgentRequest` and a simple whitelist. For a detailed discussion and all available options in case you have an advanced use case see [CORS Support](/docs/utils/cors-support).

When enabled, CORS support automatically:
- Reflects the allowed origin in `Access-Control-Allow-Origin` header
- Sets `Vary: Origin` for proper caching
- Handles OPTIONS (preflight) requests
- Adds headers to both DO responses and `onBefore...` hook responses

## Error Handling

The function throws errors for invalid requests:

- **`MissingInstanceNameError`** (400) - Binding name found but instance name/ID missing
- **`MultipleBindingsFoundError`** (400) - Multiple DO bindings match the path segment (configuration error)

Note, if the url segment for doBindingName doesn't match any DO Namespaces found on `env`, it will return undefined not an error.

Each error includes an `httpErrorCode` property in addition to the standard `message` property for easy HTTP response handling:

```typescript
try {
  const response = await routeDORequest(request, env);
  if (response) return response;
} catch (error: any) {
  // Handle MissingInstanceNameError, MultipleBindingsFoundError, etc.
  const status = error.httpErrorCode || 500;
  return new Response(error.message, { status });
}
```

## Complete Example

```typescript
import { routeDORequest } from '@lumenize/utils';

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Route all /do/* requests to Durable Objects
    const doResponse = await routeDORequest(request, env, {
      prefix: '/do',
      
      onBeforeConnect: async (request, context) => {
        // Validate WebSocket connections
        if (!request.headers.get('Authorization')) {
          return new Response('Unauthorized', { status: 401 });
        }
      },
      
      onBeforeRequest: async (request, context) => {
        // Log all HTTP requests
        console.log(`HTTP ${request.method} to ${context.doInstanceNameOrId}`);
      }
    });
    
    if (doResponse) return doResponse;
    
    // Handle non-DO routes
    if (request.url.endsWith('/health')) {
      return new Response('OK');
    }
    
    return new Response('Not Found', { status: 404 });
  }
};
```

## Key Features

- **Case-insensitive binding name matching** - Flexible naming conventions
- **Automatic ID detection** - Handles both named instances and unique IDs
- **Hooks** - Authenticate, validate, or enhance requests before they reach DOs
- **Prefix support** - Scope routing to specific URL paths
- **Hono-style behavior** - Returns `undefined` if request doesn't match
- **Standard Cloudflare naming** - No confusing party/agent/room terminology
