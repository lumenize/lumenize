---
title: Usage Examples
description: Comprehensive guide to testing Durable Objects with @lumenize/testing
testable: true
---

# @lumenize/testing Usage Examples

@lumenize/testing is a superset of functionality of `cloudflare:test` with a more *de*light*ful* DX. While `cloudflare:test`'s `runInDurableObject` only allows you to work with `ctx`/state, @lumenize/testing also allows you to do that plus:

- **Inspect or manipulate instance variables** (custom, `this.env`, etc.)
- **Call instance methods directly** from your test
- **Greatly enhances your ability to test DOs via WebSockets**
- **Simulate browser behavior** with cookie management and realistic CORS simulation
- **Honors input/output gates** (`runInDurableObject` does not) to test for race conditions
- **Does all of the above with a fraction of the boilerplate**

## Installation

```bash npm2yarn
npm install --save-dev @lumenize/testing
```

## Setup

### Durable Object

First, create a Durable Object with some methods to test. This example shows a simple counter with WebSocket support:

```typescript src/index.ts
import { DurableObject } from "cloudflare:workers";
import { routeDORequest } from '@lumenize/utils';

const handleLogin = (request: Request): Response | undefined => {
  const url = new URL(request.url);
  if (!url.pathname.endsWith('/login')) return undefined;
  
  const user = url.searchParams.get('user');
  if (user === 'test') {
    return new Response('OK', {
      headers: { 'Set-Cookie': 'token=abc123; Path=/' }
    });
  }
  return new Response('Invalid', { status: 401 });
};

const handleProtectedCookieEcho = (request: Request): Response | undefined => {
  const url = new URL(request.url);
  if (!url.pathname.endsWith('/protected-cookie-echo')) return undefined;
  
  const cookies = request.headers.get('Cookie') || '';
  return new Response(`Cookies: ${cookies}`, {
    status: cookies.includes('token=') ? 200 : 401
  });
};

// Worker
export default {
  async fetch(request, env, ctx) {
    // CORS-protected route with prefix /cors-secure/
    // Array form shown; also supports cors: true for permissive mode
    // See https://lumenize.com/docs/utils/route-do-request for routing details
    // See https://lumenize.com/docs/utils/cors-support for CORS configuration
    const routeCORSRequest = (req: Request, e: Env) => routeDORequest(req, e, {
      prefix: '/cors-secure/',
      cors: { origin: ['https://my-origin.com', 'https://app.example.com'] },
    });
    
    // Worker handlers follow the hono convention: return Response to handle, undefined to fall through
    return (
      handleLogin(request) ||
      handleProtectedCookieEcho(request) ||
      await routeCORSRequest(request, env) ||
      await routeDORequest(request, env) ||
      new Response("Not Found", { status: 404 })
    );
  }
} satisfies ExportedHandler<Env>;

// Durable Object
export class MyDO extends DurableObject<Env>{
  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env);

    this.ctx.setWebSocketAutoResponse(
      new WebSocketRequestResponsePair("auto-response-ping", "auto-response-pong"),
    );
  }

  increment(): number {
    let count = (this.ctx.storage.kv.get<number>("count")) ?? 0;
    void this.ctx.storage.put("count", ++count);
    return count;
  }

  echo(value: any): any { return value; }

  async fetch(request: Request) {
    const url = new URL(request.url);    
    
    const operation = url.searchParams.get('op') || 'unknown';
    
    if (url.pathname.endsWith('/increment')) {
      const count = await this.increment();
      return new Response(count.toString(), { 
        headers: { 'Content-Type': 'text/plain' } 
      });
    }

    if (request.headers.get("Upgrade")?.toLowerCase() === "websocket") {
      const webSocketPair = new WebSocketPair();
      const [client, server] = Object.values(webSocketPair);
      
      // Handle sub-protocol selection
      const requestedProtocols = request.headers.get('Sec-WebSocket-Protocol');
      const responseHeaders = new Headers();
      let selectedProtocol: string | undefined;
      if (requestedProtocols) {
        const protocols = requestedProtocols.split(',').map(p => p.trim());
        if (protocols.includes('correct.subprotocol')) {
          selectedProtocol = 'correct.subprotocol';
          responseHeaders.set('Sec-WebSocket-Protocol', selectedProtocol);
        }
      }
      
      const name = url.pathname.split('/').at(-1) ?? 'No name in path'
      
      // Collect all request headers for testing
      const headersObj: Record<string, string> = {};
      request.headers.forEach((value, key) => {
        headersObj[key] = value;
      });
      
      const attachment = { 
        name, 
        headers: headersObj
      };
      
      this.ctx.acceptWebSocket(server, [name]);
      server.serializeAttachment(attachment);

      return new Response(null, {
        status: 101,
        webSocket: client,
        headers: responseHeaders
      });
    }

    return new Response('Not found', { status: 404 });
  }

  webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    if (message === 'increment') {
      return ws.send(this.increment().toString());
    }

    if (message === 'test-server-close') {   
      return ws.close(4001, "Server initiated close for testing");
    }
  }

  webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {
    this.ctx.storage.kv.put("lastWebSocketClose", { code, reason, wasClean });
    ws.close(code, reason);
  }
};
```

### Wrangler Configuration

Configure your Durable Object bindings in `wrangler.jsonc`:

```jsonc wrangler.jsonc
{
	"name": "testing-agent-with-agent-client",
	"main": "src/index.ts",
	"compatibility_date": "2025-09-12",
	"compatibility_flags": [
	  "nodejs_compat"
	],
	"migrations": [
		{
			"new_sqlite_classes": [
				"MyDO"
			],
			"tag": "v1"
		}
	],
	"durable_objects": {
		"bindings": [
			{
				"class_name": "MyDO",
				"name": "MY_DO"
			}
		]
	}
}
```

### Vitest Configuration

Configure Vitest with the Cloudflare Workers pool:

```javascript vitest.config.js
import { defineWorkersProject } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersProject({
  test: {
    testTimeout: 2000, // 2 second global timeout
    poolOptions: {
      workers: {
        isolatedStorage: false,  // Must be false for now to use websockets. Have each test create a new DO instance to avoid state sharing.
        wrangler: { configPath: "./wrangler.jsonc" },
      },
    },
    coverage: {
      provider: "istanbul",
      reporter: ['text', 'json', 'html'],
      include: ['**/src/**'],
      exclude: [
        '**/node_modules/**', 
        '**/dist/**', 
        '**/build/**', 
        '**/*.config.ts',
        '**/scratch/**'
      ],
    },
  },
});
```

## Basic Usage: State Manipulation

The `createTestingClient` function creates an RPC proxy that allows you to interact with your Durable Object instance:

```typescript test
import { it, expect, vi } from 'vitest';
import { createTestingClient, Browser, fetch, WebSocket, type RpcAccessible } from '@lumenize/testing';
import { MyDO } from '../src';

type MyDOType = RpcAccessible<InstanceType<typeof MyDO>>;

it('shows pre-populating DO state, interacting with it, then checking state after', async () => {
  // Create RPC testing client with binding name and instance name or id
  await using client = createTestingClient<MyDOType>('MY_DO', 'put-do-get');

  // Pre-populate storage via RPC async KV API
  await client.ctx.storage.put('count', 10);

  // Make a regular fetch call to increment
  expect(await (await fetch('https://example.com/my-do/put-do-get/increment')).text()).toBe('11');

  // Call increment via RPC and get count as a number
  expect(await client.increment()).toBe(12);

  // Verify that storage is correct via RPC non-async KV API but still requires `await`
  expect(await client.ctx.storage.kv.get('count')).toBe(12);
});
```

## WebSocket Testing

`createTestingClient` with WebSocket support allows you to test WebSocket functionality with a familiar browser-compatible API:

```typescript test
it('shows testing WebSocket functionality', async () => {
  // Create RPC client to inspect server-side WebSocket state
  await using client = createTestingClient<MyDOType>('MY_DO', 'test-ws');
  
  // Create a WebSocket and wait for it to open
  const ws = new WebSocket('wss://example.com/my-do/test-ws', ['wrong.protocol', 'correct.subprotocol']) as any;
  let wsOpened = false
  ws.onopen = () => wsOpened = true;
  await vi.waitFor(() => expect(wsOpened).toBe(true));

  // Verify the selected protocol matches what server chose
  expect(ws.protocol).toBe('correct.subprotocol');

  // Send 'increment' message and verify response
  let incrementResponse: string | null = null;
  ws.onmessage = (event: any) => {
    incrementResponse = event.data;
  };
  ws.send('increment');
  await vi.waitFor(() => expect(incrementResponse).toBe('1'));
  
  // Trigger server-initiated close and verify close event
  let closeEventFired = false;
  let closeCode: number | null = null;
  ws.onclose = (event: any) => {
    closeEventFired = true;
    closeCode = event.code;
  };
  ws.send('test-server-close');
  await vi.waitFor(() => expect(closeEventFired).toBe(true));
  expect(closeCode).toBe(4001);

  // Access getWebSockets using tag that matches DO instance name
  const webSocketsOnServer = await client.ctx.getWebSockets('test-ws');
  expect(webSocketsOnServer.length).toBe(1);

  // Assert on ws attachment
  const { deserializeAttachment } = webSocketsOnServer[0];
  const attachment = await deserializeAttachment();
  expect(attachment).toMatchObject({
    name: 'test-ws',  // From URL path: /my-do/test-ws
    headers: expect.objectContaining({
      'upgrade': 'websocket',
      'sec-websocket-protocol': 'wrong.protocol, correct.subprotocol'
    })
  });

  // Tests ctx.setWebSocketAutoResponse by creating a new ws connection to the same DO
  const ws2 = new WebSocket('wss://example.com/my-do/test-ws') as any;
  let autoResponseReceived = false;
  ws2.send('auto-response-ping');
  ws2.onmessage = async (event: any) => {
    expect(event.data).toBe('auto-response-pong');
    autoResponseReceived = true;
  };
  await vi.waitFor(() => expect(autoResponseReceived).toBe(true));

  ws.close();
});
```

## Structured Clone Support

All structured clone types work seamlessly with RPC calls, just like Cloudflare's native RPC:

```typescript test
it('shows RPC working with StructuredClone types', async () => {
  await using client = createTestingClient<MyDOType>('MY_DO', 'structured-clone');

  // Map (and every other structured clone types) works with storage
  const testMap = new Map<string, any>([['key1', 'value1'], ['key2', 42]]);
  client.ctx.storage.kv.put('testMap', testMap);
  const retrievedMap = await client.ctx.storage.kv.get<Map<string, any>>('testMap');
  expect(retrievedMap).toEqual(testMap);
  
  // Map (and every other structured clone types) also works with custom method echo()
  const echoedMap = await client.echo(testMap);
  expect(echoedMap).toEqual(testMap);

  // We're just going to use echo() to show other types work

  // Set
  const testSet = new Set<any>([1, 2, 3, 'four']);
  expect(await client.echo(testSet)).toEqual(testSet);

  // Date
  const testDate = new Date('2025-10-12T12:00:00Z');
  expect(await client.echo(testDate)).toEqual(testDate);

  // Circular reference
  const circular: any = { name: 'circular' };
  circular.self = circular;
  expect(await client.echo(circular)).toEqual(circular); // Circular ref preserved at correct level
});
```

## Browser Simulation

The `Browser` class simulates browser behavior with automatic cookie management and CORS support:

```typescript test
it('shows cookie sharing between fetch and WebSocket from same browser', async () => {
  // Create ONE browser instance
  const browser = new Browser();
  
  // 1. Login via fetch - sets session cookie (no need to pass fetch!)
  await browser.fetch('https://example.com/login?user=test');
  
  // 2. Verify cookie was stored in the browser
  expect(browser.getCookie('token')).toBe('abc123');
  
  // 3. Manually add additional cookies - domain is inferred from first fetch
  browser.setCookie('extra', 'manual-value');
  
  // 4. Make another fetch request - gets BOTH cookies automatically
  const res = await browser.fetch('https://example.com/protected-cookie-echo');
  const text = await res.text();
  expect(text).toContain('token=abc123');      // From login
  expect(text).toContain('extra=manual-value'); // Manually added
  
  // 5. WebSocket connection also gets BOTH cookies automatically!
  // Note: Cast to `any` needed because Cloudflare's WebSocket type doesn't include event handlers
  const ws = new browser.WebSocket('wss://example.com/my-do/shared-cookies') as any;
  
  let wsOpened = false;
  ws.onopen = () => { wsOpened = true; };
  
  await vi.waitFor(() => expect(wsOpened).toBe(true));
  
  // 6. Verify WebSocket connection was established with cookies
  await using client = createTestingClient<MyDOType>('MY_DO', 'shared-cookies');
  const wsList = await client.ctx.getWebSockets('shared-cookies');
  expect(wsList.length).toBe(1);
  
  ws.close();
});
```

## CORS and Origin Testing

Use `browser.page()` to test CORS and Origin validation:

```typescript test
it('shows testing Origin validation using browser.page()', async () => {
  const browser = new Browser();
  
  // Create a page with Origin header + custom headers
  // Note: headers/maxQueueBytes configured at page level to maintain standard WebSocket API
  const page = browser.page('https://my-origin.com', {
    headers: { 'X-Custom-Header': 'test-value' },
    maxQueueBytes: 1024 * 1024 // 1MB WebSocket queue limit while CONNECTING
  });
  
  // WebSocket upgrade includes Origin header
  const ws = new page.WebSocket('wss://my-origin.com/cors-secure/my-do/ws-test') as any;
  let wsOpened = false;
  ws.onopen = () => { wsOpened = true; };
  await vi.waitFor(() => expect(wsOpened).toBe(true));
  // Note: browser standard WebSocket doesn't have request/response properties, but they're useful for debugging
  expect(ws.request.headers.get('Origin')).toBe('https://my-origin.com');
  expect(ws.request.headers.get('X-Custom-Header')).toBe('test-value');
  expect(ws.response.headers.get('Access-Control-Allow-Origin')).toBe('https://my-origin.com');
  ws.close();
  
  // HTTP request also includes Origin header - allowed
  const response = await page.fetch('https://my-origin.com/cors-secure/my-do/cors-test/increment');
  expect(response.status).toBe(200);
  expect(response.headers.get('Access-Control-Allow-Origin')).toBe('https://my-origin.com');
  
  // Set up: Pre-populate count to verify DO is never called
  await using client = createTestingClient<MyDOType>('MY_DO', 'blocked');
  await client.ctx.storage.put('count', 42);

  // Blocked origin - server rejects with 403 without CORS headers
  // In a real browser, this would throw a network error (CORS failure)
  // But in testing, we can still inspect the response    
  const blocked = await browser.page('https://evil.com').fetch('https://my-origin.com/cors-secure/my-do/blocked/increment');
  expect(blocked.status).toBe(403);
  expect(blocked.headers.get('Access-Control-Allow-Origin')).toBeNull(); // No CORS headers
  
  // Verify DO was never called - count is still 42 (not 43)
  const count = await client.ctx.storage.get('count');
  expect(count).toBe(42);
});
```

## Instance Inspection

Use `__asObject()` to discover all public members on your DO instance:

```typescript test
it('shows DO inspection and function discovery using __asObject()', async () => {
  await using client = createTestingClient<MyDOType>('MY_DO', 'property-inspection-test');

  const instanceAsObject = await client.__asObject?.();
  
  expect(instanceAsObject).toMatchObject({
    // DO methods are discoverable
    increment: "increment [Function]",
    
    // DurableObjectState context with complete API
    ctx: {
      storage: {
        get: "get [Function]",
        // ... other storage methods available
        sql: {
          databaseSize: expect.any(Number), // Assert on non-function properties
          // ... other ctx.sql methods
        },
        kv: {
          get: "get [Function]",
          // ... other storage methods available
        },
      },
      getWebSockets: "getWebSockets [Function]",
      // ... other ctx methods available
    },
    
    // Environment object with DO bindings
    env: {
      MY_DO: {
        getByName: "getByName [Function]",
        // ... other binding methods available
      },
      // ... other environment bindings available
    }
  });
});
```

## RPC Quirks

There are a few quirks to be aware of when using the RPC client:

```typescript test
it('requires await for even non-async function calls', async () => {
  await using client = createTestingClient<MyDOType>('MY_DO', 'quirks');

  // 1. Function calls require await even if what they are calling is not async inside the DO

  // using `async ctx.storage.put(...)`
  // requires await in both RPC client and the DO
  await client.ctx.storage.put('key', 'value');

  // using non-async `ctx.storage.kv.get(...)`
  // would not require await in DO but does in RPC client
  const asyncResult = await client.ctx.storage.kv.get('key');
  expect(asyncResult).toBe('value');
  
  // 2. Property access can be chained and destructured (returns a new Proxy)
  const storage = client.ctx.storage;
  const { sql } = storage;
  
  // 3. Static properties can be accessed directly and require await
  expect(typeof (await sql.databaseSize)).toBe('number');
  
  // 4. __asObject() is only callable from the root client, not nested proxies
  // But it returns the complete nested structure as plain data
  const fullObject = await client.__asObject?.();
  
  // 5. No `await` needed to access nested static properties from __asObject()
  expect(typeof fullObject?.ctx?.storage?.sql?.databaseSize).toBe('number');
  expect(fullObject?.ctx?.storage?.sql?.databaseSize).toBe(await sql.databaseSize);
});
```

## Key Features

- **`createTestingClient`**: Alter and inspect DO state (`ctx...`, custom methods/properties, etc.)
- **`fetch`**: Simple fetch for making requests to your worker
- **`WebSocket`**: Browser-compatible WebSocket for DO connections
- **`Browser`**: Simulates browser behavior for testing
  - `browser.fetch` → cookie-aware fetch (no Origin header)
  - `browser.WebSocket` → cookie-aware WebSocket constructor (no Origin header)
  - `browser.page(origin)` → returns `{ fetch, WebSocket }` with Origin header
    - Both automatically include cookies from the Browser instance
    - Simulates requests from a page loaded from the given origin
    - Perfect for testing CORS and Origin validation logic

## Next Steps

- Explore the [API Reference](/docs/testing/api) for detailed documentation
- Learn more about [routeDORequest](/docs/utils/route-do-request) for routing requests to DOs
- Check out [CORS support](/docs/utils/cors-support) for configuring CORS in your workers
