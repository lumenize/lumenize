---
title: Alarm Simulation
description: Test Durable Object alarms without runDurableObjectAlarm
---

# Alarm Simulation

:::caution[Alpha Feature]
Alarm simulation is currently in **alpha**. It works well for simple, direct uses of `ctx.storage.setAlarm()` but has known limitations with packages that multiplex Cloudflare's single alarm (like `@cloudflare/actors` Alarms or `@lumenize/alarms`). See [Known Limitations](#known-limitations) and [Workarounds](#workarounds) below.
:::

`@lumenize/testing` automatically simulates Cloudflare Durable Object alarms, making them **fire automatically at the right time** during tests - no need for `runDurableObjectAlarm()`.

## Overview

- **Automatic alarm execution**: Alarms fire automatically based on scheduled time
- **Transparent mocking**: Use standard `ctx.storage.setAlarm()` API - no special test-only APIs
- **Configurable speed**: Run alarm timers 100x faster for quick tests (configurable)
- **Full retry simulation**: Includes Cloudflare's exponential backoff retry behavior
- **Simple alarm cases**: Works reliably for single alarms and sequential scheduling

## How It Works

When you call `instrumentDOProject()`, alarm simulation is automatically enabled:

1. **Intercepts alarm methods**: Wraps `ctx.storage.setAlarm()`, `getAlarm()`, and `deleteAlarm()`
2. **Schedules `setTimeout()`**: Uses JavaScript `setTimeout` to trigger the `alarm()` handler
3. **Time scaling**: Speeds up delays by 100x (e.g., 10-second alarm fires in 100ms)
4. **Retry logic**: Automatically retries failed `alarm()` handlers with exponential backoff

## Basic Usage

### Define Your Durable Object

Write your DO with standard alarm methods:

```typescript @check-example('packages/testing/test/alarm-simulation/my-do.ts')
export class MyDO {
  ctx: DurableObjectState;
  env: Env;
  taskStatus: string = 'idle';
  // ...

  constructor(ctx: DurableObjectState, env: Env) {
    this.ctx = ctx;
    this.env = env;
  }

  // Standard Cloudflare alarm handler
  async alarm() {
    // ...
    this.taskStatus = 'processing';
    await this.processScheduledTask();
    this.taskStatus = 'complete';
    // ...
  }

  scheduleTask(delaySeconds: number) {
    // Standard Cloudflare alarm API
    const scheduledTime = Date.now() + (delaySeconds * 1000);
    this.ctx.storage.setAlarm(scheduledTime);
  }

  async processScheduledTask() {
    // Your task logic here
  }
  // ...
}
```

### Write Your Test

Alarms fire automatically - just wait for them:

```typescript @check-example('packages/testing/test/alarm-simulation/basic-usage.test.ts')
import { it, expect, vi } from 'vitest';
import { createTestingClient } from '@lumenize/testing';
import { MyDO } from '../src';

it('automatically fires scheduled alarms', async () => {
  await using client = createTestingClient<typeof MyDO>('MY_DO', 'alarm-test');

  // Schedule an alarm for 10 seconds in the future
  await client.scheduleTask(10);

  // Verify alarm was scheduled
  const state = await client.getAlarmState();
  expect(state.scheduledTime).not.toBeNull();

  // Wait for alarm to fire (100x faster = 100ms in test time)
  await vi.waitFor(async () => {
    const status = await client.taskStatus;
    expect(status).toBe('complete');
  }, { timeout: 200 }); // Give it 200ms buffer

  // Verify alarm completed
  expect(await client.taskStatus).toBe('complete');
});
```

## Time Scaling

By default, alarms run **100x faster** during tests:
- Real alarm: 10 seconds → Test time: 100ms
- Real alarm: 1 minute → Test time: 600ms

This makes tests fast while preserving timing relationships.

### Custom Time Scale

Configure the time scale when instrumenting your DO:

```typescript @skip-check
// test/test-harness.ts
import * as sourceModule from '../src';
import { instrumentDOProject } from '@lumenize/testing';

const instrumented = instrumentDOProject({
  sourceModule,
  doClassNames: ['MyDO'],
  simulateAlarms: {
    timeScale: 10,  // 10x faster (instead of default 100x)
    maxRetries: 6,  // Maximum retry attempts (default: 6)
    debug: true     // Enable debug logging
  }
});

export const { MyDO } = instrumented.dos;
export default instrumented;
```

### Disable Alarm Simulation

If you need to disable alarm simulation:

```typescript @skip-check
const instrumented = instrumentDOProject({
  sourceModule,
  doClassNames: ['MyDO'],
  simulateAlarms: false  // Disable alarm simulation
});
```

## Testing Alarm Cancellation/Overwriting

When testing scenarios where you **rapidly schedule multiple alarms** and expect the second to overwrite the first, use **WebSocket transport** to maintain a persistent connection:

```typescript @skip-check
// For rapid sequential alarm operations that need state persistence
await using client = createTestingClient<typeof MyDO>('MY_DO', 'test', {
  transport: 'websocket'
});

// First alarm scheduled
await client.scheduleTask(10);

// Second alarm immediately overwrites first (needs persistent connection)
await client.scheduleTask(5);

// Only the second alarm fires
await vi.waitFor(async () => {
  expect(await client.taskStatus).toBe('complete');
});
```

**Why WebSocket?** With HTTP transport (the default), each RPC call can hit a fresh DO execution context. For rapid sequential calls, both alarms might get scheduled instead of the second overwriting the first. WebSocket maintains a persistent connection to the same DO instance.

:::tip
This pattern applies to **any test with rapid sequential state changes**, not just alarms. For most alarm tests (schedule one, wait for it to fire), HTTP transport works perfectly and is faster.
:::

## Alarm Retry Behavior

The simulation matches Cloudflare's retry behavior:

1. **If `alarm()` throws**: Automatically retries with exponential backoff
2. **Retry delays** (Cloudflare's production delays):
   - Retry 1: 2 seconds
   - Retry 2: 4 seconds
   - Retry 3: 8 seconds
   - Retry 4: 16 seconds
   - Retry 5: 32 seconds
   - Retry 6: 64 seconds
3. **In tests** (with 100x speedup):
   - Retry 1: 20ms
   - Retry 2: 40ms
   - Retry 3: 80ms
   - Retry 4: 160ms
   - Retry 5: 320ms
   - Retry 6: 640ms
4. **After 6 retries**: Gives up (matches Cloudflare behavior)

### Testing Retry Behavior

```typescript @check-example('packages/testing/test/alarm-simulation/retry-behavior.test.ts')
it('retries failed alarms with exponential backoff', async () => {
  await using client = createTestingClient<typeof MyDO>('MY_DO', 'retry-test');

  // Make the alarm fail twice, then succeed
  await client.setAlarmFailureCount(2);

  // Schedule alarm
  await client.scheduleTask(1); // 1 second = 10ms in test time

  // Wait for retries to complete
  // First attempt (10ms) + Retry 1 (20ms) + Retry 2 (40ms) + buffer
  await vi.waitFor(async () => {
    const status = await client.taskStatus;
    expect(status).toBe('complete');
  }, { timeout: 150 });

  // Verify it succeeded after retries
  expect(await client.alarmRetryCount).toBe(2);
  expect(await client.taskStatus).toBe('complete');
});
```

## Single Alarm Limitation

Cloudflare allows **only one alarm per Durable Object**. Setting a new alarm overwrites the previous one:

```typescript @check-example('packages/testing/test/alarm-simulation/single-alarm.test.ts')
it('new alarm overwrites pending alarm', async () => {
  await using client = createTestingClient<typeof MyDO>('MY_DO', 'overwrite');

  // Schedule first alarm for 10 seconds
  await client.scheduleTask(10); // 100ms in test time
  const firstAlarmTime = await client.getAlarmTime();

  // Schedule second alarm for 5 seconds (overwrites first)
  await client.scheduleTask(5); // 50ms in test time
  const secondAlarmTime = await client.getAlarmTime();

  expect(secondAlarmTime).not.toBeNull();
  expect(firstAlarmTime).not.toBeNull();
  expect(secondAlarmTime).not.toBe(firstAlarmTime);
  expect(secondAlarmTime!).toBeLessThan(firstAlarmTime!);

  // Only the second alarm fires
  await vi.waitFor(async () => {
    expect(await client.alarmFiredCount).toBe(1);
  }, { timeout: 100 });
});
```

## Multiplexed Alarms with `@cloudflare/actors`

The simulation works seamlessly with `@cloudflare/actors` Alarms, which multiplexes multiple logical alarms over Cloudflare's single native alarm:

```typescript @check-example('packages/testing/test/alarm-simulation/scheduler-do.ts')
import { Actor } from '@cloudflare/actors';

export class SchedulerDO extends Actor<Env> {
  // ...
  
  // Required: delegate to Actor's alarm system
  async alarm() {
    await this.alarms.alarm();
  }

  // Your alarm handler
  async handleAlarm(payload: any) {
    // ...
  }

  async scheduleMultiple() {
    // Actor Alarms lets you schedule multiple alarms
    await this.alarms.schedule(5, 'handleAlarm', { task: 'first' });
    await this.alarms.schedule(10, 'handleAlarm', { task: 'second' });
    await this.alarms.schedule(15, 'handleAlarm', { task: 'third' });
    
    // All three will fire automatically in tests!
  }
  
  // ...
}
```

### Testing with Actor Alarms

For DOs using Actor Alarms, use **1x time scale** to avoid conflicts with Actor's internal scheduling logic:

```typescript @skip-check
// test/test-harness.ts
import * as sourceModule from '../src';
import { instrumentDOProject } from '@lumenize/testing';

const instrumented = instrumentDOProject({
  sourceModule,
  doClassNames: ['SchedulerDO'],
  simulateAlarms: { timeScale: 1 }  // 1x speed for Actor Alarms
});

export const { SchedulerDO } = instrumented.dos;
export default instrumented;
```

Test:

```typescript @check-example('packages/testing/test/alarm-simulation/actor-alarms.test.ts')
it('handles multiple Actor alarms automatically', // ...
  await using client = createTestingClient<typeof SchedulerDO>(
    'SCHEDULER_DO',
    'multi-alarms'
  );

  // Schedule multiple alarms
  await client.scheduleMultiple();

  // Wait for all alarms to fire (1x speed = real time)
  await vi.waitFor(async () => {
    const firedCount = await client.getAlarmsFiredCount();
    expect(firedCount).toBe(3);
  }, { timeout: 20000 }); // 20 seconds for 15-second max delay

  // Verify all fired
  expect(await client.getAlarmsFiredCount()).toBe(3);
});
```

## API Reference

### `instrumentDOProject` Options

```typescript @skip-check
interface AlarmSimulationConfig {
  /**
   * Time scale factor for alarm delays
   * @default 100 (alarms run 100x faster)
   * @example timeScale: 10 means 10x faster
   */
  timeScale?: number;

  /**
   * Maximum number of retry attempts
   * @default 6 (matches Cloudflare)
   */
  maxRetries?: number;

  /**
   * Enable debug logging
   * @default false
   */
  debug?: boolean;
}

instrumentDOProject({
  sourceModule,
  doClassNames: ['MyDO'],
  simulateAlarms: true | false | AlarmSimulationConfig
})
```

### Cloudflare Alarm API (Standard)

Your DO uses the standard Cloudflare APIs:

```typescript @skip-check
// Set an alarm
this.ctx.storage.setAlarm(Date.now() + 10000); // 10 seconds

// Get scheduled alarm time (null if none)
const scheduledTime: number | null = this.ctx.storage.getAlarm();

// Cancel scheduled alarm
this.ctx.storage.deleteAlarm();

// Alarm handler (called automatically)
async alarm() {
  // Your alarm logic
}
```

## Important Notes

### Clock Behavior in Durable Objects

Durable Objects have a "frozen clock" where `Date.now()` doesn't advance during execution. However, `setTimeout()` still works, which is how the simulation functions.

The simulation:
- ✅ Uses `Date.now()` at `setAlarm()` time to calculate delay
- ✅ Uses `setTimeout()` to schedule the alarm
- ✅ Calls your `alarm()` handler at the right time
- ✅ Supports `ctx.waitUntil()` to keep the DO context alive

### Why Not Use `runDurableObjectAlarm()`?

Cloudflare's `runDurableObjectAlarm()` from `cloudflare:test` requires manual invocation:

```typescript @skip-check
// ❌ Old way - manual and verbose
import { runDurableObjectAlarm } from 'cloudflare:test';

await client.scheduleTask(10);
await runDurableObjectAlarm(doInstance); // Must manually trigger
```

```typescript @skip-check
// ✅ New way - automatic and intuitive
await client.scheduleTask(10);
await vi.waitFor(() => {
  expect(client.taskStatus).toBe('complete');
});
```

## Known Limitations

### Multiplexed Alarm Timing Issues

When using packages that multiplex Cloudflare's single alarm to handle multiple scheduled tasks (like `@cloudflare/actors` Alarms or `@lumenize/alarms`), you may encounter timing issues when scheduling many alarms in quick succession.

**Why this happens:**
- Cloudflare provides only one native alarm per Durable Object
- Alarm packages schedule/reschedule this single alarm to handle multiple tasks
- Simulation must track clock time to know when to fire alarms
- With many rapid `setAlarm()` calls, timing can become unpredictable

**Symptoms:**
- Tests timeout waiting for alarms to fire
- Alarms fire but callbacks don't execute as expected
- Works fine with 1-3 alarms but fails with many

This is an **environmental limitation** of the test simulation, not a functional issue with the alarm packages themselves.

## Workarounds

### Option 1: Use `triggerAlarms()` (Recommended)

If using `@lumenize/alarms`, use the built-in `triggerAlarms()` method to manually execute alarms:

```typescript @check-example('packages/testing/test/alarm-workarounds/alarm-workarounds.test.ts')
describe('Alarm Execution', () => {
  it('executes scheduled tasks', async () => {
    const stub = env.MY_DO.getByName('alarm-test');
    
    // Schedule alarms
    await stub.scheduleTask('task1', 10);
    await stub.scheduleTask('task2', 20);
    
    // Manually trigger alarms (fast-forward instead of waiting)
    const executed = await stub.triggerAlarms(2);
    expect(executed.length).toBe(2);
    
    // Verify execution
    const results = await stub.getExecutedTasks();
    expect(results).toHaveLength(2);
  });
});
```

**Benefits:**
- ✅ No timing issues
- ✅ Tests are fast and reliable
- ✅ Works via RPC (no special imports)
- ✅ Can fast-forward through future alarms
- ✅ Tests actual scheduling and execution logic

See [@lumenize/alarms Testing section](/docs/alarms#testing-alarms) for more details.

### Option 2: Test Alarm Handlers Directly via RPC

For plain Durable Objects or custom alarm systems, test callback handlers directly:

```typescript @skip-check
import { createTestingClient } from '@lumenize/testing';

describe('Alarm Handlers', () => {
  it('handles scheduled task correctly', async () => {
    const client = await createTestingClient(env.MY_DO.getByName('handler-test'));
    
    // Call your alarm handler directly via RPC
    await client.handleAlarm({ task: 'process-data' }, mockSchedule);
    
    // Verify the handler worked
    const result = await client.getTaskResult();
    expect(result.status).toBe('completed');
  });
});
```

**Benefits:**
- ✅ No timing issues
- ✅ Tests are fast and reliable
- ✅ Full control over handler inputs
- ✅ Works for testing alarm callback logic

**Limitations:**
- ❌ Doesn't test the actual scheduling mechanism
- ❌ Doesn't verify alarm timing
- ❌ Can't test alarm multiplexing logic

### Option 3: Use `runDurableObjectAlarm()` from `cloudflare:test`

For comprehensive alarm testing, use Cloudflare's built-in test helper:

```typescript @check-example('packages/testing/test/alarm-workarounds/alarm-workarounds.test.ts')
import { runDurableObjectAlarm } from 'cloudflare:test';

it('triggers all pending alarms', async () => {
  const stub = env.MY_DO.getByName('alarm-test');
  
  // Schedule alarms
  await stub.scheduleTask(10);
  await stub.scheduleTask(20);
  
  // Manually trigger alarm execution
  await runDurableObjectAlarm(stub);
  
  // Verify alarms fired
  const executed = await stub.getExecutedAlarms();
  expect(executed.length).toBeGreaterThan(0);
});
```

**Benefits:**
- ✅ Triggers all pending alarms at once
- ✅ More reliable than timing simulation
- ✅ Official Cloudflare testing API

**Limitations:**
- ❌ Manual invocation required
- ❌ Doesn't test actual timing
- ❌ All alarms fire at once (not sequential)


## See Also

- [Testing Usage](/docs/testing/usage) - General testing patterns
- [RPC Downstream Messaging](/docs/rpc/downstream-messaging) - Real-time communication
- [Cloudflare Alarms Documentation](https://developers.cloudflare.com/durable-objects/api/alarms/) - Official alarm API reference

