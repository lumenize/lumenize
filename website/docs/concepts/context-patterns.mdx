---
title: Context Patterns
description: Comparing AsyncLocalStorage with OCAN closures for maintaining context across async operations
---

# Context Patterns: AsyncLocalStorage vs OCAN Closures

When working with asynchronous operations in Durable Objects, you often need to maintain context—information from the call site that needs to be available when the async operation completes. This guide compares two approaches: AsyncLocalStorage (from Node.js/Cloudflare agents) and OCAN closures (Lumenize's approach).

## The Context Problem

Consider this common scenario:

```typescript
// You have context at the call site
const requestId = crypto.randomUUID();
const startTime = Date.now();

// You kick off an async operation
await proxyFetchWorker(this, url, this.ctn().handleResult(this.ctn().$result));

// ❓ How does handleResult access requestId and startTime?
async handleResult(result: Response) {
  // Need requestId and startTime here...
}
```

## Solution 1: AsyncLocalStorage (Node.js/Cloudflare Agents)

AsyncLocalStorage creates an "async context" that follows execution through callbacks and promises:

```typescript
import { AsyncLocalStorage } from 'node:async_hooks';

const context = new AsyncLocalStorage();

async handleRequest() {
  const requestId = crypto.randomUUID();
  const startTime = Date.now();
  
  // Store in async local storage
  await context.run({ requestId, startTime }, async () => {
    await proxyFetch(this, url);
  });
}

async handleResult(result: Response) {
  // Retrieve from async local storage
  const ctx = context.getStore();
  const requestId = ctx?.requestId;
  const startTime = ctx?.startTime;
}
```

### AsyncLocalStorage Drawbacks

**1. Type Safety Issues**
```typescript
const ctx = context.getStore(); // Returns: any | undefined
const requestId = ctx?.requestId; // Runtime access, no autocomplete
```

**2. Magic Global State**
```typescript
// Where does context come from? What's in it?
const ctx = context.getStore();
// No way to know without reading distant code
```

**3. Runtime Errors**
```typescript
const ctx = context.getStore();
// Typo won't be caught by TypeScript
const id = ctx?.requsetId; // undefined at runtime!
```

**4. Breaking DO Consistency (Critical)**

AsyncLocalStorage relies on Node.js's async tracking mechanism. Cloudflare's Durable Objects use **input/output gates** for consistency:

- When you use `async/await` in a DO method, you break the input/output gate
- This allows race conditions between concurrent requests
- AsyncLocalStorage + async handlers = consistency violations

**5. Performance Overhead**

AsyncLocalStorage maintains a context chain through the entire async execution, adding overhead to every async operation.

## Solution 2: OCAN Closures (Lumenize)

OCAN uses standard JavaScript closures to capture context:

```typescript
async handleRequest() {
  const requestId = crypto.randomUUID();
  const startTime = Date.now();
  
  // Context captured in closure
  await proxyFetchWorker(
    this,
    url,
    this.ctn().handleResult(this.ctn().$result, requestId, startTime)
  );
}

async handleResult(result: Response, requestId: string, startTime: number) {
  // Context available as typed parameters
  console.log('Request', requestId, 'took', Date.now() - startTime, 'ms');
}
```

### OCAN Advantages

**1. Full Type Safety**
```typescript
// TypeScript knows exactly what's available
async handleResult(
  result: Response,      // ← Autocomplete works
  requestId: string,     // ← Type-checked
  startTime: number      // ← Compile-time errors for typos
) {
  // All parameters are typed and validated
}
```

**2. Explicit Data Flow**
```typescript
// Crystal clear what context is being passed
this.ctn().handleResult(this.ctn().$result, requestId, startTime)
// No hidden global state, no mystery about what's available
```

**3. Standard JavaScript**
```typescript
// Just closures - a fundamental JavaScript concept
const capturedValue = "hello";
const fn = () => console.log(capturedValue);
// Every JS developer already understands this
```

**4. Preserves DO Consistency**

OCAN handlers are **synchronous** (except for the required async handlers like `fetch()`):

```typescript
// Synchronous handler preserves input/output gates
handleResult(result: Response, requestId: string) {
  // No async/await = no consistency issues
  this.ctx.storage.kv.put(`result:${requestId}`, result);
}
```

The only `async` is in the background work (fetch, RPC calls), which is correctly isolated.

**5. Zero Runtime Overhead**

Closures are compiled away—no performance penalty for context capture.

## Side-by-Side Comparison

### Scenario: Tracking fetch metrics per request

**AsyncLocalStorage:**
```typescript
import { AsyncLocalStorage } from 'node:async_hooks';

const requestContext = new AsyncLocalStorage();

class MyDO extends DurableObject {
  async fetch(request: Request) {
    const requestId = crypto.randomUUID();
    const metrics = { startTime: Date.now(), fetchCount: 0 };
    
    return await requestContext.run({ requestId, metrics }, async () => {
      await this.doWork();
      return new Response('OK');
    });
  }
  
  async doWork() {
    // Get context from storage
    const ctx = requestContext.getStore() as any;
    ctx.metrics.fetchCount++;
    
    await fetch('https://api.example.com/data');
    
    // Log metrics
    console.log(`Request ${ctx.requestId}: ${ctx.metrics.fetchCount} fetches`);
  }
}
```

**OCAN Closures:**
```typescript
class MyDO extends LumenizeBase {
  async fetch(request: Request) {
    const requestId = crypto.randomUUID();
    const metrics = { startTime: Date.now(), fetchCount: 0 };
    
    this.doWork(requestId, metrics);
    return new Response('OK');
  }
  
  doWork(requestId: string, metrics: { startTime: number; fetchCount: number }) {
    metrics.fetchCount++;
    
    // Context explicitly passed, fully typed
    await proxyFetchWorker(
      this,
      'https://api.example.com/data',
      this.ctn().handleFetchResult(this.ctn().$result, requestId, metrics)
    );
  }
  
  handleFetchResult(
    result: Response,
    requestId: string,
    metrics: { startTime: number; fetchCount: number }
  ) {
    // All context available with type safety
    console.log(`Request ${requestId}: ${metrics.fetchCount} fetches`);
    console.log(`Total time: ${Date.now() - metrics.startTime}ms`);
  }
}
```

### Key Differences

| Feature | AsyncLocalStorage | OCAN Closures |
|---------|------------------|---------------|
| **Type Safety** | ❌ Runtime access (`any`) | ✅ Compile-time typed |
| **Explicitness** | ❌ Magic global state | ✅ Clear parameter passing |
| **DO Consistency** | ⚠️ Breaks with async handlers | ✅ Preserves via sync handlers |
| **Performance** | ⚠️ Runtime tracking overhead | ✅ Zero overhead |
| **Learning Curve** | ⚠️ New API to learn | ✅ Standard closures |
| **Debugging** | ❌ Hard to trace context flow | ✅ Clear in stack traces |
| **IDE Support** | ❌ No autocomplete | ✅ Full autocomplete |

## Migration from AsyncLocalStorage

If you're coming from Cloudflare's agents package or Node.js:

### Before (AsyncLocalStorage):
```typescript
const context = new AsyncLocalStorage();

await context.run({ userId, sessionId }, async () => {
  await doSomething();
});

function doSomething() {
  const ctx = context.getStore();
  console.log(ctx.userId);
}
```

### After (OCAN):
```typescript
// Capture context in continuation
await someAsyncOperation(
  this.ctn().handleResult(this.ctn().$result, userId, sessionId)
);

handleResult(result: any, userId: string, sessionId: string) {
  console.log(userId); // Typed and explicit
}
```

## Common Patterns

### Pattern 1: Request Tracking

```typescript
async fetch(request: Request) {
  const reqId = crypto.randomUUID();
  const startTime = Date.now();
  
  // Capture tracking context
  await proxyFetchWorker(
    this,
    'https://api.example.com/data',
    this.ctn().trackRequest(this.ctn().$result, reqId, startTime)
  );
  
  return new Response('Processing...');
}

trackRequest(result: Response | Error, reqId: string, startTime: number) {
  const duration = Date.now() - startTime;
  this.ctx.storage.kv.put(`metrics:${reqId}`, { duration, success: !(result instanceof Error) });
}
```

### Pattern 2: User Context

```typescript
async handleUserAction(userId: string, action: string) {
  // User context flows through closure
  await call(
    this,
    this.env.SOME_DO,
    'processAction',
    [action],
    this.ctn().onActionComplete(this.ctn().$result, userId, action)
  );
}

onActionComplete(result: any, userId: string, action: string) {
  console.log(`User ${userId} completed ${action}`);
  this.notifyUser(userId, result);
}
```

### Pattern 3: Batch Operations

```typescript
async processBatch(items: Item[]) {
  for (const item of items) {
    // Each item's context captured independently
    await proxyFetchWorker(
      this,
      item.url,
      this.ctn().handleItemResult(this.ctn().$result, item.id, item.retryCount)
    );
  }
}

handleItemResult(result: Response | Error, itemId: string, retryCount: number) {
  if (result instanceof Error && retryCount < 3) {
    // Context available for retry logic
    this.retryItem(itemId, retryCount + 1);
  }
}
```

## Why This Matters for Durable Objects

Durable Objects are designed around **single-threaded consistency**:

1. **Input gate opens** → Request starts processing
2. **Synchronous code runs** → Mutations are safe
3. **Async operation starts** → Input gate closes, next request can enter
4. **Async operation completes** → Callback runs, input gate reopens

**AsyncLocalStorage + async handlers** breaks this model:
- Async handlers can interleave with other requests
- Race conditions become possible
- Consistency guarantees are lost

**OCAN + sync handlers** preserves this model:
- Handlers run synchronously when async work completes
- No interleaving with other requests
- Consistency guarantees maintained

## Conclusion

While AsyncLocalStorage is familiar to Node.js developers, **OCAN closures are better suited to Durable Objects**:

- ✅ **Type-safe** - Compile-time errors, not runtime surprises
- ✅ **Explicit** - Clear data flow, easy to debug
- ✅ **Consistent** - Preserves DO consistency guarantees
- ✅ **Performant** - Zero runtime overhead
- ✅ **Standard** - Uses fundamental JavaScript concepts

The pattern requires a small "aha moment" to discover, but once you see it, it's simpler and more powerful than AsyncLocalStorage.

## Further Reading

- [Continuations Guide](/docs/concepts/continuations) - Deep dive into OCAN patterns
- [Durable Objects Consistency](/docs/guides/do-consistency) - Understanding DO consistency guarantees
- [@lumenize/call](/docs/call) - DO-to-DO communication with continuations
- [@lumenize/alarms](/docs/alarms) - Scheduled tasks with continuations
- [@lumenize/proxy-fetch](/docs/proxy-fetch) - External API calls with continuations

