---
title: Managing Context
description: Understanding the Dual-Context Strategy in Lumenize - AsyncLocalStorage vs. Continuations
---

# Managing Context

When working with asynchronous operations in Durable Objects, you often need to maintain **context**—information from the call site that needs to be available when the async operation completes.

Lumenize uses a **Dual-Context Strategy** to handle this problem:
1. **Framework Context (`AsyncLocalStorage`)**: For infrastructure data like identity and auth.
2. **Application Context (Continuations)**: For your specific business logic and data flow.

---

## 1. Framework Context (`AsyncLocalStorage`)

Lumenize uses Node.js's `AsyncLocalStorage` under the hood to manage **Call Context**. This ensures that properties like `this.lmz.callContext` are always accurate for the current request, even across multiple asynchronous hops.

### Why we use it for Infrastructure
*   **Magic-Free Consistency**: You don't have to manually pass auth tokens or caller IDs into every single function. They are "just there" when you need them.
*   **Race-Safe**: Even when multiple requests to the same DO interleave at `await` points, `AsyncLocalStorage` ensures each request sees its own unique context.
*   **Zero Boilerplate**: Framework-level data is propagated automatically by the mesh.

```typescript
// Any method, anywhere in your call chain
@mesh
doSomething() {
  // Always correct for the current request, thanks to AsyncLocalStorage
  const user = this.lmz.callContext.originAuth?.userId;
}
```

---

## 2. Application Context (Continuations)

While `AsyncLocalStorage` is great for infrastructure, Lumenize strongly recommends using **Continuations** for your own application data.

### The Problem with ALH for Applications
If you try to use `AsyncLocalStorage` for your business logic (like passing a `requestId` or `startTime`), you run into several issues:
1.  **Type Safety**: ALH stores are typically untyped (`any`).
2.  **Explicitness**: It creates "magic global state" that is hard to trace during debugging.
3.  **Consistency Risk**: ALH encourages using `async/await` in your handlers, which breaks Durable Object input/output gates and leads to race conditions.

### The Better Way: Continuations
Continuations capture context using standard JavaScript closures and pass them as explicit parameters to your handlers.

```typescript
// 1. Capture context at the call site
const startTime = Date.now();

this.lmz.call(
  'TARGET_DO', 
  id, 
  this.ctn<TargetDO>().process(),
  this.ctn().handleResult(startTime) // capture context
);

// 2. Access context in the handler - fully typed and explicit
handleResult(result: any | Error, startTime: number) {
  console.log(`Operation took ${Date.now() - startTime}ms`);
}
```

---

## Side-by-Side Comparison

| Feature | AsyncLocalStorage (Infrastructure) | Continuations (Application) |
| :--- | :--- | :--- |
| **Best For** | Auth, Identity, Trace IDs | Business IDs, Timestamps, Retry counts |
| **Type Safety** | ❌ Runtime access (`any`) | ✅ Compile-time typed |
| **Explicitness** | ❌ Implicit/Global | ✅ Explicit/Parameters |
| **Hibernation** | ✅ **Automatic** (captured in continuations) | ✅ **Automatic** (serialized with continuation) |
| **DO Consistency**| ⚠️ Risk if handlers use `await` | ✅ Safe (encourages sync handlers) |

---

## Hibernation & Long-Running Operations

Durable Objects can hibernate (evict from memory) at any time, especially during long-running asynchronous operations like the **"Two One-Way Call"** pattern used in `@lumenize/fetch`.

### Automatic Context Preservation

Lumenize **automatically captures `callContext`** when you create a continuation. When the continuation executes (even after hibernation), the context is restored before your handler runs.

```typescript
// You write this - no manual context capture needed!
this.lmz.call(
  'TARGET_DO',
  id,
  this.ctn<TargetDO>().longRunningProcess(),
  this.ctn().handleResult(this.ctn().$result)
);

// ... DO hibernates during the long-running call ...
// ... Result arrives later ...

// Your handler runs with callContext automatically restored
handleResult(result: any | Error) {
  // this.lmz.callContext is correct! No manual capture required.
  const userId = this.lmz.callContext.originAuth?.userId;
  console.log(`Result for ${userId}:`, result);
}
```

This "just works" because:
1. When `this.ctn()` is serialized for dispatch, it snapshots the current `callContext`.
2. When the continuation executes, the context is restored before your handler runs.
3. `this.lmz.callContext` reads from this restored context.

### Manual Persistence (For Power Users)
If you are building your own hibernation-safe functionality outside the mesh, you can manually serialize a continuation using the internal utilities:

```typescript
import { getOperationChain } from '@lumenize/mesh';
import { stringify } from '@lumenize/structured-clone';

// 1. Get the serializable OCAN chain (includes captured callContext)
const chain = getOperationChain(this.ctn().myHandler(data));

// 2. Stringify it (supports Dates, Maps, Sets, etc.)
const serialized = stringify(chain);  // Necessary for SQL. Optional for KV

// 3. Save to your own SQL or KV storage
this.ctx.storage.kv.put('my-key', serialized);
```

---

## Why This Matters for Durable Objects

Durable Objects are designed around **single-threaded consistency**. The choice of context management directly impacts this:

### The "Await" Quirk
Every time you `await` in a Durable Object, you yield execution. This opens the input "gate" and allows other requests to enter. If your handler is `async`, you risk data corruption if you don't carefully manage state transitions.

### The "Continuation" Advantage
Continuation handlers are **synchronous** by design. When a remote call completes, Lumenize executes your handler immediately. Because there is no `await` inside the handler, no other request can interleave, ensuring your mutations are atomic and safe.

---

## Conclusion: The Golden Rule

> **"Let Lumenize handle the Mesh context via `this.lmz`; handle your own application context via `.ctn().handler(context)`."**

By following this strategy, you get the best of both worlds: the zero-boilerplate convenience of a mesh and the rock-solid reliability of type-safe, synchronous Durable Objects.

## Further Reading
*   [Continuations Guide](./continuations) - Deep dive into continuation patterns
*   [Lumenize Mesh: Auth Integration](../lumenize-mesh/auth-integration) - How Call Context works
*   [Durable Objects Consistency](../guides/do-consistency) - Understanding consistency guarantees
