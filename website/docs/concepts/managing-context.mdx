---
title: Managing Context
description: Understanding the Dual-Context Strategy in Lumenize - AsyncLocalStorage vs. Continuations
---

# Managing Context

When working with asynchronous operations in Durable Objects, you often need to maintain **context**—information from the call site that needs to be available when the async operation completes.

Lumenize uses a **Dual-Context Strategy** to handle this problem:
1. **Framework Context (`AsyncLocalStorage`)**: For infrastructure data like identity and auth.
2. **Application Context (Continuations)**: For your specific business logic and data flow.

---

## 1. Framework Context (`AsyncLocalStorage`)

Lumenize uses Node.js's `AsyncLocalStorage` under the hood to manage **Call Context**. This ensures that properties like `this.lmz.callContext` are always accurate for the current request, even across multiple asynchronous hops.

### Why we use it for Infrastructure
*   **Magic-Free Consistency**: You don't have to manually pass auth tokens or caller IDs into every single function. They are "just there" when you need them.
*   **Race-Safe**: Even when multiple requests to the same DO interleave at `await` points, `AsyncLocalStorage` ensures each request sees its own unique context.
*   **Zero Boilerplate**: Framework-level data is propagated automatically by the mesh.

```typescript
// Any method, anywhere in your call chain
@mesh
doSomething() {
  // Always correct for the current request, thanks to AsyncLocalStorage
  const user = this.lmz.callContext.originAuth?.userId;
}
```

---

## 2. Application Context (Continuations)

While `AsyncLocalStorage` is great for infrastructure, Lumenize strongly recommends using **Continuations** for your own application data.

### The Problem with ALH for Applications
If you try to use `AsyncLocalStorage` for your business logic (like passing a `requestId` or `startTime`), you run into several issues:
1.  **Type Safety**: ALH stores are typically untyped (`any`).
2.  **Explicitness**: It creates "magic global state" that is hard to trace during debugging.
3.  **Consistency Risk**: ALH encourages using `async/await` in your handlers, which breaks Durable Object input/output gates and leads to race conditions.

### The Better Way: Continuations
Continuations capture context using standard JavaScript closures and pass them as explicit parameters to your handlers.

```typescript
// 1. Capture context at the call site
const startTime = Date.now();

this.lmz.call(
  'TARGET_DO', 
  id, 
  this.ctn<TargetDO>().process(),
  this.ctn().handleResult(startTime) // capture context
);

// 2. Access context in the handler - fully typed and explicit
handleResult(result: any | Error, startTime: number) {
  console.log(`Operation took ${Date.now() - startTime}ms`);
}
```

---

## Side-by-Side Comparison

| Feature | AsyncLocalStorage (Infrastructure) | Continuations (Application) |
| :--- | :--- | :--- |
| **Best For** | Auth, Identity, Trace IDs | Business IDs, Timestamps, Retry counts |
| **Type Safety** | ❌ Runtime access (`any`) | ✅ Compile-time typed |
| **Explicitness** | ❌ Implicit/Global | ✅ Explicit/Parameters |
| **Hibernation** | ❌ **Lost** on DO restart | ⚠️ **Only if** using a persisted service |
| **DO Consistency**| ⚠️ Risk if handlers use `await` | ✅ Safe (encourages sync handlers) |

---

## Hibernation & Long-Running Operations

Durable Objects can hibernate (evict from memory) at any time, especially during long-running asynchronous operations like the **"Two One-Way Call"** pattern used in `@lumenize/fetch`.

### The Hibernation Rule
*   **`this.lmz.callContext`** is in-memory only. It is lost if the DO hibernates.
*   **`this.lmz.call()`** by default is also lost if the DO hibernates while waiting for a response.
*   **Continuations** are just objects. They are only "hibernation-safe" if they are used with a service that explicitly persists them to storage (like `@lumenize/alarms`).

### How to Persist Context
If you are building a long-running process that must survive hibernation (e.g., waiting for a multi-minute download or a human approval), you should use the **explicit persistence** pattern:

1.  **Capture the context** as an argument in your continuation.
2.  **Use a persisted service** like `@lumenize/alarms` to "park" the continuation in storage.

```typescript
// 1. Capture the callContext in the continuation.
// Passing it to svc.alarms.schedule stores the entire chain 
// (including arguments) in the DO's SQL storage.
this.svc.alarms.schedule(
  60, // delay in seconds
  this.ctn().handleCompletion(this.lmz.callContext) 
);

// ... DO hibernates ... 
// ... Alarm fires later ...

// 2. The handler receives the persisted context.
handleCompletion(originalContext: CallContext) {
  // originalContext was restored from storage!
  const userId = originalContext.originAuth?.userId;
}
```

### Manual Persistence (For Power Users)
If you are building your own hibernation-safe functionality, you can manually serialize a continuation using the internal utilities:

```typescript
import { getOperationChain } from '@lumenize/lumenize-base';
import { stringify } from '@lumenize/structured-clone';

// 1. Get the serializable OCAN chain
const chain = getOperationChain(this.ctn().myHandler(data));

// 2. Stringify it (supports Dates, Maps, Sets, etc.)
const serialized = stringify(chain);  // Necessary for SQL. Optional for KV

// 3. Save to your own SQL or KV storage
this.ctx.storage.kv.put('my-key', serialized);
```

---

## Why This Matters for Durable Objects

Durable Objects are designed around **single-threaded consistency**. The choice of context management directly impacts this:

### The "Await" Quirk
Every time you `await` in a Durable Object, you yield execution. This opens the input "gate" and allows other requests to enter. If your handler is `async`, you risk data corruption if you don't carefully manage state transitions.

### The "Continuation" Advantage
Continuation handlers are **synchronous** by design. When a remote call completes, Lumenize executes your handler immediately. Because there is no `await` inside the handler, no other request can interleave, ensuring your mutations are atomic and safe.

---

## Conclusion: The Golden Rule

> **"Let Lumenize handle the Mesh context via `this.lmz`; handle your own application context via `.ctn().handler(context)`."**

By following this strategy, you get the best of both worlds: the zero-boilerplate convenience of a mesh and the rock-solid reliability of type-safe, synchronous Durable Objects.

## Further Reading
*   [Continuations Guide](./continuations) - Deep dive into continuation patterns
*   [Lumenize Mesh: Auth Integration](../lumenize-mesh/auth-integration) - How Call Context works
*   [Durable Objects Consistency](../guides/do-consistency) - Understanding consistency guarantees
