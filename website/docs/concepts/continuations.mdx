---
title: Continuations
description: Non-blocking async operations with type-safe callbacks for Durable Objects
---

# Continuations

A **Continuation** is a **description of work** that gets executed in some other place or time usually during/after some native async operation.

Here is an example of how Lumenize Mesh's `this.lmz.call` uses them:
```
const remote = this.ctn<RemoteDO>().getUserData(userId);
const local = this.ctn().handleResult(remote);
this.lmz.call(REMOTE_DO, 'instance-id', remote, local);
```

Continuations:

- Are serializable so can be pushed into storage, an alarms handler, or sent over the wire to be executed in some other Durable Object or Worker
- Can carry arbitrary data that supports almost all types (Dates, Map, Set, cycles, aliases, etc.) allowing you to restore context and continue where you previously left off
- Provide an alternative to using `async`/`await`, which can be problematic for Durable Object's consistency guarantees
- Provide type safety, so you get development-time feedback if you have the method/property name or signature wrong
- Are built with JavaScript Proxy objects and serialize to a well-defined, `JSON.strinigify`-friendly operation chaining and nesting (OCAN) object
- Can encapsulate multiple method calls and property accesses where the output of one operation can be used in another

## The `this.ctn()` Factory

Components that extend `LumenizeBase`, `LumenizeWorker`, or `LumenizeClient` have access to `this.ctn()`, which creates continuation chains:

```typescript @skip-check
// Simple method call
this.ctn().myHandler(this.ctn().$result)

// Chaining
this.ctn().processData(this.ctn().$result).saveToStorage()

// With multiple arguments
this.ctn().updateUser(userId, this.ctn().$result, timestamp)
```

### How It Works

1. **`this.ctn()`** returns a Proxy object
2. Each method/property access builds an **operation chain**
3. The chain can be serialized and sent over the wire or stored as needed
4. When the async operation completes, the chain is executed with the result

## The `$result` Placeholder

The special `$result` property marks where the async operation's result should be injected:

```typescript @skip-check
// $result will be replaced with the actual Response or Error
this.ctn().handleFetchResult(this.ctn().$result)

// You can use it anywhere in the arguments
this.ctn().processWithContext(context, this.ctn().$result, timestamp)
```

### Result Types

:::warning Important
If you don't check for `Error`, your handler might crash when operations fail. Always use `if (result instanceof Error)` at the start of handlers.
:::

Handlers receive a **union type** of the expected result and `Error`:

```typescript @skip-check
// For fetch operations
handleFetchResult(result: ResponseSync | Error) {
  if (result instanceof Error) {
    // Network failure, timeout, etc.
    return;
  }
  
  // Success - process the response
  // ResponseSync has synchronous methods for json() and text()
  const data = result.json();
}

// For DO-to-DO calls
handleRemoteResult(result: any | Error) {
  if (result instanceof Error) {
    // Remote DO threw an error
    return;
  }
  
  // Success - use the result
  console.log('Got:', result);
}
```

## Common Patterns

### 1. Simple Callback

```typescript @skip-check
class MyDO extends LumenizeBase {
  startWork() {
    // this.lmz.call is synchronous on the caller side
    this.lmz.call(
      'REMOTE_DO',
      'instance-id',
      this.ctn<RemoteDO>().remoteMethod(arg),
      this.ctn().handleResult(this.ctn().$result)
    );
  }
  
  handleResult(result: any | Error) {
    if (result instanceof Error) {
      console.error('Call failed:', result.message);
      return;
    }
    
    console.log('Got result:', result);
    this.ctx.storage.kv.put('lastResult', result);
  }
}
```

### 2. Chaining Operations

```typescript @skip-check
class MyDO extends LumenizeBase {
  processData(url: string) {
    // this.svc.fetch.proxy is synchronous
    this.svc.fetch.proxy(
      url,
      // Chain: fetch → parse → validate → save
      this.ctn()
        .parseResponse(this.ctn().$result)
        .validateData()
        .saveToStorage()
    );
  }
  
  parseResponse(result: ResponseSync | Error) {
    if (result instanceof Error) throw result;
    return result.json(); // ResponseSync has sync json()
  }
  
  validateData(data: any) {
    if (!data.id) throw new Error('Invalid data');
    return data;
  }
  
  saveToStorage(data: any) {
    this.ctx.storage.kv.put(`data:${data.id}`, data);
  }
}
```

### 3. Context Preservation

```typescript @skip-check
class MyDO extends LumenizeBase {
  fetchForUser(userId: string, url: string) {
    const timestamp = Date.now();
    
    this.svc.fetch.proxy(
      url,
      // Capture context in the continuation
      this.ctn().handleUserData(userId, this.ctn().$result, timestamp)
    );
  }
  
  handleUserData(userId: string, result: ResponseSync | Error, timestamp: number) {
    if (result instanceof Error) {
      console.error('Fetch failed:', result.message);
      return;
    }
    
    const data = result.json();
    this.ctx.storage.kv.put(`user:${userId}:data`, {
      data,
      timestamp
    });
  }
}
```

## Under the Hood

Continuations use Lumenize's **operation chaining and nesting (OCAN)** See [Lumenize RPC](/docs/rpc/operation-chaining-and-nesting) for a deep dive. While the user-facing API differs, the underlying serialization mechanism is shared.

## Best Practices

- ✅ Check for `Error` first in every handler
- ✅ Use chaining and nesting so more work can be done in a single round trip
- ✅ Preserve context by passing it as arguments
- ❌ Don't use `async` handlers (breaks consistency model)
