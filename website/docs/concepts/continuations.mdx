---
title: Continuations
description: Non-blocking async operations with type-safe callbacks for Durable Objects
---

# Continuations

A **Continuation** is a **description of work** that gets executed in some other place or time usually during/after some native async operation.

Here is an example of how Lumenize's built-in remote procedure call uses them:
```
const remote = this.ctn<RemoteDO>().getUserData(userId);
const local = this.ctn().handleResult(remote);
this.lmz.call(REMOTE_DO, 'instance-id', remote, local);
```

Continuations:

- Are Serializable so can be pushed into storage, an alarms handler, or sent over the wire to be executed in some other Durable Object or Worker.
- Can carry arbitrary data that supports almost all types (Dates, Map, Set, cycles, aliases, etc.). This allows you to restore context and pick up where you left of when returning from an asynchronous operation
- Provide an alternative to using `async`/`await`, which can be problematic for Durable Object's consistency guarantees.
- Provide type safety, so you get development-time feedback if you have the method/property name or signature wrong.
- Are built with JavaScript Proxy objects and serialize to a well-defined, `JSON.strinigify`-friendly operation chaining and nesting (OCAN) object. 
- Can encapsulate multiple method calls and property accesses and where the output of one operation can be used in another

## The `this.ctn()` Factory

Components that extend `LumenizeBase`, `LumenizeWorker`, or `LumenizeClient` has access to `this.ctn()`, which creates continuation chains:

```typescript @skip-check
// Simple method call
this.ctn().myHandler(this.ctn().$result)

// Chaining
this.ctn().processData(this.ctn().$result).saveToStorage()

// With multiple arguments
this.ctn().updateUser(userId, this.ctn().$result, timestamp)
```

### How It Works

1. **`this.ctn()`** returns a Proxy object
2. Each method/property access builds an **operation chain**
3. The chain is serialized and stored
4. When the async operation completes, the chain is executed with the result

## The `$result` Placeholder

The special `$result` property marks where the async operation's result should be injected:

```typescript @skip-check
// $result will be replaced with the actual Response or Error
this.ctn().handleFetchResult(this.ctn().$result)

// You can use it anywhere in the arguments
this.ctn().processWithContext(metadata, this.ctn().$result, timestamp)
```

### Result Types

Handlers receive a **union type** of the expected result and `Error`:

```typescript @skip-check
// For fetch operations
handleFetchResult(result: Response | Error) {
  if (result instanceof Error) {
    // Network failure, timeout, etc.
    return;
  }
  
  // Success - process the response
  const data = await result.text();
}

// For DO-to-DO calls
handleRemoteResult(result: any | Error) {
  if (result instanceof Error) {
    // Remote DO threw an error
    return;
  }
  
  // Success - use the result
  console.log('Got:', result);
}
```

## Common Patterns

### 1. Simple Callback

```typescript @skip-check
class MyDO extends LumenizeBase {
  async startWork() {
    await call(
      this,
      'REMOTE_DO',
      'instance-id',
      this.ctn().remoteMethod(arg),
      this.ctn().handleResult(this.ctn().$result)
    );
  }
  
  handleResult(result: any | Error) {
    if (result instanceof Error) {
      console.error('Call failed:', result);
      return;
    }
    
    console.log('Got result:', result);
  }
}
```

### 2. Chaining Operations

```typescript @skip-check
class MyDO extends LumenizeBase {
  async processData(url: string) {
    await proxyFetchWorker(
      this,
      url,
      // Chain: fetch → parse → validate → save
      this.ctn()
        .parseResponse(this.ctn().$result)
        .validateData()
        .saveToStorage()
    );
  }
  
  parseResponse(result: Response | Error) {
    if (result instanceof Error) throw result;
    return result.json();
  }
  
  validateData(data: any) {
    if (!data.id) throw new Error('Invalid data');
    return data;
  }
  
  saveToStorage(data: any) {
    this.ctx.storage.kv.put(`data:${data.id}`, data);
  }
}
```

### 3. Context Preservation

```typescript @skip-check
class MyDO extends LumenizeBase {
  async fetchForUser(userId: string, url: string) {
    const timestamp = Date.now();
    
    await proxyFetchWorker(
      this,
      url,
      // Capture context in the continuation
      this.ctn().handleUserData(userId, this.ctn().$result, timestamp)
    );
  }
  
  handleUserData(userId: string, result: Response | Error, timestamp: number) {
    if (result instanceof Error) {
      this.ctx.storage.kv.put(`user:${userId}:error`, {
        error: result.message,
        timestamp
      });
      return;
    }
    
    const data = await result.json();
    this.ctx.storage.kv.put(`user:${userId}:data`, {
      data,
      timestamp
    });
  }
}
```

## Under the Hood

Continuations use **operation chaining** internally—method calls are recorded as a chain of operations that can be serialized, stored, and later executed with results injected:

1. **Proxy Factory**: `this.ctn()` returns a Proxy that records operations
2. **Serialization**: The operation chain is serialized via `structured-clone`
3. **Storage**: Stored in DO storage until the result arrives
4. **Deserialization**: Chain is deserialized when result arrives
5. **Execution**: Chain is executed with `$result` replaced by actual result

This ensures:
- ✅ **Type safety**: TypeScript validates the method chains
- ✅ **Serialization**: Chains survive DO eviction/restart
- ✅ **Consistency**: Handlers execute synchronously (no race conditions)
- ✅ **Flexibility**: Complex flows without callback hell

:::info For Power Users
The operation chaining pattern is also exposed in [Lumenize RPC](/docs/rpc/operation-chaining-and-nesting) where it enables batching multiple client operations into a single round trip. While the user-facing API differs, the underlying serialization mechanism is shared.
:::

## Error Handling

Always check for `Error` in your handlers:

```typescript @skip-check
handleResult(result: any | Error) {
  // Guard clause pattern (recommended)
  if (result instanceof Error) {
    console.error('Operation failed:', result.message);
    // Handle error, notify user, retry, etc.
    return;
  }
  
  // Success path - TypeScript knows result is not an Error here
  this.ctx.storage.kv.put('result', result);
}
```

:::warning Important
If you don't check for `Error`, your handler might crash when operations fail. Always use `if (result instanceof Error)` at the start of handlers.
:::

## Best Practices

### ✅ Do

- Check for `Error` first in every handler
- Keep handlers synchronous (no `async` unless wrapped in `ctx.waitUntil`)
- Use descriptive handler names
- Chain related operations together
- Preserve context by passing it as arguments

### ❌ Don't

- Don't use `async` handlers (breaks consistency)
- Don't ignore errors (check `instanceof Error`)
- Don't store sensitive data in continuation chains (they're serialized)
- Don't create circular references (serialization will fail)

## Next Steps

- **[@lumenize/lumenize-base](/docs/lumenize-base/index)** - DO-to-DO communication with `this.lmz.call()`
- **[@lumenize/alarms](/docs/alarms/index)** - Scheduled tasks with continuations
- **[@lumenize/fetch](/docs/fetch/index)** - External fetches with continuations






