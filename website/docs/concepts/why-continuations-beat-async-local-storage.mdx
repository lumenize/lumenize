---
title: Why Continuations Beat AsyncLocalStorage
description: Comparing AsyncLocalStorage with continuations for maintaining context across async operations in Durable Objects
draft: true
---

# Why Continuations Beat AsyncLocalStorage

When working with asynchronous operations in Durable Objects, you often need to maintain context—information from the call site that needs to be available when the async operation completes. This guide compares two approaches: AsyncLocalStorage (from Node.js/Cloudflare agents) and continuations (Lumenize's approach).

## The Context Problem

Consider this common scenario:

```typescript
// You have context at the call site
const requestId = crypto.randomUUID();
const startTime = Date.now();

// You kick off an async operation
await proxyFetchWorker(this, url, this.ctn().handleResult());

// ❓ How does handleResult access requestId and startTime?
async handleResult(result: Response) {
  // Result is first parameter, but where are requestId and startTime?
}
```

## Solution 1: AsyncLocalStorage (Node.js/Cloudflare Agents)

AsyncLocalStorage creates an "async context" that follows execution through callbacks and promises:

```typescript
import { AsyncLocalStorage } from 'node:async_hooks';

const context = new AsyncLocalStorage();

async handleRequest() {
  const requestId = crypto.randomUUID();
  const startTime = Date.now();
  
  // Store in async local storage
  await context.run({ requestId, startTime }, async () => {
    await proxyFetch(this, url);
  });
}

async handleResult(result: Response) {
  // Retrieve from async local storage
  const ctx = context.getStore();
  const requestId = ctx?.requestId;
  const startTime = ctx?.startTime;
}
```

### AsyncLocalStorage Drawbacks

**1. Type Safety Issues**
```typescript
const ctx = context.getStore(); // Returns: any | undefined
const requestId = ctx?.requestId; // Runtime access, no autocomplete
```

**2. Magic Global State**
```typescript
// Where does context come from? What's in it?
const ctx = context.getStore();
// No way to know without reading distant code
```

**3. Runtime Errors**
```typescript
const ctx = context.getStore();
// Typo won't be caught by TypeScript
const id = ctx?.requsetId; // undefined at runtime!
```

**4. Breaking DO Consistency (Critical)**

AsyncLocalStorage relies on Node.js's async tracking mechanism. Cloudflare's Durable Objects use **input/output gates** for consistency:

- When you use `async/await` in a DO method, you break the input/output gate
- This allows race conditions between concurrent requests
- AsyncLocalStorage + async handlers = consistency violations

**5. Performance Overhead**

AsyncLocalStorage maintains a context chain through the entire async execution, adding overhead to every async operation.

## Solution 2: Continuations (Lumenize)

Continuations use standard JavaScript closures to capture context:

```typescript
async handleRequest() {
  const requestId = crypto.randomUUID();
  const startTime = Date.now();
  
  // Context captured in closure - result injected as first parameter by convention
  await proxyFetchWorker(
    this,
    url,
    this.ctn().handleResult(requestId, startTime)
  );
}

async handleResult(result: Response, requestId: string, startTime: number) {
  // Result is first parameter, context follows - all fully typed
  console.log('Request', requestId, 'took', Date.now() - startTime, 'ms');
}
```

### Continuation Advantages

**1. Full Type Safety**
```typescript
// TypeScript knows exactly what's available
async handleResult(
  result: Response,      // ← Autocomplete works
  requestId: string,     // ← Type-checked
  startTime: number      // ← Compile-time errors for typos
) {
  // All parameters are typed and validated
}
```

**2. Explicit Data Flow**
```typescript
// Crystal clear what context is being passed
this.ctn().handleResult(this.ctn().$result, requestId, startTime)
// No hidden global state, no mystery about what's available
```

**3. Standard JavaScript**
```typescript
// Just closures - a fundamental JavaScript concept
const capturedValue = "hello";
const fn = () => console.log(capturedValue);
// Every JS developer already understands this

// Result injection is a simple convention: always first parameter
handler(result, ...capturedContext) // No magic, just pattern
```

**4. Preserves DO Consistency**

Continuation handlers are **synchronous** (except for the required async handlers like `fetch()`):

```typescript
// Synchronous handler preserves input/output gates
handleResult(result: Response, requestId: string) {
  // No async/await = no consistency issues
  this.ctx.storage.kv.put(`result:${requestId}`, result);
}
```

The only `async` is in the background work (fetch, RPC calls), which is correctly isolated.

**5. Zero Runtime Overhead**

Closures are compiled away—no performance penalty for context capture.

## Side-by-Side Comparison

### Scenario: Tracking fetch metrics per request

**AsyncLocalStorage:**
```typescript
import { AsyncLocalStorage } from 'node:async_hooks';

const requestContext = new AsyncLocalStorage();

class MyDO extends DurableObject {
  async fetch(request: Request) {
    const requestId = crypto.randomUUID();
    const metrics = { startTime: Date.now(), fetchCount: 0 };
    
    return await requestContext.run({ requestId, metrics }, async () => {
      await this.doWork();
      return new Response('OK');
    });
  }
  
  async doWork() {
    // Get context from storage
    const ctx = requestContext.getStore() as any;
    ctx.metrics.fetchCount++;
    
    await fetch('https://api.example.com/data');
    
    // Log metrics
    console.log(`Request ${ctx.requestId}: ${ctx.metrics.fetchCount} fetches`);
  }
}
```

**Continuations:**
```typescript
class MyDO extends LumenizeBase {
  async fetch(request: Request) {
    const requestId = crypto.randomUUID();
    const metrics = { startTime: Date.now(), fetchCount: 0 };
    
    this.doWork(requestId, metrics);
    return new Response('OK');
  }
  
  doWork(requestId: string, metrics: { startTime: number; fetchCount: number }) {
    metrics.fetchCount++;
    
    // Context explicitly passed, fully typed - result injected as first parameter
    await proxyFetchWorker(
      this,
      'https://api.example.com/data',
      this.ctn().handleFetchResult(requestId, metrics)
    );
  }
  
  handleFetchResult(
    result: Response,
    requestId: string,
    metrics: { startTime: number; fetchCount: number }
  ) {
    // All context available with type safety
    console.log(`Request ${requestId}: ${metrics.fetchCount} fetches`);
    console.log(`Total time: ${Date.now() - metrics.startTime}ms`);
  }
}
```

### Key Differences

| Feature | AsyncLocalStorage | Continuations |
|---------|------------------|---------------|
| **Type Safety** | ❌ Runtime access (`any`) | ✅ Compile-time typed |
| **Explicitness** | ❌ Magic global state | ✅ Clear parameter passing |
| **DO Consistency** | ⚠️ Breaks with async handlers | ✅ Preserves via sync handlers |
| **Performance** | ⚠️ Runtime tracking overhead | ✅ Zero overhead |
| **Learning Curve** | ⚠️ New API to learn | ✅ Standard closures |
| **Debugging** | ❌ Hard to trace context flow | ✅ Clear in stack traces |
| **IDE Support** | ❌ No autocomplete | ✅ Full autocomplete |

## Migration from AsyncLocalStorage

If you're coming from Cloudflare's agents package or Node.js:

### Before (AsyncLocalStorage):
```typescript
const context = new AsyncLocalStorage();

await context.run({ userId, sessionId }, async () => {
  await doSomething();
});

function doSomething() {
  const ctx = context.getStore();
  console.log(ctx.userId);
}
```

### After (Continuations):
```typescript
// Capture context in continuation - result injected as first parameter
await someAsyncOperation(
  this.ctn().handleResult(userId, sessionId)
);

handleResult(result: any, userId: string, sessionId: string) {
  console.log(userId); // All typed and explicit
}
```

## Common Patterns

### Pattern 1: Request Tracking

```typescript
async fetch(request: Request) {
  const reqId = crypto.randomUUID();
  const startTime = Date.now();
  
  // Capture tracking context - result injected as first parameter
  await proxyFetchWorker(
    this,
    'https://api.example.com/data',
    this.ctn().trackRequest(reqId, startTime)
  );
  
  return new Response('Processing...');
}

trackRequest(result: Response | Error, reqId: string, startTime: number) {
  const duration = Date.now() - startTime;
  this.ctx.storage.kv.put(`metrics:${reqId}`, { duration, success: !(result instanceof Error) });
}
```

### Pattern 2: User Context

```typescript
async handleUserAction(userId: string, action: string) {
  // User context flows through closure - result injected as first parameter
  await call(
    this,
    this.env.SOME_DO,
    'processAction',
    [action],
    this.ctn().onActionComplete(userId, action)
  );
}

onActionComplete(result: any, userId: string, action: string) {
  console.log(`User ${userId} completed ${action}`);
  this.notifyUser(userId, result);
}
```

### Pattern 3: Batch Operations

```typescript
async processBatch(items: Item[]) {
  for (const item of items) {
    // Each item's context captured independently - result injected as first parameter
    await proxyFetchWorker(
      this,
      item.url,
      this.ctn().handleItemResult(item.id, item.retryCount)
    );
  }
}

handleItemResult(result: Response | Error, itemId: string, retryCount: number) {
  if (result instanceof Error && retryCount < 3) {
    // Context available for retry logic
    this.retryItem(itemId, retryCount + 1);
  }
}
```

## Why This Matters for Durable Objects

Durable Objects are designed around **single-threaded consistency**:

1. **Input gate opens** → Request starts processing
2. **Synchronous code runs** → Mutations are safe
3. **Async operation starts** → Input gate closes, next request can enter
4. **Async operation completes** → Callback runs, input gate reopens

**AsyncLocalStorage + async handlers** breaks this model:
- Async handlers can interleave with other requests
- Race conditions become possible
- Consistency guarantees are lost

**Continuations + sync handlers** preserves this model:
- Handlers run synchronously when async work completes
- No interleaving with other requests
- Consistency guarantees maintained

## Conclusion

While AsyncLocalStorage is familiar to Node.js developers, **continuations are better suited to Durable Objects**:

- ✅ **Type-safe** - Compile-time errors, not runtime surprises
- ✅ **Explicit** - Clear data flow, easy to debug
- ✅ **Consistent** - Preserves DO consistency guarantees
- ✅ **Performant** - Zero runtime overhead
- ✅ **Standard** - Uses fundamental JavaScript concepts

The pattern requires a small "aha moment" to discover, but once you see it, it's simpler and more powerful than AsyncLocalStorage.

## Further Reading

- [Continuations Guide](/docs/concepts/continuations) - Deep dive into continuation patterns
- [Durable Objects Consistency](/docs/guides/do-consistency) - Understanding DO consistency guarantees
- [@lumenize/alarms](/docs/alarms) - Scheduled tasks with continuations
- [@lumenize/fetch](/docs/fetch) - External API calls with continuations




