---
description: Powerful alarm scheduling for Cloudflare Durable Objects with cron support
---

# Usage

A de✨light✨ful alarm scheduling package for Cloudflare Durable Objects. Multiplexes single native alarm to give you the appearance of many.

## Features

- **Specific time**: Schedule tasks at a specific timestamp
- **Seconds from now**: Schedule tasks N seconds in the future
- **Cron schedules**: Recurring tasks using cron expressions
- **SQL persistence**: Survives DO eviction and restarts
- **Works standalone or with LumenizeBase**: Use directly or get auto-injected via NADIS

## Installation

```bash @skip-check
npm install @lumenize/alarms
```

## Why Alarms Matter

Cloudflare provides only **one native alarm** per Durable Object. `@lumenize/alarms` multiplexes this single alarm to manage unlimited scheduled tasks.

**Without @lumenize/alarms:**
```typescript @skip-check
// ❌ Only one alarm at a time
await ctx.storage.setAlarm(Date.now() + 60000); // task1
await ctx.storage.setAlarm(Date.now() + 30000); // overwrites task1!
```

**With @lumenize/alarms:**
```typescript @skip-check
// ✅ Unlimited tasks with automatic multiplexing
await alarms.schedule(60, 'handleTask1', { id: 1 });
await alarms.schedule(new Date('2026-01-01'), 'handleTask2', { id: 2 });
await alarms.schedule('0 0 * * *', 'dailyReport', {}); // cron!
// All three tasks will execute at their scheduled times
```

## Key Methods

All method signatures and detailed examples are shown below:

- **`schedule(when, callback, payload)`** - Schedule a task (seconds, Date, or cron string)
- **`cancelSchedule(id)`** - Cancel a scheduled task
- **`getSchedule(id)`** - Get details about a specific schedule
- **`getSchedules(criteria?)`** - Get all schedules matching criteria
- **`alarm()`** - Alarm handler (must be called from DO's `alarm()` method)
- **`triggerAlarms(count?)`** - Testing helper (see [Testing Alarms](#testing-alarms))

## Setup Your Durable Object

### Standalone Usage

Manual instantiation with explicit dependencies:

```typescript @check-example('packages/alarms/test/for-docs/standalone-pattern.test.ts')
import { Alarms, type Schedule } from '@lumenize/alarms';
import { sql } from '@lumenize/core';
import { DurableObject } from 'cloudflare:workers';

class MyDO extends DurableObject {
  #alarms: Alarms;
  
  constructor(ctx: DurableObjectState, env: any) {
    super(ctx, env);
    this.#alarms = new Alarms(ctx, this, { sql: sql(this) });
  }
  
  // Required boilerplate. Delegates standard `alarm()` handler to Alarms
  async alarm() {
    await this.#alarms.alarm();
  }
  
  scheduleTask() {
    this.#alarms.schedule(60, 'handleTask', { data: 'example' });
  }
  
  handleTask(payload: any, schedule: Schedule) {
    console.log('Task executed:', payload);
  }
}
```

### Usage with LumenizeBase (Auto-Injected)

When using `@lumenize/lumenize-base`, alarms are automatically available via `this.svc`:

```typescript @check-example('packages/alarms/test/for-docs/lumenize-base-pattern.test.ts')
import '@lumenize/core';    // Registers sql in this.svc
import '@lumenize/alarms';  // Registers alarms in this.svc (depends on sql)
import { LumenizeBase } from '@lumenize/lumenize-base';

class MyDO extends LumenizeBase<any> {
  // Required boilerplate. Delegates standard `alarm()` handler to Alarms
  async alarm() {
    await this.svc.alarms.alarm();
  }
  
  scheduleTask() {
    this.svc.alarms.schedule(60, 'handleTask', { data: 'example' });
  }
  
  handleTask(payload: any, schedule: Schedule) {
    console.log('Task executed:', payload);
  }
}
```

No manual initialization needed - alarms are automatically injected!

See [@lumenize/lumenize-base documentation](/docs/lumenize-base) for more details on auto-injection.

### Schedule Tasks

#### Seconds From Now

```typescript @check-example('packages/alarms/test/for-docs/basic-usage.test.ts')
const schedule = this.#alarms.schedule(
  delaySeconds,  // a number
  'handleTask',  // handler method as string
  { name: taskName }  // payload
);
```

The handler receives the payload and schedule info:

```typescript @check-example('packages/alarms/test/for-docs/basic-usage.test.ts')
handleTask(payload: any, schedule: Schedule) {
  console.log(payload, schedule);
  // payload: { name: 'send-email' }
  // schedule: { id: '...', runAt: 1699564800000, callback: 'handleTask', ... }
// ...
}
```

#### At a Specific Date (and time)

```typescript @check-example('packages/alarms/test/for-docs/basic-usage.test.ts')
const schedule = this.#alarms.schedule(
  new Date(timestamp),  // a Date
  'handleTask',  // handler method as string
  { name: taskName }  // payload
);
```

#### Recurring Task (Cron)

```typescript @check-example('packages/alarms/test/for-docs/basic-usage.test.ts')
const schedule = this.#alarms.schedule(
  '0 0 * * *',  // cron expression (daily at midnight)
  'handleRecurringTask',  // handler method as string
  { name: taskName }  // payload
);
```

Cron handlers are called repeatedly. See below for [cron expression examples](#cron-expression-examples).

```typescript @check-example('packages/alarms/test/for-docs/basic-usage.test.ts')
handleRecurringTask(payload: any, schedule: Schedule) {
  console.log(payload, schedule);
  // payload: { name: 'daily-report' }
  // schedule: { id: '...', cron: '0 0 * * *', callback: 'handleRecurringTask', ... }
// ...
}
```

## Managing Schedules

### Cancel a Schedule

The `schedule()` method returns a schedule object with an `id`:

```typescript @check-example('packages/alarms/test/for-docs/basic-usage.test.ts')
const schedule = this.#alarms.schedule(/* ... */);

// Later, to cancel:
this.#alarms.cancelSchedule(schedule.id);
```

### List Scheduled Tasks

```typescript @skip-check
console.log(this.#alarms.getSchedules());
// [
//   { 
//     id: 'abc123',
//     callback: 'handleTask',
//     payload: { name: 'send-email' },
//     type: 'delayed',
//     time: 1699564860,
//     delayInSeconds: 60
//   },
//   {
//     id: 'def456',
//     callback: 'dailyReport',
//     payload: { name: 'report' },
//     type: 'cron',
//     time: 1699574400,
//     cron: '0 0 * * *'
//   }
// ]
```

## Cron Expression Examples

`@lumenize/alarms` uses standard cron syntax:

```
 ┌───────────── minute (0 - 59)
 │ ┌───────────── hour (0 - 23)
 │ │ ┌───────────── day of month (1 - 31)
 │ │ │ ┌───────────── month (1 - 12)
 │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday = 0)
 │ │ │ │ │
 * * * * *
```

**Common patterns:**
- `'0 0 * * *'` - Daily at midnight
- `'0 9 * * 1-5'` - Weekdays at 9am
- `'*/15 * * * *'` - Every 15 minutes
- `'0 0 1 * *'` - First day of every month
- `'0 0 * * 0'` - Every Sunday at midnight

## Implementation Details

### How It Works

1. **Persistence**: All schedules are stored in a SQL table `_lumenize_alarms`
2. **Multiplexing**: The package intelligently sets Cloudflare's single native alarm to the next due task
3. **Execution**: When the alarm fires, all overdue tasks execute and the next alarm is scheduled
4. **Cron handling**: After a cron task executes, it's automatically rescheduled for its next occurrence

### Storage Table

The alarms table (`_lumenize_alarms`) is automatically created with columns for id, callback, payload, type, time, and optional delayInSeconds/cron fields.

### Lazy Initialization

The table is created lazily on first use if it doesn't already exist, rather than in the constructor. This ensures compatibility with the NADIS auto-injection system where services might be instantiated outside `blockConcurrencyWhile`.

## Testing Alarms

### Manual Trigger for Tests

The `triggerAlarms(count?)` method lets you manually execute alarms for testing without waiting for real time to pass. It executes alarms chronologically and can "fast-forward" through future alarms.

See [Testing Alarm Simulation](/docs/testing/alarm-simulation) for complete examples and patterns.

## Standing on the Shoulders of Giants

The core of this implementation is based upon the Alarms functionality in the
[`@cloudflare/actors`](https://www.npmjs.com/package/@cloudflare/actors)
package with the following enhancements:

- NADIS dependency injection - Changed from mixin approach to accepting `{ sql }` in constructor
- Lazy table initialization - Table created if it doesn't exist on first operation (critical for NADIS auto-injection)
- Removed actor-specific dependencies - Removed setName, actorName, etc.
- Added TypeScript generics - Enhanced type safety with generics
- Made API synchronous - Changed schedule(), getSchedule(), cancelSchedule(), and #scheduleNextAlarm() from async to synchronous
- Added triggerAlarms() testing helper - Enables reliable alarm testing
