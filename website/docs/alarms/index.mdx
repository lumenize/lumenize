---
title: 'Alarms'
description: Powerful alarm scheduling for Cloudflare Durable Objects with continuations and cron support
---

# Lumenize Alarms

De✨light✨ful alarm scheduling for Cloudflare Durable Objects using [continuations](/docs/lumenize-mesh/continuations). Multiplexes single native alarm to give you unlimited scheduled tasks.

## Features

- **[Continuations](/docs/lumenize-mesh/continuations)** - Type-safe, serializable task handlers
- **Multiple schedules** - Specific time, seconds from now, or cron expressions
- **SQL persistence** - Survives DO eviction and restarts
- **Auto-injection** - Automatically available via NADIS when using LumenizeDO
- **Testing support** - Manual alarm triggering for tests

## Installation

```bash @skip-check
npm install @lumenize/alarms
```

## Why Alarms Matter

Cloudflare provides only **one native alarm** per Durable Object. `@lumenize/alarms` multiplexes this single alarm to manage unlimited scheduled tasks with type-safe continuations.

**Without @lumenize/alarms:**
```typescript @skip-check
// ❌ Only one alarm at a time
await ctx.storage.setAlarm(Date.now() + 60000); // task1
await ctx.storage.setAlarm(Date.now() + 30000); // overwrites task1!
```

**With @lumenize/alarms:**
```typescript @skip-check
// ✅ Unlimited tasks with automatic multiplexing and type safety
this.svc.alarms.schedule(60, this.ctn().handleTask1({ id: 1 }));
this.svc.alarms.schedule(new Date('2026-01-01'), this.ctn().handleTask2({ id: 2 }));
this.svc.alarms.schedule('0 0 * * *', this.ctn().dailyReport()); // cron!
// All three tasks execute at their scheduled times
```

## Quick Start

```typescript @skip-check
import { LumenizeDO } from '@lumenize/mesh';
import '@lumenize/alarms'; // Registers alarms service

class MyDO extends LumenizeDO<Env> {
  async fetch(request: Request): Promise<Response> {
    // Schedule a task 60 seconds from now
    this.svc.alarms.schedule(
      60,  // seconds from now
      this.ctn().sendEmail('user@example.com', 'Welcome!')
    );
    
    return new Response('Email scheduled!');
  }
  
  // Handler executes when alarm fires
  sendEmail(to: string, subject: string) {
    console.log(`Sending email to ${to}: ${subject}`);
    // Send email logic here
  }
}
```

## Setup Your Durable Object

### Usage with LumenizeDO (Recommended)

When using `@lumenize/mesh`, alarms are automatically available via `this.svc`:

```typescript @skip-check
import { LumenizeDO } from '@lumenize/mesh';
import '@lumenize/alarms';  // Registers alarms in this.svc

class MyDO extends LumenizeDO<Env> {
  // Delegate alarm() to the alarms service
  async alarm() {
    await this.svc.alarms.alarm();
  }

  async scheduleTask(userId: string, data: any) {
    const schedule = this.svc.alarms.schedule(
      60,  // 60 seconds
      this.ctn().processUserData(userId, data)
    );

    console.log('Scheduled:', schedule.id);
  }

  processUserData(userId: string, data: any) {
    // Synchronous handler - maintains DO consistency
    console.log('Processing data for user:', userId);
    this.ctx.storage.kv.put(`user:${userId}:data`, data);
  }
}
```

## Scheduling Tasks

### Seconds From Now

Schedule a task to run after a delay:

```typescript @skip-check
// Schedule task for 60 seconds from now
this.svc.alarms.schedule(
  60,  // 60 seconds
  this.ctn().handleTask({ name: 'send-email' })
);
```

### At a Specific Date/Time

Schedule a task at a specific moment:

```typescript @skip-check
this.svc.alarms.schedule(
  new Date('2026-01-01T00:00:00Z'),
  this.ctn().newYearTask()
);

// Or with a timestamp
const timestamp = Date.now() + 3600000; // 1 hour from now
this.svc.alarms.schedule(
  new Date(timestamp),
  this.ctn().handleTask({ id: 123 })
);
```

### Recurring Tasks (Cron)

Schedule recurring tasks with cron expressions:

```typescript @skip-check
// Daily at midnight UTC
this.svc.alarms.schedule(
  '0 0 * * *',
  this.ctn().dailyReport()
);

// Every 15 minutes
this.svc.alarms.schedule(
  '*/15 * * * *',
  this.ctn().checkStatus()
);

// Weekdays at 9am
this.svc.alarms.schedule(
  '0 9 * * 1-5',
  this.ctn().sendDailyDigest()
);
```

## Handlers and Context

### Simple Handlers

```typescript @skip-check
class MyDO extends LumenizeDO {
  async scheduleTasks() {
    // No arguments
    this.svc.alarms.schedule(30, this.ctn().simpleTask());
    
    // With arguments
    this.svc.alarms.schedule(
      60,
      this.ctn().taskWithArgs('value1', 123, { key: 'value' })
    );
  }
  
  simpleTask() {
    console.log('Simple task executed');
  }
  
  taskWithArgs(str: string, num: number, obj: any) {
    console.log('Task with args:', str, num, obj);
  }
}
```

### Preserving Context

Capture context by passing it as arguments to your continuation:

```typescript @skip-check
class SessionDO extends LumenizeDO {
  async scheduleUserReminder(userId: string, message: string) {
    const scheduledAt = Date.now();
    
    this.svc.alarms.schedule(
      3600, // 1 hour
      // Context preserved in continuation
      this.ctn().sendReminder(userId, message, scheduledAt)
    );
  }
  
  sendReminder(userId: string, message: string, scheduledAt: number) {
    const now = Date.now();
    const delay = now - scheduledAt;
    
    console.log(`Reminder for ${userId} (scheduled ${delay}ms ago): ${message}`);
    
    // Access storage, make API calls, etc.
    this.ctx.storage.kv.put(`user:${userId}:last-reminder`, {
      message,
      sentAt: now,
      scheduledAt
    });
  }
}
```

### Chaining Operations

Build complex workflows by chaining operations:

```typescript @skip-check
class WorkflowDO extends LumenizeDO {
  async startWorkflow(data: any) {
    this.svc.alarms.schedule(
      60,
      // Chain: validate → process → save → notify
      this.ctn()
        .validateData(data)
        .processData()
        .saveResults()
        .notifyCompletion()
    );
  }
  
  validateData(data: any) {
    if (!data.id) throw new Error('Invalid data');
    console.log('Validated:', data.id);
    return data;
  }
  
  processData(data: any) {
    console.log('Processing:', data);
    return { ...data, processed: true };
  }
  
  saveResults(data: any) {
    this.ctx.storage.kv.put(`result:${data.id}`, data);
    return data.id;
  }
  
  notifyCompletion(id: string) {
    console.log('Workflow complete:', id);
  }
}
```

## Managing Schedules

### Get Schedule Information

```typescript @skip-check
// Schedule returns schedule info
const schedule = this.svc.alarms.schedule(
  60,
  this.ctn().handleTask()
);

console.log(schedule);
// {
//   id: 'abc123',
//   operationChain: [...],
//   time: 1699564860000,
//   type: 'delayed',
//   delayInSeconds: 60
// }
```

### Cancel a Schedule

```typescript @skip-check
// Save the schedule ID
const schedule = this.svc.alarms.schedule(/* ... */);

// Later, cancel it
await this.svc.alarms.cancelSchedule(schedule.id);
```

### List All Schedules

```typescript @skip-check
const schedules = this.svc.alarms.getSchedules();
console.log(schedules);
// [
//   { 
//     id: 'abc123',
//     operationChain: [...],
//     type: 'delayed',
//     time: 1699564860000,
//     delayInSeconds: 60
//   },
//   {
//     id: 'def456',
//     operationChain: [...],
//     type: 'cron',
//     time: 1699574400000,
//     cron: '0 0 * * *'
//   }
// ]
```

### Get Specific Schedule

```typescript @skip-check
const schedule = this.svc.alarms.getSchedule('abc123');
if (schedule) {
  console.log('Found schedule:', schedule);
} else {
  console.log('Schedule not found or already executed');
}
```

## Cron Expression Examples

Standard cron syntax:

```
 ┌───────────── minute (0 - 59)
 │ ┌───────────── hour (0 - 23)
 │ │ ┌───────────── day of month (1 - 31)
 │ │ │ ┌───────────── month (1 - 12)
 │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday = 0)
 │ │ │ │ │
 * * * * *
```

**Common patterns:**
- `'0 0 * * *'` - Daily at midnight UTC
- `'0 9 * * 1-5'` - Weekdays at 9am UTC
- `'*/15 * * * *'` - Every 15 minutes
- `'0 0 1 * *'` - First day of every month at midnight
- `'0 0 * * 0'` - Every Sunday at midnight
- `'30 14 * * 1,3,5'` - Monday, Wednesday, Friday at 2:30pm

:::tip Timezone
All cron schedules use UTC. Convert local times to UTC when scheduling.
:::

## Advanced Patterns

### Conditional Execution

```typescript @skip-check
class SmartDO extends LumenizeDO {
  async scheduleConditionalTask() {
    this.svc.alarms.schedule(
      60,
      this.ctn().checkAndExecute('feature-flag')
    );
  }
  
  checkAndExecute(flagName: string) {
    const enabled = this.ctx.storage.kv.get(`flag:${flagName}`);
    
    if (!enabled) {
      console.log('Feature disabled, skipping task');
      return;
    }
    
    console.log('Feature enabled, executing task');
    this.executeTask();
  }
  
  executeTask() {
    // Actual task logic
  }
}
```

### Retry with Backoff

```typescript @skip-check
class ResilientDO extends LumenizeDO {
  async startWithRetry(url: string, maxRetries = 3) {
    this.svc.alarms.schedule(
      5, // Initial delay
      this.ctn().fetchWithRetry(url, 0, maxRetries)
    );
  }
  
  async fetchWithRetry(url: string, attempt: number, maxRetries: number) {
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      // Success!
      console.log('Fetch succeeded on attempt:', attempt + 1);
      this.ctx.storage.kv.put('last-success', Date.now());
    } catch (error) {
      if (attempt >= maxRetries) {
        console.error('Max retries reached:', error);
        return;
      }
      
      // Exponential backoff: 10s, 20s, 40s
      const backoffSeconds = 10 * Math.pow(2, attempt);
      console.log(`Retry ${attempt + 1}/${maxRetries} in ${backoffSeconds}s`);
      
      this.svc.alarms.schedule(
        backoffSeconds,
        this.ctn().fetchWithRetry(url, attempt + 1, maxRetries)
      );
    }
  }
}
```

### State Machine with Alarms

```typescript @skip-check
class StateMachineDO extends LumenizeDO {
  async startStateMachine(data: any) {
    // Initial state
    this.ctx.storage.kv.put('state', 'init');
    
    this.svc.alarms.schedule(
      1,
      this.ctn().transition('init', 'processing', data)
    );
  }
  
  transition(from: string, to: string, data: any) {
    const current = this.ctx.storage.kv.get('state');
    
    if (current !== from) {
      console.error(`Invalid transition: ${from} -> ${to} (current: ${current})`);
      return;
    }
    
    console.log(`Transition: ${from} -> ${to}`);
    this.ctx.storage.kv.put('state', to);
    
    // Execute state logic
    switch (to) {
      case 'processing':
        this.processData(data);
        break;
      case 'complete':
        this.completeWorkflow(data);
        break;
    }
  }
  
  processData(data: any) {
    // Process data...
    
    // Transition to next state
    this.svc.alarms.schedule(
      5,
      this.ctn().transition('processing', 'complete', data)
    );
  }
  
  completeWorkflow(data: any) {
    console.log('Workflow complete:', data);
    this.ctx.storage.kv.delete('state');
  }
}
```

## Testing Alarms

### How Alarm Execution Works

Understanding the execution flow:

1. **`schedule()` is synchronous** - Stores alarm to SQL, sets native alarm, returns immediately
2. **Never executes inline** - Even 0-second delays go through Cloudflare's native alarm queue
3. **Production**: Native `alarm()` fires → calls `triggerAlarms(overdueCount)` → executes callbacks
4. **Testing**: Call `await triggerAlarms()` manually to bypass Cloudflare's timing uncertainty

### Manual Trigger for Tests

To make testing as close to reality as possible, the `triggerAlarms(count?)` method is the core execution logic used both by the production `alarm()` handler and exposed publicly for testing:

```typescript @skip-check
import { describe, test, expect } from 'vitest';

describe('Alarm Tests', () => {
  test('scheduled task executes', async () => {
    const stub = env.MY_DO.get(env.MY_DO.idFromName('test'));
    
    // Schedule task (synchronous, only stores to SQL)
    await stub.scheduleTask();
    
    // Manually trigger (core execution logic, bypasses native alarm timing)
    await stub.triggerAlarms();
    
    // Verify task executed
    const result = await stub.getResult();
    expect(result).toBe('task-executed');
  });
  
  test('cron task executes multiple times', async () => {
    const stub = env.MY_DO.get(env.MY_DO.idFromName('test'));
    
    // Schedule recurring task
    await stub.scheduleCronTask();
    
    // Trigger 3 times (fast-forward through cron executions)
    await stub.triggerAlarms(3);
    
    // Verify task ran 3 times
    const count = await stub.getExecutionCount();
    expect(count).toBe(3);
  });
});
```

**Key insight**: Without calling `triggerAlarms()`, alarms remain queued waiting for Cloudflare to fire the native alarm - which can be unpredictable in test environments.

Note, the `@lumenize/testing` package includes experimental [alarm simulation](/docs/testing/alarm-simulation) capability that will speed up the clock 100x to simulate time passing faster for the convenience of tests. When using `@lumenize/alarms`, calling triggerAlarms directly for testing is superior in every way. Simulate alarms is only for testing with native alarms or 3rd party alarms packages like Actor Alarms.

## How It Works

1. **Persistence**: All schedules stored in SQL table `__lmz_alarms`
2. **Multiplexing**: Cloudflare's single native alarm set to the next due task
3. **Execution**: When alarm fires, all overdue tasks execute via continuations
4. **Cron handling**: After cron task executes, automatically rescheduled for next occurrence
5. **Lazy initialization**: Table created on first use (compatible with NADIS)

### Storage Table

The alarms table (`__lmz_alarms`) is automatically created with:
- `id` - Unique schedule ID
- `operationChain` - Serialized continuation chain
- `type` - 'delayed', 'timestamp', or 'cron'
- `time` - Unix timestamp for next execution
- `delayInSeconds` - Original delay (delayed type only)
- `cron` - Cron expression (cron type only)

## Best Practices

### ✅ Do

- Use continuations (`this.ctn()`) for type-safe handlers
- Keep handlers synchronous (no `async` unless wrapped in `ctx.waitUntil`)
- Preserve context by passing it as arguments
- Use descriptive method names for handlers
- Check cron syntax carefully
- Consider timezones (cron uses UTC)
- Test with `triggerAlarms()` instead of waiting for real time

### ❌ Don't

- Don't use `async` handlers (breaks consistency)
- Don't pass non-serializable data (functions, symbols, etc.)
- Don't create circular references in arguments
- Don't rely on instance variables (they may not persist after DO eviction)
- Don't forget to handle errors in your handlers
- Don't schedule huge numbers of tasks (storage has limits)

## Comparison to Native Alarms

| Feature | Native Alarm | @lumenize/alarms |
|---------|-------------|------------------|
| **Max alarms** | 1 per DO | Unlimited |
| **Cron support** | No | Yes |
| **Type safety** | No | Yes (via continuations) |
| **Serialization** | Manual | Automatic |
| **Testing** | Real time only | Manual triggers |
| **Persistence** | Native | SQL table |

## API Reference

See the [TypeDoc API Reference](/docs/alarms/api) for complete type information.

## Next Steps

- **[Continuations](/docs/lumenize-mesh/continuations)** - Understanding the continuation pattern
- **[LumenizeDO](/docs/lumenize-base/index)** - DO-to-DO communication with `this.lmz.call()`
- **[Fetch](/docs/fetch/index)** - External API calls with continuations
- **[Testing](/docs/testing/alarm-simulation)** - Testing alarms without waiting

## Standing on the Shoulders of Giants

The core implementation is based on the Alarms functionality in [`@cloudflare/actors`](https://www.npmjs.com/package/@cloudflare/actors) with these enhancements:

- **Continuations** - Type-safe handlers instead of string callbacks
- **NADIS integration** - Auto-injection via dependency injection
- **Lazy initialization** - Table created on first use (critical for NADIS)
- **Synchronous API** - No unnecessary async operations
- **Testing support** - `triggerAlarms()` for reliable alarm testing

