---
title: Mesh API
description: Core APIs shared by all mesh node types
---

# Mesh API

All mesh node types — [LumenizeDO](./lumenize-do), [LumenizeWorker](./lumenize-worker), and [LumenizeClient](./lumenize-client) — share a common API for mesh communication.

## Interface: `LmzApi`

Every mesh node has access to `this.lmz`:

```typescript @skip-check
interface LmzApi {
  // Node identity
  type: 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient';
  bindingName: string;           // e.g., 'DOCUMENT_DO', 'LUMENIZE_CLIENT_GATEWAY'
  instanceName?: string;         // e.g., 'doc-123' (undefined for Workers)

  // Current request context (only valid during handler execution)
  callContext: CallContext;

  // Make a mesh call
  call(
    binding: string,
    instanceName: string | undefined,
    continuation: Continuation,
    responseHandler?: Continuation
  ): void;
}
```

| `type` | `instanceName` |
|--------|----------------|
| `'LumenizeDO'` | Named instance (e.g., `'user-123'`) |
| `'LumenizeWorker'` | Always `undefined` |
| `'LumenizeClient'` | Client identifier (e.g., `'alice.tab1'`) |

For `call()` patterns including fire-and-forget, response handlers, chaining, and error handling, see [Making Calls](./calls).

## Interface: `CallContext`

Available via `this.lmz.callContext` during any `@mesh` handler execution:

```typescript @skip-check
interface CallContext {
  // Immutable — set at chain start, cannot be modified by intermediate nodes
  origin: {
    type: 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient';
    bindingName: string;
    instanceName?: string;
  };
  // Immutable — verified claims from origin's JWT (if authenticated)
  originAuth?: {
    userId: string;
    // ... other auth claims
  };
  // Per-hop — reflects the immediate caller (changes at each hop)
  caller: {
    type: 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient';
    bindingName: string;
    instanceName?: string;
  };
  // Per-hop — this node's identity in the current call
  callee: {
    bindingName: string;
    instanceName: string;
  };
  // Mutable — can be modified by onBeforeCall or any handler execution along the way
  state: Record<string, any>;
}
```

**Property summary:**
- `origin` — Original caller at chain start. **Immutable**.
- `originAuth` — Verified JWT claims from original caller. **Immutable**.
- `caller` — Immediate caller. **Per-hop** — changes at each hop.
- `callee` — This node's identity in the current call. **Per-hop**.
- `state` — Middleware data. **Mutable** — starts as `{}`, typically populated in `onBeforeCall()`.

For context propagation and persistence patterns, see [Managing Context](./managing-context).

## Decorator: `@mesh`

Marks methods as mesh entry points. Methods without `@mesh` cannot be called from outside the node.

```typescript @skip-check
@mesh                         // Basic entry point
@mesh(guardFunction)          // With access control guard
```

**Guard signature:**
```typescript @skip-check
(instance: T) => void | Promise<void>
// Throw to deny access. Access context via instance.lmz.callContext.
```

For guard patterns and access control, see [Security](./security#access-control).

## Hook: `onBeforeCall()`

Override for class-wide access control that runs before every mesh call:

```typescript @skip-check
onBeforeCall(): void
// Call super.onBeforeCall() for default behavior
// Access context via this.lmz.callContext
// Throw to reject the call
```

| Level | Mechanism | Purpose |
|-------|-----------|---------|
| Class-wide | `onBeforeCall()` | WHO can call (authentication) |
| Method-level | `@mesh(guard)` | Fine-grained permissions |

For the complete security model, see [Security](./security#access-control).

## Method: `this.ctn<T>()`

Creates type-safe continuations for mesh calls:

```typescript @skip-check
// Remote continuation — what to call on another node
this.ctn<OtherDO>().someMethod(arg1, arg2)

// Local continuation — what to call on this instance
this.ctn().handleResult(this.ctn().$result)
```

The `$result` placeholder gets replaced with the actual result (or `Error`) when the continuation executes.

For operation chains, nesting, and context preservation, see [Continuations](./continuations).
