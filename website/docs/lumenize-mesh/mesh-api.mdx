---
title: Mesh API
description: Core APIs shared by all mesh node types
---

# Mesh API

All mesh node types — [LumenizeDO](./lumenize-do), [LumenizeWorker](./lumenize-worker), and [LumenizeClient](./lumenize-client) — share a common API for mesh communication.

## Interface: `LmzApi`

Every mesh node has access to `this.lmz`:

```typescript @skip-check
interface LmzApi {
  // Node identity
  type: 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient';
  bindingName: string;           // e.g., 'DOCUMENT_DO', 'LUMENIZE_CLIENT_GATEWAY'
  instanceName?: string;         // e.g., 'doc-123' (undefined for Workers)

  // Current request context (only valid during handler execution)
  callContext: CallContext;

  // Make a mesh call
  call(
    binding: string,
    instanceName: string | undefined,
    continuation: Continuation,
    responseHandler?: Continuation
  ): void;
}
```

| `type` | `instanceName` |
|--------|----------------|
| `'LumenizeDO'` | Named instance (e.g., `'user-123'`) |
| `'LumenizeWorker'` | Always `undefined` |
| `'LumenizeClient'` | Client identifier (e.g., `'alice.tab1'`) |

For `call()` patterns including fire-and-forget, response handlers, chaining, and error handling, see [Making Calls](./calls).

## Interface: `CallContext`

Available via `this.lmz.callContext` during any `@mesh` handler execution:

```typescript @skip-check
interface CallContext {
  // Immutable — set at chain start, cannot be modified by intermediate nodes
  origin: NodeIdentity;

  // Immutable — verified claims from origin's JWT (if authenticated)
  originAuth?: {
    userId: string;
    claims?: Record<string, unknown>;  // Additional JWT claims (roles, permissions, etc.)
  };

  // Full call path from origin to immediate caller (immutable array, grows at each hop)
  callChain: NodeIdentity[];  // [origin, hop1, hop2, ...] — last element is immediate caller

  // Per-hop — this node's identity (populated by receiver)
  callee?: NodeIdentity;

  // Mutable — can be modified by onBeforeCall or any handler along the way
  state: Record<string, unknown>;
}

interface NodeIdentity {
  type: 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient';
  bindingName: string;
  instanceName?: string;  // undefined for Workers
}
```

**Property summary:**
- `origin` — Original caller at chain start. **Immutable**.
- `originAuth` — Verified JWT claims from original caller. **Immutable**. Only set for authenticated LumenizeClient origins.
- `callChain` — Full call path from origin to immediate caller. **Immutable array** — grows at each hop.
- `callee` — This node's identity in the current call. **Per-hop** — populated by receiver from envelope metadata.
- `state` — Middleware data. **Mutable** — starts as `{}`, typically populated in `onBeforeCall()`.

**Convenience getter:**
```typescript @skip-check
this.lmz.caller  // Returns last element of callChain (immediate caller), or origin if chain is empty
```

For context propagation and persistence patterns, see [Managing Context](./managing-context).

## Decorator: `@mesh`

Marks methods as mesh entry points. Methods without `@mesh` cannot be called from outside the node. This is the security boundary — only methods you explicitly mark can be invoked remotely.

```typescript @skip-check
@mesh                         // Basic entry point
@mesh.guard(guardFunction)    // With access control guard
```

**Guard signature:**
```typescript @skip-check
(instance: T) => void | Promise<void>
// Throw to deny access. Access context via instance.lmz.callContext.
```

For guard patterns and access control, see [Security](./security#access-control).

## Hook: `onBeforeCall()`

Override for class-wide access control that runs before every mesh call:

```typescript @skip-check
onBeforeCall(): void
// Call super.onBeforeCall() for default behavior
// Access context via this.lmz.callContext
// Throw to reject the call
```

| Level | Mechanism | Purpose |
|-------|-----------|---------|
| Class-wide | `onBeforeCall()` | WHO can call (authentication) |
| Method-level | `@mesh.guard()` | Fine-grained permissions |

For the complete security model, see [Security](./security#access-control).

## Method: `this.ctn<T>()`

Creates type-safe continuations for mesh calls:

```typescript @skip-check
// Remote continuation — what to call on another node
this.ctn<OtherDO>().someMethod(arg1, arg2)

// Local continuation — what to call on this instance
this.ctn().handleResult(this.ctn().$result)
```

The `$result` placeholder gets replaced with the actual result (or `Error`) when the continuation executes.

For operation chains, nesting, and context preservation, see [Continuations](./continuations).
