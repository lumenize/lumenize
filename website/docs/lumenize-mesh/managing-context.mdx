---
title: Managing Context
description: Understanding the Dual-Context Strategy in Lumenize - Call Context vs. Continuations
---

# Managing Context

When making calls in to another place or time, you often need to maintain **context**: information from the call site that must be available for the callee to accomplish its work.

Lumenize uses a **Dual-Context Strategy** to handle this:
1. **Call Context (`this.lmz.callContext`)**: For information about the caller/callee including mesh node type and auth as well as custom annotations added by middleware, like the `onBeforeCall` auth hook, to assist with later access control decisions, like made in the `@mesh` handler.
2. **Application Context (Continuations)**: For your specific business logic and data flow.

## 1. Call Context (`this.lmz.callContext`)

Lumenize automatically propagates **Call Context** across any call chain (e.g., Client → DO → Worker → DO). `this.lmz.callContext` is always accurate for the current request—even when calls chain through multiple mesh nodes, when local continuation handlers execute later, when using two-one-way call patterns, or when alarms fire.

### Why We Do This
- **Zero Boilerplate**: You don't have to manually pass identity, calling node type, etc. into every single function. They are "just there" when you need them.
- **Race-Safe**: Even when multiple requests to the same mesh node interleave, each request sees its own unique context.

```typescript
// Any method, anywhere in your call chain
@mesh
doSomething() {
  // Always correct for the current request
  const user = this.lmz.callContext.originAuth?.userId;
}
```

:::note Implementation Detail
Under the hood, `this.lmz.callContext` uses Node.js's confusingly named `AsyncLocalStorage` to maintain context across hops through space and time. There is no reason to use it directly in Lumenize Mesh. Just use `this.lmz.callContext`.
:::

### Where Identity Enters the Mesh

User identity (`callContext.originAuth`) enters the mesh **only** through [LumenizeClient](./lumenize-client) via [LumenizeGateway](./gateway). The Gateway verifies the JWT and populates `originAuth` with the verified claims — the actual token is never propagated. Both `origin` and `originAuth` are immutable throughout the chain; intermediate nodes cannot modify them.

For the complete `CallContext` interface — including which fields are immutable, per-hop, or mutable — see [Mesh API: CallContext](./mesh-api#interface-callcontext).

## 2. Application Context (Continuations)

While `this.lmz.callContext` is great for mesh-oriented context, you should use extra parameters in your [continuations](./continuations) for your own application context. Alternatively, for DOs and other nodes with storage capability, you could store such context locally and merely pass the key for such data into the continuation.

```typescript
this.lmz.call(
  'VALIDATION_WORKER',
  undefined,
  this.ctn<ValidationWorker>().validate(data),
  this.ctn().handleValidation(documentId, this.ctn().$result) // $result can go anywhere
);

handleValidation(documentId: string, result: ValidationResult | Error) {
  if (result instanceof Error) {
    console.log(`Validation failed for ${documentId}:`, result.message);
    return;
  }
  console.log(`Document ${documentId} is valid`);
}
```

## Eviction/Hibernation Risk

Context is maintained in most cases, but if a node hibernates/evicts while `await`ing a response, the local handler might never execute.

For restart-safe patterns:
- Use **[Two One-Way Calls](./calls#cost-optimization-two-one-way-calls)** — both kinds of contexts are fully contained in the outgoing call. When the call back is made, it'll reawaken the instance. The `lmz.callContext` is automatically restored, and you can include whatever context you want in the callback.
- Use **[@lumenize/alarms](/docs/alarms)** — persists alarm handler continuation including `lmz.callContext` and your continuation parameters to storage so they are available when the alarm triggers.

## Manual Persistence (Power Users)

If you're building your own restart-safe patterns outside the standard tools, you may want to explicitly serialize and store the continuation:

```typescript
import { getOperationChain } from '@lumenize/mesh';

// getOperationChain captures callContext automatically
const chain = getOperationChain(this.ctn().myHandler(data));

// Save to storage — KV handles Dates, Maps, Sets, cycles, etc. natively
this.ctx.storage.kv.put('my-key', chain);
```

For SQL TEXT columns, use `stringify()`/`parse()` from `@lumenize/structured-clone` on the operation chain before saving. All structured-cloneable types (Dates, Maps, cycles, etc.) are stringified.

## Conclusion

> **"Let Lumenize handle call context via `this.lmz.callContext`; handle your own application context via `.ctn().handler(myData)`."**
