---
title: Managing Context
description: Understanding the Dual-Context Strategy in Lumenize - AsyncLocalStorage vs. Continuations
---

# Managing Context

When working with asynchronous operations in Durable Objects, you often need to maintain **context**—information from the call site that needs to be available when the async operation completes.

Lumenize uses a **Dual-Context Strategy** to handle this problem:
1. **Framework Context (`AsyncLocalStorage`)**: For infrastructure data like identity and auth.
2. **Application Context (Continuations)**: For your specific business logic and data flow.

## 1. Framework Context (`AsyncLocalStorage`)

Lumenize uses Node.js's `AsyncLocalStorage` under the hood to manage **Call Context**. This ensures that properties like `this.lmz.callContext` are always accurate for the current request, even across multiple asynchronous hops.

### Why we use it for Infrastructure
*   **Magic-Free Consistency**: You don't have to manually pass auth tokens or caller IDs into every single function. They are "just there" when you need them.
*   **Race-Safe**: Even when multiple requests to the same DO interleave at `await` points, `AsyncLocalStorage` ensures each request sees its own unique context.
*   **Zero Boilerplate**: Framework-level data is propagated automatically by the mesh.

```typescript
// Any method, anywhere in your call chain
@mesh
doSomething() {
  // Always correct for the current request, thanks to AsyncLocalStorage
  const user = this.lmz.callContext.originAuth?.userId;
}
```

## 2. Application Context (Continuations)

While `AsyncLocalStorage` is great for infrastructure, Lumenize strongly recommends using **Continuations** for your own application data.

### The Problem with ALH for Applications
If you try to use `AsyncLocalStorage` for your business logic (like passing a `requestId` or `startTime`), you run into several issues:
1.  **Type Safety**: ALH stores are typically untyped (`any`).
2.  **Explicitness**: It creates "magic global state" that is hard to trace during debugging.
3.  **Consistency Risk**: ALH encourages using `async/await` in your handlers, which breaks Durable Object input/output gates and leads to race conditions.

### The Better Way: Continuations
Continuations capture context using standard JavaScript closures and pass them as explicit parameters to your handlers.

```typescript
// 1. Capture context at the call site
const startTime = Date.now();

this.lmz.call(
  'TARGET_DO', 
  id, 
  this.ctn<TargetDO>().process(),
  this.ctn().handleResult(startTime) // capture context
);

// 2. Access context in the handler - fully typed and explicit
handleResult(result: any | Error, startTime: number) {
  console.log(`Operation took ${Date.now() - startTime}ms`);
}
```

## Side-by-Side Comparison

| Feature | AsyncLocalStorage (Infrastructure) | Continuations (Application) |
| :--- | :--- | :--- |
| **Best For** | Auth, Identity, Trace IDs | Business IDs, Timestamps, Retry counts |
| **Type Safety** | ❌ Runtime access (`any`) | ✅ Compile-time typed |
| **Explicitness** | ❌ Implicit/Global | ✅ Explicit/Parameters |
| **Hibernation** | ⚠️ Lost if DO hibernates | ✅ **Survives** (if passed as parameters) |
| **DO Consistency**| ⚠️ Risk if handlers use `await` | ✅ Safe (encourages sync handlers) |

## Hibernation & Long-Running Operations

Durable Objects can hibernate (evict from memory) at any time, especially during long-running asynchronous operations like the **"Two One-Way Call"** pattern used in `@lumenize/fetch`.

### Context During Normal Calls

For typical `this.lmz.call()` operations, `callContext` is available in your handler because both execute in the same async context:

```typescript
this.lmz.call(
  'VALIDATION_WORKER',
  undefined,
  this.ctn<ValidationWorker>().validate(data),
  this.ctn().handleResult(this.ctn().$result)
);

// callContext is available here
handleResult(result: any | Error) {
  const userId = this.lmz.callContext.originAuth?.userId;
  console.log(`Result for ${userId}:`, result);
}
```

### Hibernation Risk

If a DO hibernates while waiting for a response, the in-flight call is lost — your handler never executes. This affects `this.lmz.call()` with a handler continuation.

For hibernation-safe patterns:
- Use **[Two One-Way Calls](./calls#cost-optimization-two-one-way-calls)** — the DO returns immediately, nothing to lose
- Use **[@lumenize/alarms](/docs/alarms)** — persists continuations to storage with automatic context capture

### Manual Persistence (Power Users)

If you're building your own hibernation-safe patterns outside the standard tools, explicitly serialize and store the continuation:

```typescript
import { getOperationChain } from '@lumenize/mesh';

// getOperationChain captures callContext automatically
const chain = getOperationChain(this.ctn().myHandler(data));

// Save to storage — KV handles Dates, Maps, Sets, cycles, etc. natively
this.ctx.storage.kv.put('my-key', chain);
```

For SQL TEXT columns, use `stringify()`/`parse()` from `@lumenize/structured-clone`.

**Key insight**: `getOperationChain()` captures `callContext` at the moment you call it. But that capture only survives hibernation if YOU store it somewhere. The framework doesn't do that automatically.

## Why This Matters for Durable Objects

Durable Objects are designed around **single-threaded consistency**. The choice of context management directly impacts this:

### The "Await" Quirk
Every time you `await` in a Durable Object, you yield execution. This opens the input "gate" and allows other requests to enter. If your handler is `async`, you risk data corruption if you don't carefully manage state transitions.

### The "Continuation" Advantage
Continuation handlers are **synchronous** by design. When a remote call completes, Lumenize executes your handler immediately. Because there is no `await` inside the handler, no other request can interleave, ensuring your mutations are atomic and safe.

## Conclusion: The Golden Rule

> **"Let Lumenize handle the Mesh context via `this.lmz`; handle your own application context via `.ctn().handler(context)`."**

By following this strategy, you get the best of both worlds: the zero-boilerplate convenience of a mesh and the rock-solid reliability of type-safe, synchronous Durable Objects.

