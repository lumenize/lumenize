---
title: Getting Started
description: Build a collaborative document editor with the Lumenize Mesh
---

import MeshArchitectureDiagram from '../_partials/_mesh-architecture-diagram.mdx';

# Getting Started

This tutorial builds a **collaborative document editor** using all mesh node types. By the end, you'll have:

- A `DocumentDO` that stores document content and notifies collaborators
- A `SpellCheckWorker` that checks spelling via an external API
- An `EditorClient` that runs in the browser and receives real-time updates

## What You'll Build

With the exception of the Workspace LumenizeDO, which we leave as a potential exercise for the reader, we will flesh out the nodes in this diagram:

<MeshArchitectureDiagram />

**Call flows:**
1. **User edits** → Client → Gateway → DocumentDO
2. **DocumentDO notifies** → Gateway → Client (real-time update)
3. **DocumentDO spell checks** → SpellCheckWorker → DocumentDO → Gateway → Client

## Prerequisites

```bash @skip-check
npm install @lumenize/mesh @lumenize/auth @lumenize/utils
```

## Step 1: Define the Document DO

`LumenizeDO` is for **stateful server-side logic**. It has persistent SQL/KV storage and can receive calls from any mesh node.

```typescript @skip-check
// src/document-do.ts
import { LumenizeDO, mesh } from '@lumenize/mesh';
import type { SpellCheckWorker, SpellFinding } from './spellcheck-worker';
import type { EditorClient } from './editor-client';

export class DocumentDO extends LumenizeDO<Env> {
  // Require authentication for all mesh calls
  onBeforeCall() {
    super.onBeforeCall();  // For now, this is a no-op
    if (!this.lmz.callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }

  @mesh
  update(content: string) {
    this.ctx.storage.kv.put('content', content);

    // Notify all subscribers with new content
    this.#broadcastContent(content);

    // Trigger spell check
    this.lmz.call(
      'SPELLCHECK_WORKER',
      undefined,
      this.ctn<SpellCheckWorker>().check(content),
      this.ctn().handleSpellCheckResult(this.ctn().$result)
    );
  }

  @mesh
  subscribe(): string {
    const clientId = this.lmz.callContext.caller.instanceName;
    if (clientId) {
      const subscribers: Set<string> = this.ctx.storage.kv.get('subscribers') ?? new Set();
      subscribers.add(clientId);
      this.ctx.storage.kv.put('subscribers', subscribers);
    }
    return this.ctx.storage.kv.get('content') ?? '';
  }

  @mesh
  unsubscribe() {
    const clientId = this.lmz.callContext.caller.instanceName;
    if (clientId) {
      const subscribers: Set<string> = this.ctx.storage.kv.get('subscribers') ?? new Set();
      subscribers.delete(clientId);
      this.ctx.storage.kv.put('subscribers', subscribers);
    }
  }

  // Response handler — no @mesh needed (see Design Insights below)
  handleSpellCheckResult(findings: SpellFinding[] | Error) {
    if (findings instanceof Error) {
      console.error('Spell check failed:', findings);
      return;
    }
    this.#broadcastSpellFindings(findings);
  }

  #broadcastContent(content: string) {
    const subscribers: Set<string> = this.ctx.storage.kv.get('subscribers') ?? new Set();
    for (const clientId of subscribers) {
      this.lmz.call(
        'LUMENIZE_CLIENT_GATEWAY',
        clientId,
        this.ctn<EditorClient>().handleContentUpdate(content)
      );
    }
  }

  #broadcastSpellFindings(findings: SpellFinding[]) {
    const subscribers: Set<string> = this.ctx.storage.kv.get('subscribers') ?? new Set();
    for (const clientId of subscribers) {
      this.lmz.call(
        'LUMENIZE_CLIENT_GATEWAY',
        clientId,
        this.ctn<EditorClient>().handleSpellFindings(findings)
      );
    }
  }
}
```

**Key patterns:**
- `onBeforeCall()` enforces authentication at the class level
- `@mesh` decorator exposes methods as entry points
- `this.lmz.call()` makes fire-and-forget or request/response calls
- `this.ctn<T>()` builds type-safe continuations for remote methods

### Design Insights

| Pattern | Why It Matters |
|---------|----------------|
| No `async`/`await` | Continuations describe work; framework handles timing. Avoids race conditions. |
| No instance variables | State in storage survives hibernation/eviction. Reads are cached and cheap (writes cost 10,000x more). |
| Response handlers skip `@mesh` | Framework trusts your own continuations — only entry points need the decorator. |
| `@mesh(guard)` not shown | Fine-grained permissions per method. See [Security](./security#method-level-guards). |

## Step 2: Define the Spell Check Worker

`LumenizeWorker` is for **stateless server-side logic**. It's perfect for proxying external APIs, compute-intensive tasks, or offloading fanout.

```typescript @skip-check
// src/spellcheck-worker.ts
import { LumenizeWorker, mesh } from '@lumenize/mesh';

export interface SpellFinding {
  word: string;
  position: number;
  suggestions: string[];
}

export class SpellCheckWorker extends LumenizeWorker<Env> {
  @mesh
  async check(content: string): Promise<SpellFinding[]> {
    // Call external spell check API
    const response = await fetch('https://api.spellcheck.example/check', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: content }),
    });

    if (!response.ok) {
      throw new Error(`Spell check API error: ${response.status}`);
    }

    return response.json();
  }
}
```

**Key patterns:**
- Workers can be `async` — they don't have the same consistency constraints as DOs
- Workers have no instance name (pass `undefined` to `lmz.call`)

:::tip Cost Optimization
For long-running external calls, consider using `@lumenize/fetch` with the "two one-way call" pattern to avoid DO wall-clock billing while waiting for long-running (>2s) responses.
:::

## Step 3: Define the Browser Client

`LumenizeClient` runs in the browser and is a **full mesh peer** — it can both make and receive calls.

```typescript @skip-check
// src/editor-client.ts
import { LumenizeClient, mesh, type LumenizeClientConfig } from '@lumenize/mesh';
import type { DocumentDO } from './document-do';
import type { SpellFinding } from './spellcheck-worker';

export class EditorClient extends LumenizeClient {
  #editor: any; // Your editor instance
  #documentId: string;

  constructor(config: LumenizeClientConfig, editor: any, documentId: string) {
    super(config);
    this.#editor = editor;
    this.#documentId = documentId;

    // Subscribe and load initial content
    this.#subscribe();
  }

  // Called by DocumentDO when another user edits the document
  @mesh
  handleContentUpdate(content: string) {
    this.#editor.setContent(content);
  }

  // Called by DocumentDO with spell check results
  @mesh
  handleSpellFindings(findings: SpellFinding[]) {
    this.#editor.highlightFindings(findings);
  }

  // Called when reconnecting after grace period expired
  onSubscriptionsLost = () => {
    this.#subscribe();
  };

  // Public method for your UI to call
  saveContent(content: string) {
    this.lmz.call(
      'DOCUMENT_DO',
      this.#documentId,
      this.ctn<DocumentDO>().update(content)
    );
  }

  #subscribe() {
    this.lmz.call(
      'DOCUMENT_DO',
      this.#documentId,
      this.ctn<DocumentDO>().subscribe(),
      this.ctn().#handleSubscribeResult(this.ctn().$result)
    );
  }

  #handleSubscribeResult(content: string | Error) {
    if (content instanceof Error) {
      console.error('Failed to subscribe:', content);
      return;
    }
    this.#editor.setContent(content);
  }
}
```

**Key patterns:**
- Extend `LumenizeClient` and define `@mesh` methods for incoming calls
- `onSubscriptionsLost` handles resubscription. This is only called if auto-reconnect is unsuccessful within the 5-second grace period
- The client can call any mesh node using the same `this.lmz.call()` API
- Results can be `Error` — always check before using

## Step 4: Connect from the Browser

```typescript @skip-check
// In your browser application
import { EditorClient } from './editor-client';

async function initEditor(accessToken: string, userId: string, documentId: string) {
  const editor = createYourEditor(); // Your editor library

  // Create and connect the client
  using client = new EditorClient(
    {
      baseUrl: 'wss://collab-editor.your-cloudflare-account.workers.dev',
      instanceName: `${userId}.${getTabId()}`,
      accessToken,
      onConnectionStateChange: (state) => {
        updateConnectionIndicator(state);
      },
      onAuthenticationError: () => {
        redirectToLogin();
      }
    },
    editor,
    documentId
  );

  // Wire up editor changes
  editor.onChange = (change) => {
    client.saveContent(change);
  };
}

function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}
```

## Step 5: Set Up the Worker Entry Point

The Worker routes requests to DOs and handles authentication. See [Security](./security) for details on token handling and key rotation.

```typescript @skip-check
// src/index.ts
import { LumenizeAuth, createAuthMiddleware, createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';
import { DocumentDO } from './document-do';
import { SpellCheckWorker } from './spellcheck-worker';

export { LumenizeAuth, DocumentDO, SpellCheckWorker };
// Note: LumenizeClientGateway is exported from @lumenize/mesh

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - public (no middleware)
    const authResponse = await routeDORequest(request, env, {
      prefix: 'auth',
      cors: true
    });
    if (authResponse) return authResponse;

    // Create auth middleware (accepts BLUE and/or GREEN keys for rotation)
    const publicKeys = [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN].filter(Boolean);
    const httpAuth = await createAuthMiddleware({ publicKeysPem: publicKeys });
    const wsAuth = await createWebSocketAuthMiddleware({ publicKeysPem: publicKeys });

    // Protected routes
    return routeDORequest(request, env, {
      onBeforeRequest: httpAuth,
      onBeforeConnect: wsAuth,
      cors: true
    }) ?? new Response('Not Found', { status: 404 });
  }
};
```

:::note Coming Soon
`createLumenizeRouter` will provide this setup with sensible defaults, reducing the boilerplate above to a single function call.
:::

## Step 6: Configure wrangler.jsonc

```jsonc @skip-check
{
  "name": "collab-editor",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      { "name": "LUMENIZE_AUTH", "class_name": "LumenizeAuth" },
      { "name": "DOCUMENT_DO", "class_name": "DocumentDO" },
      { "name": "LUMENIZE_CLIENT_GATEWAY", "class_name": "LumenizeClientGateway" }
    ]
  },
  "services": [
    {
      "binding": "SPELLCHECK_WORKER",
      "service": "collab-editor",
      "entrypoint": "SpellCheckWorker"
    }
  ],
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["LumenizeAuth", "DocumentDO", "LumenizeClientGateway"]
    }
  ]
}
```

:::note `SpellCheckWorker`
The `SpellCheckWorker` is a [named entrypoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/#named-entrypoints) in the same Worker, bound via `services`.
:::
