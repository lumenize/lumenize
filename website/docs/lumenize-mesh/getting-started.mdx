---
title: Getting Started
description: Build a collaborative document editor with the Lumenize Mesh
---

# Getting Started

This tutorial builds a **collaborative document editor** using all mesh node types. By the end, you'll have:

- A `DocumentDO` that stores document content and notifies collaborators
- A `SpellCheckWorker` that checks spelling via an external API
- An `EditorClient` that runs in the browser and receives real-time updates

## Prerequisites

```bash @skip-check
npm install @lumenize/mesh @lumenize/core @lumenize/auth @lumenize/utils
```

---

## Step 1: Define the Document DO

`LumenizeDO` is for **stateful server-side logic**. It has persistent SQL/KV storage and can receive calls from any mesh node.

```typescript @skip-check
// src/document-do.ts
import '@lumenize/core';
import { LumenizeDO, mesh } from '@lumenize/mesh';

interface DocumentChange {
  type: 'insert' | 'delete';
  position: number;
  text?: string;
  length?: number;
}

export class DocumentDO extends LumenizeDO<Env> {
  #subscribers = new Set<string>();

  // Initialize schema (runs once, safely wrapped in blockConcurrencyWhile)
  async onStart() {
    this.svc.sql`
      CREATE TABLE IF NOT EXISTS documents (
        id TEXT PRIMARY KEY,
        content TEXT NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `;
  }

  // Require authentication for all mesh calls
  onBeforeCall(callContext: CallContext) {
    super.onBeforeCall(callContext);
    if (!callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }

  @mesh
  update(changes: DocumentChange) {
    // Apply changes to storage
    const content = this.ctx.storage.kv.get('content') ?? '';
    const newContent = this.#applyChanges(content, changes);
    this.ctx.storage.kv.put('content', newContent);
    this.ctx.storage.kv.put('updated_at', Date.now());

    // Notify all subscribers
    this.#notifySubscribers(changes);

    // Trigger spell check (fire-and-forget)
    this.lmz.call(
      'SPELLCHECK_WORKER',
      undefined,
      this.ctn<SpellCheckWorker>().check(newContent),
      this.ctn().handleSpellCheckResult(this.ctn().$result)
    );
  }

  @mesh
  getContent(): string {
    return this.ctx.storage.kv.get('content') ?? '';
  }

  @mesh
  subscribe() {
    const clientId = this.lmz.callContext.caller.instanceName;
    if (clientId) {
      this.#subscribers.add(clientId);
    }
  }

  @mesh
  unsubscribe() {
    const clientId = this.lmz.callContext.caller.instanceName;
    if (clientId) {
      this.#subscribers.delete(clientId);
    }
  }

  // Response handler — no @mesh needed (see tip below)
  handleSpellCheckResult(errors: SpellError[] | Error) {
    if (errors instanceof Error) {
      console.error('Spell check failed:', errors);
      return;
    }
    this.ctx.storage.kv.put('spellErrors', errors);
    this.#notifySubscribers({ type: 'spell_errors', errors });
  }

  // Internal: notify all connected clients
  #notifySubscribers(change: any) {
    for (const clientId of this.#subscribers) {
      this.lmz.call(
        'LUMENIZE_CLIENT_GATEWAY',
        clientId,
        this.ctn<EditorClient>().handleDocumentChange(change)
      );
    }
  }

  #applyChanges(content: string, changes: DocumentChange): string {
    // Simplified - real implementation would handle operational transforms
    if (changes.type === 'insert') {
      return content.slice(0, changes.position) + 
             changes.text + 
             content.slice(changes.position);
    } else {
      return content.slice(0, changes.position) + 
             content.slice(changes.position + (changes.length ?? 0));
    }
  }
}
```

**Key patterns:**
- `onBeforeCall()` enforces authentication at the class level
- `@mesh` decorator exposes methods as entry points
- `this.lmz.call()` makes fire-and-forget and request/response calls
- `this.ctn<T>()` builds type-safe continuations for remote methods
- `this.svc.sql` provides NADIS-injected SQL access

:::tip Response Handlers Don't Need @mesh
Notice that `handleSpellCheckResult` lacks the `@mesh` decorator. Response handlers in continuations you author yourself (via `this.ctn().myHandler(...)`) don't need `@mesh` — the framework trusts that you're calling your own methods. Only methods that external mesh nodes call as **entry points** need the decorator.
:::

---

## Step 2: Define the Spell Check Worker

`LumenizeWorker` is for **stateless server-side logic**. It's perfect for proxying external APIs or compute-intensive tasks.

```typescript @skip-check
// src/spellcheck-worker.ts
import { LumenizeWorker, mesh } from '@lumenize/mesh';

export interface SpellError {
  word: string;
  position: number;
  suggestions: string[];
}

export class SpellCheckWorker extends LumenizeWorker<Env> {
  @mesh
  async check(content: string): Promise<SpellError[]> {
    // Call external spell check API
    const response = await fetch('https://api.spellcheck.example/check', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: content }),
    });

    if (!response.ok) {
      throw new Error(`Spell check API error: ${response.status}`);
    }

    return response.json();
  }
}
```

**Key patterns:**
- Workers can be `async` — they don't have the same consistency constraints as DOs
- Workers have no instance name (pass `undefined` to `lmz.call`)
- Workers can make external HTTP calls directly

:::tip Cost Optimization
For long-running external calls, consider using `@lumenize/fetch` with the "two one-way call" pattern to avoid DO wall-clock billing while waiting for the response.
:::

---

## Step 3: Define the Browser Client

`LumenizeClient` runs in the browser and is a **full mesh peer** — it can both make and receive calls.

```typescript @skip-check
// src/editor-client.ts
import { LumenizeClient, mesh } from '@lumenize/mesh';

interface DocumentChange {
  type: string;
  [key: string]: any;
}

export class EditorClient extends LumenizeClient {
  #editor: any; // Your editor instance
  #documentId: string;

  constructor(config: LumenizeClientConfig & { editor: any; documentId: string }) {
    super(config);
    this.#editor = config.editor;
    this.#documentId = config.documentId;
  }

  // Called by DocumentDO when content changes
  @mesh
  handleDocumentChange(change: DocumentChange) {
    if (change.type === 'spell_errors') {
      this.#editor.highlightErrors(change.errors);
    } else {
      this.#editor.applyChange(change);
    }
  }

  // Called when reconnecting after grace period expired
  onSubscriptionsLost = () => {
    // Re-subscribe to the document
    this.lmz.call(
      'DOCUMENT_DO',
      this.#documentId,
      this.ctn<DocumentDO>().subscribe()
    );
  };

  // Public method for your UI to call
  sendChange(change: DocumentChange) {
    this.lmz.call(
      'DOCUMENT_DO',
      this.#documentId,
      this.ctn<DocumentDO>().update(change)
    );
  }

  loadDocument() {
    this.lmz.call(
      'DOCUMENT_DO',
      this.#documentId,
      this.ctn<DocumentDO>().getContent(),
      this.ctn().handleContentLoaded(this.ctn().$result)
    );
  }

  handleContentLoaded(content: string | Error) {
    if (content instanceof Error) {
      console.error('Failed to load document:', content);
      return;
    }
    this.#editor.setContent(content);
  }
}
```

**Key patterns:**
- Extend `LumenizeClient` and define `@mesh` methods for incoming calls
- `onSubscriptionsLost` handles reconnection after the 5-second grace period
- The client can call any mesh node using the same `this.lmz.call()` API
- Results can be `Error` — always check before using

---

## Step 4: Set Up the Worker Entry Point

The Worker routes requests to DOs and handles authentication:

```typescript @skip-check
// src/index.ts
import { LumenizeAuth, createAuthMiddleware, createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';
import { DocumentDO } from './document-do';
import { SpellCheckWorker } from './spellcheck-worker';

export { LumenizeAuth, DocumentDO, SpellCheckWorker };
// Note: LumenizeClientGateway is exported from @lumenize/mesh

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - public (no middleware)
    const authResponse = await routeDORequest(request, env, {
      prefix: 'auth',
      cors: true
    });
    if (authResponse) return authResponse;

    // Create auth middleware
    const httpAuth = await createAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });
    const wsAuth = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });

    // Protected routes
    return routeDORequest(request, env, {
      onBeforeRequest: httpAuth,
      onBeforeConnect: wsAuth,
      cors: true
    }) ?? new Response('Not Found', { status: 404 });
  }
};
```

---

## Step 5: Configure wrangler.jsonc

```jsonc @skip-check
{
  "name": "collab-editor",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      { "name": "LUMENIZE_AUTH", "class_name": "LumenizeAuth" },
      { "name": "DOCUMENT_DO", "class_name": "DocumentDO" },
      { "name": "LUMENIZE_CLIENT_GATEWAY", "class_name": "LumenizeClientGateway" }
    ]
  },
  "services": [
    {
      "binding": "SPELLCHECK_WORKER",
      "service": "collab-editor",
      "entrypoint": "SpellCheckWorker"
    }
  ],
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["LumenizeAuth", "DocumentDO"] }
  ]
}
```

:::note Binding Types
- **Durable Objects** use `durable_objects.bindings` — each has named instances
- **Workers** use `services` — stateless, no instance name (pass `undefined` to `lmz.call`)
- **Gateway** needs no migration — it uses zero storage

The `SpellCheckWorker` is a [named entrypoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/#named-entrypoints) in the same Worker, bound via `services`.
:::

---

## Step 6: Connect from the Browser

```typescript @skip-check
// In your browser application
import { EditorClient } from './editor-client';

async function initEditor(accessToken: string, userId: string, documentId: string) {
  const editor = createYourEditor(); // Your editor library

  // Create and connect the client
  using client = new EditorClient({
    baseUrl: 'wss://collab-editor.your-account.workers.dev',
    instanceName: `${userId}.${getTabId()}`,
    accessToken,
    editor,
    documentId,
    onConnectionStateChange: (state) => {
      updateConnectionIndicator(state);
    },
    onConnectionError: (error) => {
      if (error.message.includes('401')) {
        redirectToLogin();
      }
    }
  });

  // Subscribe to updates and load content
  client.lmz.call('DOCUMENT_DO', documentId, client.ctn<DocumentDO>().subscribe());
  client.loadDocument();

  // Wire up editor changes
  editor.onChange = (change) => {
    client.sendChange(change);
  };
}

function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}
```

---

## What You've Built

```
┌─────────────────────────────────────────────────────────────────────┐
│                        ☁️ Cloudflare                                │
│                                                                     │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────────────┐   │
│  │ DocumentDO  │◄───►│ SpellCheck  │     │ LumenizeClientGateway│   │
│  │ (draft-1)   │     │   Worker    │     │   (alice.tab1)       │   │
│  └─────────────┘     └─────────────┘     └──────────┬───────────┘   │
│         ▲                                           │               │
│         │                                           │               │
│         └───────────────────────────────────────────┘               │
│                              ▲                                      │
└──────────────────────────────│──────────────────────────────────────┘
                               │ WebSocket
                    ┌──────────▼──────────┐
                    │    EditorClient     │
                    │    (Browser)        │
                    └─────────────────────┘
```

**Call flows:**
1. **User edits** → Client → Gateway → DocumentDO
2. **DocumentDO notifies** → Gateway → Client (real-time update)
3. **DocumentDO spell checks** → SpellCheckWorker → DocumentDO → Gateway → Client

---

## Next Steps

- **[LumenizeDO Reference](./lumenize-do)** — Full API, NADIS plugins, storage patterns
- **[LumenizeClient Reference](./lumenize-client)** — Connection lifecycle, access control
- **[Auth Integration](./auth-integration)** — Token refresh, WebSocket auth, callContext
- **[Gateway Internals](./gateway)** — Zero-storage design, grace periods

