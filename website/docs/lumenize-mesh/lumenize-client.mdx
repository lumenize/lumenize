---
title: LumenizeClient
description: Browser and Node.js clients as full mesh peers
---

# LumenizeClient

`LumenizeClient` is the base class for **client-side mesh nodes** running in browsers or Node.js. Clients are full mesh peers — they can both make and receive calls.

## Installation

```bash @skip-check
npm install @lumenize/mesh
```

---

## Quick Start

```typescript @skip-check
import { LumenizeClient, mesh } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  // Called by DocumentDO when content changes
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
  
  // Called for collaborative cursor updates
  @mesh
  handleCursorUpdate(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}

using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: jwt
});
```

:::info `using` Keyword (TypeScript 5.2+)
The `using` keyword ensures the client automatically disconnects when the scope exits. It's TC39's [Explicit Resource Management](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management) — think of it as `try/finally` for cleanup.
:::

**Why extend a class?** In a word, "consistency". All nodes in the Lumenize Mesh are full peers that can make and receive calls. You define incoming call handlers as `@mesh` methods on your subclass.

---

## Configuration

The `LumenizeClient` constructor takes a configuration object:

### Connection & Identity

| Option | Type | Description |
|--------|------|-------------|
| `baseUrl` | `string` | Base URL for WebSocket connection (e.g., `wss://app.example.com`) |
| `instanceName` | `string` | Unique client identifier. Recommended: `${userId}.${tabId}` |
| `gatewayBinding` | `string?` | [Gateway](./gateway) DO binding name. Default: `LUMENIZE_CLIENT_GATEWAY` |

### Authentication

| Option | Type | Description |
|--------|------|-------------|
| `accessToken` | `string` | Initial JWT access token |
| `refreshEndpoint` | `string?` | Token refresh endpoint. Default: `/auth/refresh-token` |

### Lifecycle Callbacks

| Option | Type | Description |
|--------|------|-------------|
| `onConnectionStateChange` | `(state) => void` | Called with `connecting`, `connected`, `reconnecting`, or `disconnected` |
| `onConnectionError` | `(error) => void` | Called when WebSocket connection error occurs |
| `onAuthenticationError` | `(error) => void` | Called on any authentication failure (token refresh failed, connection rejected, session expired) |
| `onSubscriptionsLost` | `() => void` | Called when reconnecting after grace period expired |

---

## The `this.lmz` API

Clients have the same `this.lmz` API as DOs and Workers:

```typescript @skip-check
this.lmz.type           // 'LumenizeClient'
this.lmz.bindingName    // 'LUMENIZE_CLIENT_GATEWAY' (or custom)
this.lmz.instanceName   // Your instanceName (e.g., 'alice.tab1')
this.lmz.callContext    // Current request's context (during handler execution)
```

### Making Calls

```typescript @skip-check
// Fire-and-forget
client.lmz.call('DOCUMENT_DO', id, client.ctn<DocumentDO>().update(change));

// With response handler
client.lmz.call(
  'DOCUMENT_DO', 
  id, 
  client.ctn<DocumentDO>().getContent(),
  client.ctn().handleContent(client.ctn().$result)
);

// Chaining operations in one round trip
client.lmz.call(
  'DOCUMENT_DO',
  id,
  client.ctn<DocumentDO>().validate().save().getRevision()
);
```

### Receiving Calls

Define `@mesh` methods for incoming calls from mesh nodes:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}
```

### Local vs Mesh Calls

Methods on your client class can be called two ways:

| Call Origin | Example | Access Control |
|-------------|---------|----------------|
| **Local** (your browser code) | `client.sendChange(change)` | No checks — direct method call |
| **Mesh** (from DO/Worker) | Via `this.lmz.call()` to Gateway | `@mesh` decorator required |

This means you can have both public methods for your UI and `@mesh` methods for the mesh on the same class:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  // Called by your browser code — no @mesh needed
  sendChange(change: DocumentChange) {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().update(change));
  }

  // Called by mesh nodes — requires @mesh
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}
```

---

## Connection Lifecycle

### Automatic Connection

The WebSocket connection is established automatically upon instantiation. You don't need to call `connect()` manually.

### Resource Cleanup

Use the `using` keyword for automatic cleanup:

```typescript @skip-check
{
  using client = new EditorClient(config);
  // ...
} // disconnects here
```

Or call `disconnect()` manually:

```typescript @skip-check
client.disconnect();
```

### Connection State

Monitor state changes via the callback:

```typescript @skip-check
using client = new MyClient({
  onConnectionStateChange: (state) => {
    const isOnline = state === 'connected';
    const isPending = state === 'connecting' || state === 'reconnecting';
    updateUI({ isOnline, isPending });
  }
});
```

Or check programmatically:

```typescript @skip-check
if (client.connectionState === 'connected') {
  // Safe to make calls
}
```

---

## Access Control

LumenizeClient has the same **secure-by-default** model as DOs and Workers.

### Default: Peer Calls Rejected

By default, clients reject calls from other clients (peer-to-peer):

```typescript @skip-check
class LumenizeClient {
  // Default implementation
  onBeforeCall(callContext: CallContext) {
    if (callContext.origin.type === 'LumenizeClient') {
      throw new Error('Peer-to-peer calls not allowed');
    }
  }
}
```

With this default:
- ✅ Calls from DOs and Workers are allowed
- ❌ Calls from other clients are rejected

### Opting In to Peer Communication

For collaborative features (cursors, voice/video signaling), override `onBeforeCall`:

```typescript @skip-check
class CollaborativeClient extends LumenizeClient {
  onBeforeCall(callContext: CallContext) {
    // Note: NOT calling super.onBeforeCall() — we WANT to allow peers
    if (callContext.origin.type === 'LumenizeClient') {
      // Allow peers, but require authentication
      if (!callContext.originAuth?.userId) {
        throw new Error('Authentication required for peer calls');
      }
    }
  }
  
  @mesh
  handlePeerCursor(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}
```

### Method-Level Guards

Guards needing instance state receive the instance as a second parameter:

```typescript @skip-check
@mesh((callContext, instance: EditorClient) => {
  if (callContext.caller.instanceName !== instance.documentId) {
    throw new Error('Change from unexpected source');
  }
})
handleDocumentChange(change: DocumentChange) {
  this.editor.applyChange(change);
}
```

See [Security](./security#access-control) for the complete security model including reusable guards.

---

## Reconnection & Subscription Loss

LumenizeClient handles flaky networks and tab hibernation automatically.

### Grace Period

When disconnected, the mesh maintains client state for a **5-second grace period**:

- **Within 5 seconds**: Reconnection is seamless — all subscriptions remain active
- **After 5 seconds**: Mesh nodes may clean up resources

### Handling Subscription Loss

When reconnecting after the grace period, `onSubscriptionsLost` is called:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  onSubscriptionsLost = () => {
    // Re-establish subscriptions
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}
```

---

## Error Handling

### Connection Errors

```typescript @skip-check
onConnectionError: (error) => {
  console.error('Network failure:', error.message);
  if (error.message.includes('401')) {
    redirectToLogin();
  }
  showOfflineBanner();
}
```

### Call Errors

Results can be `Error` — always check:

```typescript @skip-check
handleContentLoaded(result: string | Error) {
  if (result instanceof Error) {
    console.error('Call failed:', result.message);
    return;
  }
  this.editor.setContent(result);
}
```

---

## Browser Considerations

### Tab Identity

Each browser tab should have its own `LumenizeClient` with a unique `instanceName`:

```typescript @skip-check
function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}

using client = new MyClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${getTabId()}`
});
```

### Hibernation and Backgrounding

No manual handling needed. `LumenizeClient` automatically:
- Detects when a tab is "woken up"
- Immediately attempts reconnection
- Triggers `onSubscriptionsLost` if beyond the grace period

---

## API Reference

### Class: `LumenizeClient`

**Constructor:**
```typescript @skip-check
constructor(config: LumenizeClientConfig)
```

**Properties:**
- `connectionState: ConnectionState` — Current state
- `lmz: LmzApi` — Mesh communication API

**Methods:**
- `ctn<T>()` — Create typed continuation builder
- `connect()` — Manually reconnect
- `disconnect()` — Close connection
- `[Symbol.dispose]()` — Auto-cleanup (enables `using` keyword)

**Overridable Methods:**
- `onBeforeCall(callContext: CallContext)` — Class-wide access control

### Type: `ConnectionState`

```typescript @skip-check
type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';
```

### Type: `LumenizeClientConfig`

```typescript @skip-check
interface LumenizeClientConfig {
  baseUrl: string;
  instanceName: string;
  gatewayBinding?: string;
  accessToken: string;
  refreshEndpoint?: string;
  onConnectionStateChange?: (state: ConnectionState) => void;
  onConnectionError?: (error: Error) => void;
  onAuthenticationError?: (error: Error) => void;
  onSubscriptionsLost?: () => void;
}
```

---

## Testing

`LumenizeClient` accepts a `WebSocket` constructor option, enabling integration testing without running a separate server:

```typescript @skip-check
import { Browser } from '@lumenize/testing';

it('tests client-DO communication', async () => {
  const browser = new Browser();  // Cookie simulation, CORS support
  
  using client = new EditorClient({
    baseUrl: 'wss://example.com',
    instanceName: 'test-user.tab1',
    accessToken: testJwt,
    WebSocket: browser.WebSocket,  // Inject testing WebSocket
  });
  
  // Test interactions...
});
```

The `Browser` class provides:
- **Cookie simulation** — Critical for testing token refresh flows
- **Realistic CORS behavior** — Catches preflight issues before production
- **Injectable WebSocket** — Connects through `vitest-pool-workers` to real DO instances

See **[@lumenize/testing: Agents](/docs/testing/agents)** for complete patterns including multi-user scenarios and authentication testing.

---

## See Also

- **[Getting Started](./getting-started)** — Build a complete app
- **[Security](./security)** — Token handling and security
- **[Gateway Internals](./gateway)** — How client-mesh bridging works

