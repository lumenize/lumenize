---
title: LumenizeClient
description: Browser and Node.js clients as full mesh peers
---

# LumenizeClient

`LumenizeClient` is the base class for **client-side mesh nodes** running in browsers or Node.js. Clients are full mesh peers — they can both make and receive calls.

## Installation

```bash @skip-check
npm install @lumenize/mesh
```

---

## Quick Start

For a complete tutorial building a collaborative document editor, see the [Getting Started Guide](./getting-started). Here's the essence:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

// Fresh login — pass the token you just received
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: jwt
});

// Page refresh — let client fetch token via refresh endpoint (cookie-based)
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`
  // accessToken omitted — will be fetched automatically
});
```

Extend `LumenizeClient` and define `@mesh` methods for incoming calls — the same pattern as `LumenizeDO` and `LumenizeWorker`.

---

## Configuration

The `LumenizeClient` constructor takes a configuration object:

### Connection & Identity

| Option | Type | Description |
|--------|------|-------------|
| `baseUrl` | `string` | Base URL for WebSocket connection (e.g., `wss://app.example.com`) |
| `instanceName` | `string` | Unique client identifier. Recommended: `${userId}.${tabId}` |
| `gatewayBinding` | `string?` | [Gateway](./gateway) DO binding name. Default: `LUMENIZE_CLIENT_GATEWAY` |

### Authentication

| Option | Type | Description |
|--------|------|-------------|
| `accessToken` | `string?` | Initial JWT access token. If omitted, fetched via `refreshEndpoint` on connect. |
| `refreshEndpoint` | `string?` | Token refresh endpoint. Default: `/auth/refresh-token` |

**Token acquisition behavior:**
- **`accessToken` provided**: Use it for initial connection (fresh login scenario)
- **`accessToken` omitted**: Hit `refreshEndpoint` first to get token (page refresh scenario where refresh cookie is still valid)

### Lifecycle Callbacks

| Option | Type | Description |
|--------|------|-------------|
| `onConnectionStateChange` | `(state) => void` | Called with `connecting`, `connected`, `reconnecting`, or `disconnected` |
| `onConnectionError` | `(error) => void` | Low-level WebSocket errors (rarely actionable) |
| `onAuthenticationError` | `(error: AuthenticationError) => void` | Called on auth failure with `code` and `reason` from Gateway close |
| `onSubscriptionsLost` | `() => void` | Called after reconnection if grace period had expired |

---

## Mesh API

`LumenizeClient` shares the standard [Mesh API](./mesh-api) with all node types:

- **`this.lmz`** — Identity properties and `call()` for mesh communication
- **`@mesh` decorator** — Mark methods as mesh entry points
- **`onBeforeCall()`** — Class-wide access control hook
- **`this.ctn<T>()`** — Create type-safe continuations

See [Mesh API](./mesh-api) for full documentation.

### Local vs Mesh Calls

Methods on your client class can be called two ways:

| Call Origin | Example | Access Control |
|-------------|---------|----------------|
| **Local** (your browser code) | `client.sendChange(change)` | No checks — direct method call |
| **Mesh** (from DO/Worker) | Via `this.lmz.call()` to Gateway | `@mesh` decorator required |

This means you can have both public methods for your UI and `@mesh` decorated methods for the mesh on the same class:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  // Called by your browser code — no @mesh needed
  sendChange(change: DocumentChange) {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().update(change));
  }

  // Called by mesh nodes — requires @mesh
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}
```

---

## Connection Lifecycle

### Automatic Connection

The WebSocket connection is established automatically upon instantiation. You don't need to call `connect()` manually.

### Resource Cleanup

Use the `using` keyword for automatic cleanup:

```typescript @skip-check
{
  using client = new EditorClient(config);
  // ...
} // disconnects here
```

Or call `disconnect()` manually:

```typescript @skip-check
client.disconnect();
```

### Connection State

Monitor state changes via the callback:

```typescript @skip-check
using client = new MyClient({
  onConnectionStateChange: (state) => {
    const isOnline = state === 'connected';
    const isPending = state === 'connecting' || state === 'reconnecting';
    updateUI({ isOnline, isPending });
  }
});
```

Or check programmatically:

```typescript @skip-check
if (client.connectionState === 'connected') {
  // Safe to make calls
}
```

---

## Access Control

LumenizeClient has a similar **secure-by-default** model as DOs and Workers. The exception is that calls from other clients are rejected by default:

With this default:
- ✅ Calls from DOs and Workers are allowed
- ❌ Calls from other clients are rejected

### Opting In to Client-to-Client Communication

For collaborative features (cursors, voice/video signaling, etc.), override `onBeforeCall`:

```typescript @skip-check
class CollaborativeClient extends LumenizeClient {
  onBeforeCall(callContext: CallContext) {
    // Note: NOT calling super.onBeforeCall() — we WANT to allow peers
    if (callContext.origin.type === 'LumenizeClient') {
      // Allow peers, but require authentication
      if (!callContext.originAuth?.userId) {
        throw new Error('Authentication required for peer calls');
      }
    }
  }
  
  @mesh
  handlePeerCursor(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}
```

### Method-Level Guards

Add guards to individual methods using the `@mesh` decorator with a guard function. Guards can access instance state via a second parameter.

See [Security](./security#access-control) for guard patterns including [instance access](./security#guards-with-instance-access) and reusable guards.

---

## Reconnection & Subscription Loss

LumenizeClient handles flaky networks and tab hibernation automatically.

### Grace Period

When disconnected, the mesh maintains client state for at least a **5-second grace period**:

- **Within 5 seconds**: Reconnection is seamless — all subscriptions remain active
- **After 5 seconds**: Mesh nodes may clean up resources. Resubscribing is necessary.

### Handling Subscription Loss

When the client reconnects, the Gateway determines whether the grace period expired and notifies the client. If subscriptions were lost, `onSubscriptionsLost` fires after the connection is reestablished:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  onSubscriptionsLost = () => {
    // Re-establish subscriptions
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}
```

---

## Error Handling

### Authentication Errors

When authentication fails, the Gateway closes the connection with a specific close code (4400, 4401, 4403). `LumenizeClient` translates these into `onAuthenticationError` calls:

```typescript @skip-check
using client = new EditorClient({
  accessToken,
  onAuthenticationError: (error) => {
    console.log('Auth failed:', error.code, error.reason);
    window.location.href = '/login';
  }
});
```

See [Security: Auth Close Codes](./security#auth-close-codes) for the full list.

### Call Errors

See [Making Calls: Error Handling](./calls#error-handling) for handling errors in call responses.

---

## Browser Considerations

### Tab Identity

Each browser tab should have its own `LumenizeClient` with a unique `instanceName`. See the [Getting Started Guide](./getting-started#step-4-connect-from-the-browser) for the `getTabId()` helper pattern.

### Hibernation and Backgrounding

No manual handling needed. `LumenizeClient` automatically:
- Detects when a tab is "woken up"
- Immediately attempts reconnection
- Receives subscription status from Gateway and triggers `onSubscriptionsLost` if needed

---

## API Reference

### Class: `LumenizeClient`

**Constructor:**
```typescript @skip-check
constructor(config: LumenizeClientConfig)
```

**Properties:**
- `connectionState: ConnectionState` — Current state
- `lmz: LmzApi` — Mesh communication API

**Methods:**
- `ctn<T>()` — Create typed continuation builder
- `connect()` — Manually reconnect
- `disconnect()` — Close connection
- `[Symbol.dispose]()` — Auto-cleanup (enables `using` keyword)

**Overridable Methods:**
- `onBeforeCall(callContext: CallContext)` — Class-wide access control

See [Mesh API](./mesh-api#api-reference) for shared types (`@mesh`, `CallContext`, `LmzApi`).

### Type: `ConnectionState`

```typescript @skip-check
type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';
```

### Type: `LumenizeClientConfig`

```typescript @skip-check
interface LumenizeClientConfig {
  baseUrl: string;
  instanceName: string;
  gatewayBinding?: string;  // default: LUMENIZE_CLIENT_GATEWAY
  accessToken?: string;  // If omitted, fetched via refreshEndpoint
  refreshEndpoint?: string;
  onConnectionStateChange?: (state: ConnectionState) => void;
  onConnectionError?: (error: Error) => void;  // Rarely actionable
  onAuthenticationError?: (error: AuthenticationError) => void;
  onSubscriptionsLost?: () => void;
}
```

### Type: `AuthenticationError`

```typescript @skip-check
interface AuthenticationError extends Error {
  code: number;   // WebSocket close code (4400, 4401, 4403)
  reason: string; // Close reason from Gateway
}
```

---

## Testing

`LumenizeClient` accepts a `WebSocket` constructor option, enabling integration testing without running a separate server:

```typescript @skip-check
import { Browser } from '@lumenize/testing';

it('tests client-DO communication', async () => {
  const browser = new Browser();  // Cookie simulation, CORS support
  
  using client = new EditorClient({
    baseUrl: 'wss://example.com',
    instanceName: 'test-user.tab1',
    accessToken: testJwt,
    WebSocket: browser.WebSocket,  // Inject testing WebSocket
  });
  
  // Test interactions...
});
```

The `Browser` class provides:
- **Cookie simulation** — Critical for testing token refresh flows
- **Realistic CORS behavior** — Catches preflight issues before production
- **Injectable WebSocket Polyfill** — Connects through `vitest-pool-workers` to real DO instances

See **[@lumenize/testing: Agents](/docs/testing/agents)** for complete patterns including multi-user scenarios and authentication testing.
