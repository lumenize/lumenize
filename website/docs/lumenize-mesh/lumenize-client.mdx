---
title: LumenizeClient
description: Browser and Node.js clients as full mesh peers
---

# LumenizeClient

`LumenizeClient` is the base class for **client-side mesh nodes** running in browsers or Node.js. Clients are full mesh peers — they can both make and receive calls.

## Installation

```bash @skip-check
npm install @lumenize/mesh
```

## Quick Start

For a complete tutorial building a collaborative document editor, see the [Getting Started Guide](./getting-started). Here's the essence:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

// Minimal config — baseUrl defaults to origin, refresh defaults to /auth/refresh-token
using client = new EditorClient({
  instanceName: `${userId}.${tabId}`
});
```

Extend `LumenizeClient` and define `@mesh` methods for incoming calls — the same pattern as `LumenizeDO` and `LumenizeWorker`.

## Configuration

The `LumenizeClient` constructor takes a configuration object:

### Connection & Identity

- **`baseUrl`**: `string?` — Base URL for WebSocket connection. Default: current origin in browsers (e.g., `https://` → `wss://`). Required in Node.js.
- **`instanceName`**: `string` — Unique client identifier. Recommended: `${userId}.${tabId}`
- **`gatewayBindingName`**: `string?` — [Gateway](./gateway) DO binding name. Default: `LUMENIZE_CLIENT_GATEWAY`

### Authentication

- **`refresh`**: `string | () => Promise<string>` — Token refresh source. String = endpoint URL (POST, expects `{ access_token }`). Function = custom refresh logic. Default: `/auth/refresh-token`
- **`accessToken`**: `string?` — Initial JWT access token. If omitted, fetched via `refresh` as needed which is the recommended configuration.

**Custom refresh example** (for non-standard auth providers):
```typescript @skip-check
using client = new EditorClient({
  instanceName: `${userId}.${tabId}`,
  refresh: async () => {
    const response = await fetch('/my/custom/refresh');  // Cookies sent automatically (same-origin)
    const data = await response.json();
    return data.token;  // Return just the access token string
  }
});
```

### Lifecycle Callbacks

- **`onConnectionStateChange`**: `(state) => void` — Called with `connecting`, `connected`, `reconnecting`, or `disconnected`
- **`onAuthenticationError`**: `(error: AuthenticationError) => void` — Called when re-login required (not for routine token refresh)
- **`onSubscriptionsLost`**: `() => void` — Called after reconnection if grace period had expired
- **`onConnectionError`**: `(error) => void` — Low-level WebSocket errors (rarely actionable)

## Mesh API

`LumenizeClient` shares the standard [Mesh API](./mesh-api) with all node types:

- **`this.lmz`** — Identity properties and `call()` for mesh communication
- **`@mesh` decorator** — Mark methods as mesh entry points
- **`onBeforeCall()`** — Class-wide access control hook
- **`this.ctn<T>()`** — Create type-safe continuations

See [Mesh API](./mesh-api) for full documentation.

### Local vs Mesh Calls

Methods on your client class can be called two ways:

| Call Origin | Example | Access Control |
|-------------|---------|----------------|
| **Local** (your browser code) | `client.sendChange(change)` | No checks — direct method call |
| **Mesh** (from DO/Worker) | `this.lmz.call()` via Gateway | `@mesh` decorator required |

This means you can have both public methods for your UI and `@mesh` decorated methods for the mesh on the same class:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  // Called by your browser code — no @mesh needed
  sendChange(change: DocumentChange) {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().update(change));
  }

  // Called by mesh nodes — requires @mesh
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}
```

## Connection Lifecycle

### Automatic Connection

The WebSocket connection is established automatically upon instantiation. You don't need to call `connect()` manually.

### Resource Cleanup

Use the `using` keyword for automatic cleanup as soon as it leaves scope:

```typescript @skip-check
{
  using client = new EditorClient(config);
  // ...
} // disconnects here
```

Or call `disconnect()`/`[Symbol.dispose]()` manually:

```typescript @skip-check
client.disconnect();
```

### Connection State

Monitor state changes via the callback:

```typescript @skip-check
using client = new MyClient({
  onConnectionStateChange: (state) => {
    const isOnline = state === 'connected';
    const isPending = state === 'connecting' || state === 'reconnecting';
    updateUI({ isOnline, isPending });
  }
});
```

Or check programmatically:

```typescript @skip-check
if (client.connectionState === 'connected') {
  // Safe to make calls
}
```

## Access Control

LumenizeClient has almost the exact same **secure-by-default** model as LumenizeDO and LumenizeWorker. The exception is that calls from other clients are rejected by default:

With this default:
- ✅ Calls from LumenizeDOs and LumenizeWorkers are allowed
- ❌ Calls from other clients are rejected

### Opting In to Client-to-Client Communication

For collaborative features (cursors, voice/video signaling, etc.), override `onBeforeCall`:

```typescript @skip-check
class CollaborativeClient extends LumenizeClient {
  onBeforeCall() {
    // Note: NOT calling super.onBeforeCall() — we WANT to allow peers
    const callContext = this.lmz.callContext;
    if (callContext.origin.type === 'LumenizeClient') {
      // Allow peers, but require authentication
      if (!callContext.originAuth?.userId) {
        throw new Error('Authentication required for peer calls');
      }
    }
  }

  @mesh
  handlePeerCursor(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}
```

### Method-Level Guards

Add guards to individual methods using the `@mesh` decorator with a guard function. Guards receive the instance, providing access to both instance state and call context.

See [Security](./security#access-control) for guard patterns including [instance access](./security#guards-with-instance-access) and reusable guards.

## Reconnection & Subscription Loss

LumenizeClient handles flaky networks and tab hibernation automatically.

### Grace Period

When disconnected, the mesh maintains client state for at least a **5-second grace period**:

- **Within 5 seconds**: Reconnection is seamless — all subscriptions remain active
- **After 5 seconds**: Mesh nodes may clean up resources. Resubscribing is necessary.

### Handling Subscription Loss

When the client reconnects, the Gateway determines whether the grace period expired and notifies the client. If subscriptions were lost, `onSubscriptionsLost` fires after the connection is reestablished:

```typescript @skip-check
class EditorClient extends LumenizeClient {
  onSubscriptionsLost = () => {
    // Re-establish subscriptions
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}
```

## Error Handling

### Authentication Errors

Token expiration (4401) is handled automatically — refresh and reconnect happen transparently. `onAuthenticationError` only fires when the user must re-login:

```typescript @skip-check
using client = new EditorClient({
  accessToken,
  onAuthenticationError: (error) => {
    // Only fires when re-login is required:
    // - Refresh token expired (HTTP 401)
    // - (unlikely, but just in case) Invalid token signature (4403)
    // - (unlikely, but just in case) No token provided (4400)
    console.log('Auth failed:', error.code, error.reason);
    window.location.href = '/login';
  }
});
```

See [Security: Auth Close Codes](./security#auth-close-codes) for the full list.

### Call Errors

See [Making Calls: Error Handling](./calls#error-handling) for handling errors in call responses.

## Browser Considerations

### Tab Identity

Each browser tab should have its own `LumenizeClient` with a unique `instanceName`. See the [Getting Started Guide](./getting-started#step-4-connect-from-the-browser) for the `getTabId()` helper pattern.

### Hibernation and Backgrounding

No manual handling needed. `LumenizeClient` automatically:
- Detects when a tab is "woken up"
- Immediately attempts reconnection
- Receives subscription status from Gateway and triggers `onSubscriptionsLost` if needed

## Testing

`LumenizeClient` accepts a `WebSocket` constructor option, enabling integration testing without running a separate server:

```typescript @skip-check
import { Browser } from '@lumenize/testing';

it('tests client-DO communication', async () => {
  const browser = new Browser();  // Cookie simulation, CORS support

  using client = new EditorClient({
    baseUrl: 'wss://example.com',
    instanceName: 'test-user.tab1',
    accessToken: testJwt,
    WebSocket: browser.WebSocket,  // Inject testing WebSocket
  });

  // Test interactions...
});
```

The `Browser` class provides:
- **Cookie simulation** — Critical for testing token refresh flows
- **Realistic CORS behavior** — Catches preflight issues before production
- **Injectable WebSocket Polyfill** — Connects through `vitest-pool-workers` to DO instances running in `vitest-workers-pool`

See **[@lumenize/testing: Agents](/docs/testing/agents)** for complete patterns including multi-user scenarios and authentication testing.

## API Reference

### Class: `LumenizeClient`

**Constructor:**
```typescript @skip-check
constructor(config: LumenizeClientConfig)
```

**Properties:**
- `connectionState: ConnectionState` — Current state
- `lmz: LmzApi` — Mesh communication API

**Methods:**
- `ctn<T>()` — Create typed continuation builder
- `connect()` — Manually reconnect
- `disconnect()` — Close connection and clear internal state
- `[Symbol.dispose]()` — Calls `disconnect()` (enables `using` keyword)

**Overridable Methods:**
- `onBeforeCall()` — Class-wide access control (access context via `this.lmz.callContext`)

See [Mesh API](./mesh-api#api-reference) for shared types (`@mesh`, `CallContext`, `LmzApi`).

### Type: `ConnectionState`

```typescript @skip-check
type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';
```

### Type: `LumenizeClientConfig`

```typescript @skip-check
interface LumenizeClientConfig {
  baseUrl?: string;  // default: current origin in browsers; required in Node.js
  instanceName: string;
  gatewayBindingName?: string;  // default: LUMENIZE_CLIENT_GATEWAY
  accessToken?: string;  // If omitted, fetched via refresh
  refresh?: string | (() => Promise<string>);  // default: /auth/refresh-token
  onConnectionStateChange?: (state: ConnectionState) => void;
  onConnectionError?: (error: Error) => void;  // Rarely actionable
  onAuthenticationError?: (error: AuthenticationError) => void;
  onSubscriptionsLost?: () => void;
}
```

### Type: `AuthenticationError`

```typescript @skip-check
interface AuthenticationError extends Error {
  code: number;   // WebSocket close code (4400, 4401, 4403)
  reason: string; // Close reason from Gateway
}
```
