---
title: "Debug"
description: "Scoped, filterable debug logging optimized for the JSON filter capability in Cloudflare's observability dashboard"
---

# Debug

A de✨light✨ful scoped debug logging system inspired by npm's `debug` package with JSON output that works perfectly with Cloudflare's observability dashboard.

:::tip Built-in Service
This utility is used internally by Lumenize and is also available for your own logging needs. It's automatically available via `this.svc.debug` in `LumenizeDO`, `LumenizeWorker`, and `LumenizeClient`. No additional imports needed.
:::

## Features

- **Namespace filtering**: Use dot-notation scopes (e.g., `lmz.utils.routeDORequest`) with wildcard patterns
- **Level support**: `debug`, `info`, `warn`, and `error` levels
- **JSON output**: Structured logs integrate seamlessly with Cloudflare's observability dashboard
- **Zero-cost when disabled**: Early exit via `enabled` flag - no string interpolation or object creation
- **NADIS integration**: Automatically available via `this.svc.debug` in all mesh node types
- **⚠️ Error level never filtered**: `log.error()` always outputs regardless of filter settings

## Installation

```bash @skip-check
npm install @lumenize/mesh
```

## Quick Start

### In LumenizeDO

```typescript @check-example('packages/core/debug/test/for-docs/quick-start-lumenize-base.test.ts')
import { LumenizeDO } from '@lumenize/mesh';

class ChatRoom extends LumenizeDO<Env> {
  // ...
  onRequest(request: Request) {
    const log = this.svc.debug('ChatRoom.onRequest');
    
    log.debug('Processing request', { 
      method: request.method,
      url: request.url,
    });
    
    // Handle the request
    const messages = this.ctx.storage.kv.get('messages') || [];
    const response = new Response(JSON.stringify(messages));
    
    log.info('Request completed', { 
      messageCount: messages.length
    });
    
    return response;
  }
  // ...
}
```

### In LumenizeWorker

```typescript @skip-check
import { LumenizeWorker } from '@lumenize/mesh';

class SpellCheckWorker extends LumenizeWorker<Env> {
  @mesh
  check(text: string) {
    const log = this.svc.debug('SpellCheckWorker.check');
    log.debug('Checking text', { length: text.length });
    // ...
  }
}
```

### In LumenizeClient

```typescript @skip-check
import { LumenizeClient } from '@lumenize/mesh';

class EditorClient extends LumenizeClient<Env> {
  onDocumentUpdate(changes: Change[]) {
    const log = this.svc.debug('EditorClient.onDocumentUpdate');
    log.debug('Received changes', { count: changes.length });
    // ...
  }
}
```

### Standalone Usage (Without Lumenize Mesh)

For vanilla Durable Objects or Workers, import `debug` directly:

```typescript @check-example('packages/core/debug/test/for-docs/quick-start-vanilla-do.test.ts')
import { debug } from '@lumenize/mesh';
import { DurableObject } from 'cloudflare:workers';

class MyDO extends DurableObject {
  #log = debug(this)('MyDO');
  
  async fetch(request: Request) {
    this.#log.debug('Processing request', { url: request.url });
    return new Response('OK');
  }
}
```

### In Vanilla Workers (Without LumenizeWorker)

```typescript @check-example('packages/core/debug/test/for-docs/quick-start-worker.test.ts')
import { debug } from '@lumenize/mesh';

export default {
  async fetch(request: Request, env: Env) {
    const log = debug({ env })('Worker.router');
    
    log.debug('Routing request', { 
      pathname: new URL(request.url).pathname 
    });
    
    // Route to DO...
    return new Response('Routed successfully');
  }
}
```

## Configuration

### `DEBUG` Environment Variable

Control logging via the `DEBUG` environment variable.

Set the environment variable any one of the many ways you would any other environment variable for that environment (dashboard, command line, wrangler.jsonc, .dev.vars, etc.)

**Important**: Environment variable changes don't take effect in Cloudflare production until redeployment.

**Off by default**: All filterable logs (not .error) are off by default when `DEBUG` is not set.

### Pattern Examples

```bash @skip-check
# Development - see everything
DEBUG=*

# Single namespace, all levels
DEBUG=ChatRoom.handleMessage

# Wildcards
DEBUG=ChatRoom.*

# Combined: wildcards + levels + multiple patterns
DEBUG=ChatRoom.*:info,lmz.rpc.RpcClient:warn

# Exclusions (enable all except one verbose subsystem)
DEBUG=ChatRoom.*,-ChatRoom.verboseDebug
```

## Log Output Format

All logs output as pretty-printed JSON objects to `console.debug`:

```json @skip-check
{
  "type": "debug",  // Says "this is from Lumenize debug"
  "level": "info",
  "namespace": "lmz.fetch.proxyFetchQueueConsumer",
  "message": "Processing request",
  "url": "https://api.example.com/data",
  "method": "POST",
  "timestamp": "2025-11-09T12:34:56.789Z"
}
```

This format integrates with Cloudflare's observability dashboard, allowing you to:
- Query by field (e.g., `namespace:"lmz.fetch.proxyFetchQueueConsumer"`)
- Filter by level
- Search message content
- Analyze structured data

## API

The debug system provides a simple, type-safe logging interface:

```typescript @skip-check
// Create logger
const log = this.svc.debug('MyDO.myMethod');  // LumenizeDO, LumenizeWorker, LumenizeClient
const log = debug(this)('MyDO.myMethod');     // Vanilla DO
const log = debug({ env })('Worker.router');  // Vanilla Worker

// Log at different levels
log.debug(message: string, data?: any);  // Most verbose
log.info(message: string, data?: any);   // Milestones, events
log.warn(message: string, data?: any);   // Expected operational issues
log.error(message: string, data?: any);  // ⚠️ ALWAYS outputs - never filtered
```

### `enabled` Flag as Performance Guard

Check `enabled` flag before outputing expensive operations. `enabled` is computed based upon current `DEBUG` filter and the namespace for logger. So if `DEBUG=Chat.*` and you have this code:

```typescript @skip-check
const log = this.svc.debug('NotChat');
if (log.enabled) {
  const expensiveData = computeExpensiveDetails();
  log.debug('Details', expensiveData);
}
```
`computeExpensiveDetails()` is skipped.

## Lumenize Internals

`lmz.{package-name}.{ActualIdentifier}` convention:
- Package names: kebab-case (npm convention) - `rpc`, `fetch`, `utils`
- Identifiers: actual case from code - `RpcClient`, `routeDORequest`, `ProxyFetchDO`

Examples:
- `lmz.rpc.RpcClient`, `lmz.rpc.WebSocketRpcTransport`
- `lmz.fetch.ProxyFetchDO`, `lmz.fetch.proxyFetchQueueConsumer`
- `lmz.utils.routeDORequest`
- `lmz.alarms.Alarms`

## Comparison with npm's `debug`

Similarities:
- Namespace filtering with wildcards
- Environment variable configuration
- Zero-cost when disabled

Differences:
- **Level support**: debug, info, warn, error (vs. single level)
- **Casing**: Use actual package, class, method case (vs. all lower-kabob-case)
- **Error level**: Never filtered - always outputs
- **JSON output**: Structured objects (vs. plain text)
- **Cloudflare-optimized**: No colors, no TTY detection
- **NADIS integration**: Auto-injection in all mesh node types (LumenizeDO, LumenizeWorker, LumenizeClient)








