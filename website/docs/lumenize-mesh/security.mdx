---
title: Authentication & Access Control
description: JWT authentication, access control, and callContext propagation in the mesh
---

# Authentication & Access Control

Lumenize Mesh includes built-in support for secure, passwordless authentication via magic links and JWT tokens. It also provides facilities for access control.

## Overview

| Feature | Description |
|---------|-------------|
| **Passwordless** | Magic link email login (no passwords to manage) |
| **Secure JWTs** | Ed25519 signed tokens with key rotation support |
| **Refresh rotation** | Automatic token refresh with revocation |
| **WebSocket support** | Token dance designed to work with connection/message flows |

:::info Using a different auth provider?
The mesh reads identity from HTTP headers set by auth middleware — it doesn't care *how* you authenticate. If you prefer Auth0, Clerk, or a custom solution, see [Integrating Alternative Auth](#integrating-alternative-auth) for the header spec.
:::

:::note Access Token vs Refresh Token
**Access tokens** are short-lived (15 min) and kept in memory — if stolen, damage is time-limited. **Refresh tokens** are long-lived (30 days) and stored in HTTP-only cookies — JavaScript can't access them, protecting against XSS. This is the standard [OAuth 2.0 refresh token pattern](https://oauth.net/2/refresh-tokens/).
:::

## WebSocket Authentication

Unlike HTTP where each request carries its own token, WebSocket connections are long-lived. Here's how Lumenize handles it:

1. **Connect**: Access token sent once during upgrade (via subprotocol header)
2. **Store**: Gateway saves token in connection attachment — not sent with each message
3. **Check expiry**: Gateway verifies stored token hasn't expired on each call
4. **Proactive refresh**: ~30s before expiration, client refreshes via HTTP and sends new token via [`token-update`](./gateway#message-types) message — Gateway validates and updates attachment in place (no reconnect)
5. **Fallback**: If token expires anyway, Gateway closes with `4401` — client refreshes and reconnects automatically

This keeps the token off the wire except during initial connection and refresh, while providing truly seamless rotation.

### Token Delivery via Subprotocol

Browsers don't allow custom headers on WebSocket connections, which is where the access token is usually provided. `LumenizeClient` smuggles it in as part of an alternative in the WebSocket subprotocol list during connection/reconnection:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

The server:
1. Extracts the token from `lmz.access-token.{jwt}`
2. Verifies JWT signature and expiration
3. Stores verified claims in the WebSocket attachment (for later expiry checks)
4. Responds with `Sec-WebSocket-Protocol: lmz` — browsers require the server to accept at least one requested subprotocol, so `lmz` is the "real" one while `lmz.access-token.*` is the smuggled payload

### Client Configuration

See [LumenizeClient: Authentication](./lumenize-client#authentication) for configuration options including `accessToken` and `refreshEndpoint`.

### Handling Authentication Errors

If authentication fails (token refresh failed, connection rejected, or session expired), `onAuthenticationError` fires:

```typescript @skip-check
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  onAuthenticationError: (error) => {
    console.log('Auth failed:', error.code, error.reason);
    window.location.href = '/login';  // redirect
  }
});
```

:::note Separate from Connection Errors
`onAuthenticationError` is distinct from `onConnectionError`. Authentication errors include token refresh failures (HTTP), initial connection rejection (401/403), and mid-session token expiration (4401 close code). Network-level WebSocket errors go to `onConnectionError`.
:::

## Magic Link Login Flow

Magic link authentication works as follows:

```mermaid
sequenceDiagram
    participant User
    participant Worker
    participant AuthDO
    participant Email

    User->>Worker: POST /auth/email-magic-link {email}
    Worker->>AuthDO: Forward request
    AuthDO->>Email: Send magic link
    AuthDO->>Worker: {message: "Check email"}
    Worker->>User: Response

    Note over User: User clicks email link

    User->>Worker: GET /auth/magic-link?token=...&state=...
    Worker->>AuthDO: Validate token
    AuthDO->>Worker: {access_token, Set-Cookie: refresh-token}
    Worker->>User: JWT + refresh cookie
```

### Request Magic Link

```typescript @skip-check
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: 'user@example.com' })
});
// Returns: { message: "Check your email for the magic link", expires_in: 1800 }
```

### Validate Magic Link & Get Tokens

When the user clicks the link in their email:

```json @skip-check
{
  "access_token": "eyJhbGciOiJFZERTQSIs...",
  "token_type": "Bearer",
  "expires_in": 900  // 15 minutes
}
```

Plus a `Set-Cookie` header with the refresh token (HttpOnly, Secure, SameSite=Strict).

## Access Control

### Three-Layer Security Model

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **Class-wide** | `onBeforeCall()` hook | WHO can call (authentication) |
| **Entry Point** | `@mesh` decorator | WHAT is exposed (method allowlist) |
| **Capability Trust** | Automatic | Returned objects trusted for that chain |

Methods without the `@mesh` decorator behave as if they don't exist — callers receive a generic error. Errors thrown by guards or `onBeforeCall` pass through unchanged, preserving your domain-specific error types. See [Making Calls: Error Handling](./calls#error-handling) for details.

### Class-Level: `onBeforeCall()`

Override to enforce class-wide policies:

```typescript @skip-check
class ProtectedDO extends LumenizeDO<Env> {
  onBeforeCall() {
    super.onBeforeCall();

    // Require authentication
    if (!this.lmz.callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }
}
```

### Method-Level: `@mesh` Guard

Guards receive the instance, providing access to both call context and instance state. This works for all node types (`LumenizeDO`, `LumenizeWorker`, `LumenizeClient`):

```typescript @skip-check
// Check call context (e.g., claims)
@mesh((instance: MyDO) => {
  if (!instance.lmz.callContext.originAuth?.claims?.isAdmin) {
    throw new Error('Admin only');
  }
})
adminMethod() {
  // Only admins reach here
}

// Check instance state
@mesh((instance: DocumentDO) => {
  const userId = instance.lmz.callContext.originAuth?.userId;
  if (!instance.allowedEditors.has(userId)) {
    throw new Error('Not an allowed editor');
  }
})
updateDocument(changes: DocumentChange) {
  // Only allowed editors reach here
}
```

### Reusable Guards

```typescript @skip-check
function requireRole(role: string) {
  return (instance: { lmz: LmzApi }) => {
    const roles = instance.lmz.callContext.originAuth?.claims?.roles ?? [];
    if (!roles.includes(role)) {
      throw new Error(`Role ${role} required`);
    }
  };
}

@mesh(requireRole('editor'))
editDocument(changes: DocumentChange) { /* ... */ }

@mesh(requireRole('admin'))
deleteDocument() { /* ... */ }
```

### State-Based Access

The `callContext.state` object is a mutable `Record<string, any>` that:
- Starts **empty** (`{}`) for each incoming mesh call
- **Persists through the call chain** — method guards and handlers see the same state even when the call chain hops from mesh node to mesh node
- Is often **populated in `onBeforeCall()`** after verifying authentication, but can be added to by any call in the call chain
- Is **isolated per-request** via AsyncLocalStorage (concurrent calls don't interfere)

Use it to attach computed data (like user records or permissions) so method guards don't need to re-fetch:

```typescript @skip-check
// In onBeforeCall — runs once per incoming call
onBeforeCall() {
  super.onBeforeCall();
  const callContext = this.lmz.callContext;
  if (!callContext.originAuth?.userId) throw new Error('Auth required');

  // Populate state for use by method guards
  const user = this.loadUser(callContext.originAuth.userId);
  callContext.state.user = user;
  callContext.state.permissions = this.computePermissions(user);
}

// In method guard
@mesh((instance: MyDO) => {
  if (!instance.lmz.callContext.state.permissions.canEdit) {
    throw new Error('Edit permission required');
  }
})
editDocument(changes: DocumentChange) { /* ... */ }
```

:::note Per-Request Isolation
Each request gets its own `callContext` instance with its own `state` object, even when multiple requests hit the same DO concurrently. This isolation is provided by AsyncLocalStorage under the hood — you don't need to worry about concurrent requests overwriting each other's state.
:::

## Error Handling

### Auth Close Codes

The Gateway uses standard WebSocket close codes for auth issues:

| Code | Meaning | Action |
|------|---------|--------|
| `4400` | No token provided | Redirect to login |
| `4401` | Token expired | Refresh and reconnect (automatic) |
| `4403` | Invalid token/signature | Redirect to login |

## Installation & Setup

### 1. Install

```bash @skip-check
npm install @lumenize/mesh @lumenize/utils
```

### 2. Generate Ed25519 Key Pair

```bash @skip-check
# Generate and display private key (copy for next step)
openssl genpkey -algorithm ed25519 | tee /dev/stderr | openssl pkey -pubout
```

This outputs both keys to the console. Copy each (including the `-----BEGIN/END-----` lines) for the next step.

### 3. Configure Environment Variables

Generate two key pairs (BLUE and GREEN) for zero-downtime key rotation. Run the command from step 2 twice.

**Local development** (`.dev.vars`):
```bash @skip-check
JWT_PRIVATE_KEY_BLUE="-----BEGIN PRIVATE KEY-----\nMC4CAQAw..."
JWT_PUBLIC_KEY_BLUE="-----BEGIN PUBLIC KEY-----\nMCowBQYD..."
JWT_PRIVATE_KEY_GREEN="-----BEGIN PRIVATE KEY-----\nMC4CAQAw..."
JWT_PUBLIC_KEY_GREEN="-----BEGIN PUBLIC KEY-----\nMCowBQYD..."
PRIMARY_JWT_KEY="BLUE"
```

**Production** (changes take effect on next deploy):
```bash @skip-check
# Secrets (never visible in dashboard, can only be replaced)
wrangler secret put JWT_PRIVATE_KEY_BLUE
wrangler secret put JWT_PUBLIC_KEY_BLUE
wrangler secret put JWT_PRIVATE_KEY_GREEN
wrangler secret put JWT_PUBLIC_KEY_GREEN

# Variables (visible and editable in dashboard)
wrangler vars put PRIMARY_JWT_KEY
```

See [Key Rotation](#key-rotation) for how to rotate keys without downtime.

### 4. Configure `wrangler.jsonc`

```jsonc @skip-check
{
  "name": "my-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "compatibility_flags": ["nodejs_compat"],  // Required for AsyncLocalStorage
  "durable_objects": {
    "bindings": [
      // Lumenize infrastructure (use as-is)
      { "name": "LUMENIZE_AUTH", "class_name": "LumenizeAuth" },
      { "name": "LUMENIZE_CLIENT_GATEWAY", "class_name": "LumenizeClientGateway" },
      // Your DOs (extend LumenizeDO)
      { "name": "DOCUMENT_DO", "class_name": "DocumentDO" },
      // ...
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["LumenizeAuth", "LumenizeClientGateway", "DocumentDO", /* ... */ ] }
  ]
}
```

### 5. Set Up Worker with Auth Middleware

```typescript @skip-check
import { LumenizeAuth, createAuthMiddleware, createWebSocketAuthMiddleware } from '@lumenize/mesh';
import { routeDORequest } from '@lumenize/utils';

export { LumenizeAuth };

// Allowlist your app's origins (server-side rejection for disallowed origins)
const cors = { origin: ['https://app.example.com', 'https://admin.example.com'] };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - public (no middleware)
    const authResponse = await routeDORequest(request, env, {
      prefix: 'auth',
      cors
    });
    if (authResponse) return authResponse;

    // Create auth middleware (accepts tokens signed with either key)
    const httpAuth = await createAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN]
    });
    const wsAuth = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN]
    });

    // Protected routes - with auth middleware
    return routeDORequest(request, env, {
      onBeforeRequest: httpAuth,
      onBeforeConnect: wsAuth,
      cors
    }) ?? new Response('Not Found', { status: 404 });
  }
};
```

The middleware:
1. Extracts Bearer token from `Authorization` header (HTTP) or subprotocol (WebSocket)
2. Verifies JWT signature (tries primary key first, then secondary for rotation)
3. Validates expiration
4. On success: Enhances request with `X-Auth-User-Id` and `X-Auth-Claims` headers
5. On failure: Returns 401 (HTTP) or closes with 4401/4403 (WebSocket)

See [`routeDORequest`](/docs/utils/route-do-request) or [CORS Support](/docs/utils/cors-support) for advanced options.

## Key Rotation

Zero-downtime key rotation using interleaved BLUE/GREEN keys. Both keys always exist; `PRIMARY_JWT_KEY` controls which one signs new tokens. Verification tries primary first, then secondary.

**Every 90 days:**

1. Generate a new key pair (see [step 2 in Installation](#2-generate-ed25519-key-pair))
2. Replace the **secondary** key's secrets
3. Switch `PRIMARY_JWT_KEY` to the newly replaced key (making it primary)

```bash @skip-check
# Example: BLUE is primary, GREEN is secondary — replacing GREEN
wrangler secret put JWT_PRIVATE_KEY_GREEN   # Paste new private key
wrangler secret put JWT_PUBLIC_KEY_GREEN    # Paste new public key
# Deploy happens automatically or via wrangler deploy

wrangler vars put PRIMARY_JWT_KEY           # Enter: GREEN (now primary)
```

Note secret and vars changes do not take effect until your next deploy.

**Timeline example** (6-month max key age):

| Day | Action | Set PRIMARY_JWT_KEY to |
|-----|--------|------------------------|
| 0 | Initial setup | BLUE |
| 90 | Replace GREEN | GREEN |
| 180 | Replace BLUE | BLUE |
| 270 | Replace GREEN | GREEN |

**Why this works**: By the time you replace a key, it's been secondary for 90 days. Since refresh tokens live only 30 days, all tokens signed with that key expired 60+ days ago.

## Integrating Alternative Auth

The mesh reads identity from HTTP headers — it doesn't care how authentication happens. If you're using Auth0, Clerk, Supabase Auth, or a custom solution, your middleware just needs to set the right headers.

### Header Contract

| Header | Required | Description |
|--------|----------|-------------|
| `X-Auth-User-Id` | Yes | Verified user ID (typically from JWT `sub` claim) |
| `X-Auth-Claims` | No | JSON-encoded object with additional claims |

The presence of `X-Auth-User-Id` indicates successful authentication. If missing, the request is treated as unauthenticated.

### How Headers Map to callContext

```typescript @skip-check
// Your middleware sets headers
request.headers.set('X-Auth-User-Id', 'user-123');
request.headers.set('X-Auth-Claims', JSON.stringify({
  roles: ['editor'],
  orgId: 'org-456'
}));

// In your mesh handlers, access via callContext
@mesh
someMethod() {
  const { originAuth } = this.lmz.callContext;
  console.log(originAuth.userId);        // 'user-123'
  console.log(originAuth.claims.roles);  // ['editor']
  console.log(originAuth.claims.orgId);  // 'org-456'
}
```

### Example: Auth0 Integration

```typescript @skip-check
import { jwtVerify } from 'jose';

async function auth0Middleware(request: Request, env: Env): Promise<Request | Response> {
  const token = request.headers.get('Authorization')?.replace('Bearer ', '');
  if (!token) return new Response('Unauthorized', { status: 401 });

  try {
    const { payload } = await jwtVerify(token, env.AUTH0_PUBLIC_KEY, {
      issuer: `https://${env.AUTH0_DOMAIN}/`,
      audience: env.AUTH0_AUDIENCE
    });

    const enhanced = new Request(request);
    enhanced.headers.set('X-Auth-User-Id', payload.sub);
    enhanced.headers.set('X-Auth-Claims', JSON.stringify({
      roles: payload['https://myapp.com/roles'] ?? [],
      email: payload.email
    }));
    return enhanced;
  } catch {
    return new Response('Invalid token', { status: 401 });
  }
}
```

### WebSocket Considerations

For WebSocket connections, you have two options:

1. **Use subprotocol token delivery** — Your auth middleware extracts the token from `lmz.access-token.{jwt}` in the `Sec-WebSocket-Protocol` header (same pattern as `@lumenize/auth`)

2. **Query parameter fallback** — Pass the token as `?token={jwt}` during the WebSocket upgrade (less secure, but simpler)

Either way, your middleware must verify the token and store the user identity in the WebSocket attachment for the Gateway to access on subsequent messages.

## API Reference

### Auth Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/auth/enter` | GET | Login instructions |
| `/auth/email-magic-link` | POST | Request magic link (body: `{email}`) |
| `/auth/magic-link` | GET | Validate magic link and login |
| `/auth/refresh-token` | POST | Refresh access token (uses cookie) |
| `/auth/logout` | POST | Revoke refresh token |

### Middleware Functions

```typescript @skip-check
// HTTP auth
const httpAuth = await createAuthMiddleware({
  publicKeysPem: string[],
  audience?: string,
  issuer?: string
});

// WebSocket auth
const wsAuth = await createWebSocketAuthMiddleware({
  publicKeysPem: string[]
});
```

### JWT Utilities

```typescript @skip-check
import {
  signJwt,
  verifyJwt,
  verifyJwtWithRotation,
  importPrivateKey,
  importPublicKey,
  parseJwtUnsafe
} from '@lumenize/mesh';
```

### WebSocket Utilities

```typescript @skip-check
import {
  extractWebSocketToken,
  verifyWebSocketToken,
  getTokenTtl,
  WS_CLOSE_CODES
} from '@lumenize/mesh';
```

## Test Mode

For development, add `?_test=true` to get the magic link directly:

```typescript @skip-check
const response = await fetch('/auth/email-magic-link?_test=true', {
  method: 'POST',
  body: JSON.stringify({ email: 'test@example.com' })
});
// Returns: { message: "Magic link generated (test mode)", magic_link: "..." }
```

Requires `AUTH_TEST_MODE="true"` in environment.
