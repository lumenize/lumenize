---
title: Authentication & Access Control
description: JWT authentication, access control, and callContext propagation in the mesh
---

# Authentication & Access Control

The Lumenize Mesh integrates with `@lumenize/auth` for secure, passwordless authentication via magic links and JWT tokens.

## Overview

| Feature | Description |
|---------|-------------|
| **Passwordless** | Magic link email login (no passwords to manage) |
| **Secure JWTs** | Ed25519 signed tokens with key rotation support |
| **Refresh rotation** | Automatic token refresh with revocation |
| **Rate limiting** | Built-in protection against abuse |
| **WebSocket auth** | Token passing via subprotocol headers |
| **Middleware** | Drop-in hooks for HTTP and WebSocket routes |

## Installation & Setup

### 1. Install

```bash @skip-check
npm install @lumenize/auth @lumenize/mesh @lumenize/utils
```

### 2. Generate Ed25519 Key Pair

```bash @skip-check
# Generate private key
openssl genpkey -algorithm ed25519 -out private.pem

# Extract public key
openssl pkey -in private.pem -pubout -out public.pem

# View keys (copy to .dev.vars)
cat private.pem | tr '\n' '\\n' && echo
cat public.pem | tr '\n' '\\n' && echo
```

### 3. Configure `.dev.vars`

```bash @skip-check
JWT_PRIVATE_KEY_BLUE="-----BEGIN PRIVATE KEY-----\nMC4CAQAw..."
JWT_PUBLIC_KEY_BLUE="-----BEGIN PUBLIC KEY-----\nMCowBQYD..."
ACTIVE_JWT_KEY="BLUE"
```

### 4. Configure `wrangler.jsonc`

```jsonc @skip-check
{
  "name": "my-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      { "name": "LUMENIZE_AUTH", "class_name": "LumenizeAuth" },
      { "name": "LUMENIZE_CLIENT_GATEWAY", "class_name": "LumenizeClientGateway" },
      { "name": "DOCUMENT_DO", "class_name": "DocumentDO" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["LumenizeAuth", "DocumentDO"] }
  ]
}
```

### 5. Set Up Worker with Auth Middleware

```typescript @skip-check
import { LumenizeAuth, createAuthMiddleware, createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

export { LumenizeAuth };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - public (no middleware)
    const authResponse = await routeDORequest(request, env, {
      prefix: 'auth',
      cors: true
    });
    if (authResponse) return authResponse;

    // Create auth middleware
    const httpAuth = await createAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });
    const wsAuth = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });

    // Protected routes - with auth middleware
    return routeDORequest(request, env, {
      onBeforeRequest: httpAuth,
      onBeforeConnect: wsAuth,
      cors: true
    }) ?? new Response('Not Found', { status: 404 });
  }
};
```

## Login Flow

Magic link authentication works as follows:

```mermaid
sequenceDiagram
    participant User
    participant Worker
    participant AuthDO
    participant Email
    
    User->>Worker: POST /auth/email-magic-link {email}
    Worker->>AuthDO: Forward request
    AuthDO->>Email: Send magic link
    AuthDO->>Worker: {message: "Check email"}
    Worker->>User: Response
    
    Note over User: User clicks email link
    
    User->>Worker: GET /auth/magic-link?token=...&state=...
    Worker->>AuthDO: Validate token
    AuthDO->>Worker: {access_token, Set-Cookie: refresh-token}
    Worker->>User: JWT + refresh cookie
```

### Request Magic Link

```typescript @skip-check
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: 'user@example.com' })
});
// Returns: { message: "Check your email for the magic link", expires_in: 1800 }
```

### Validate Magic Link

When the user clicks the link in their email:

```json @skip-check
{
  "access_token": "eyJhbGciOiJFZERTQSIs...",
  "token_type": "Bearer",
  "expires_in": 900
}
```

Plus a `Set-Cookie` header with the refresh token (HttpOnly, Secure, SameSite=Strict).

## WebSocket Authentication

### Token Delivery via Subprotocol

Browsers don't allow custom headers on WebSocket connections. `LumenizeClient` uses the subprotocol mechanism:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

The server:
1. Extracts the token from `lmz.access-token.{jwt}`
2. Verifies JWT signature and expiration
3. Accepts with `Sec-WebSocket-Protocol: lmz`

### Client Configuration

```typescript @skip-check
// Fresh login — pass the token you just received
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: accessToken
});

// Page refresh — let client fetch token via refresh endpoint
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`
  // accessToken omitted — fetched automatically via refreshEndpoint
});
```

### Token Acquisition & Refresh

`LumenizeClient` handles tokens automatically:

**Initial connection:**
- If `accessToken` provided → use it for WebSocket connection
- If `accessToken` omitted → POST to `refreshEndpoint` first to get token (uses refresh cookie)

**Ongoing refresh:**
1. **Monitor**: Parses JWT to determine expiration
2. **Timer**: Sets timer for ~30 seconds before expiry
3. **Refresh**: POSTs to `refreshEndpoint` with `credentials: 'include'`
4. **Update**: Updates internal token for future reconnections

### Handling Authentication Errors

If authentication fails (token refresh failed, connection rejected, or session expired), `onAuthenticationError` fires:

```typescript @skip-check
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  onAuthenticationError: (error) => {
    console.log('Auth failed:', error.code, error.reason);
    window.location.href = '/login';
  }
});
```

:::note Separate from Connection Errors
`onAuthenticationError` is distinct from `onConnectionError`. Authentication errors include token refresh failures (HTTP), initial connection rejection (401/403), and mid-session token expiration (4401 close code). Network-level WebSocket errors go to `onConnectionError`.
:::

## Identity in the Mesh

### `callContext.originAuth`

Once authenticated, your identity propagates through the entire call chain:

```typescript @skip-check
// In any mesh node
@mesh
updateDocument(changes: DocumentChange) {
  const userId = this.lmz.callContext.originAuth?.userId;
  const claims = this.lmz.callContext.originAuth?.claims;
  
  // Identity is the ORIGINAL caller's, even through multiple hops
}
```

**Call chain example:**
```
Client (alice) → DocumentDO → ValidationWorker → NotificationDO
                    ↓              ↓                  ↓
            originAuth has   originAuth has    originAuth has
            alice's auth     alice's auth      alice's auth (propagated!)
```

### Context Preservation

`callContext` (including `originAuth`) is automatically captured in continuations. Even if a DO hibernates during a long-running operation, your handler receives the correct context.

See [Managing Context](./managing-context) for the full guide.

## Access Control

### Three-Layer Security Model

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **Class-wide** | `onBeforeCall()` hook | WHO can call (auth, rate limiting) |
| **Entry Point** | `@mesh` decorator | WHAT is exposed (method allowlist) |
| **Capability Trust** | Automatic | Returned objects trusted for that chain |

When a method lacks the `@mesh` decorator, callers receive a `MeshAccessError`. Errors thrown by guards or `onBeforeCall` pass through unchanged, preserving your domain-specific error types. See [Making Calls: Error Types](./calls#error-types) for details.

### Class-Level: `onBeforeCall()`

Override to enforce class-wide policies:

```typescript @skip-check
class ProtectedDO extends LumenizeDO<Env> {
  onBeforeCall() {
    super.onBeforeCall();

    // Require authentication
    if (!this.lmz.callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }
}
```

### Method-Level: `@mesh` Guard

```typescript @skip-check
@mesh((instance: MyDO) => {
  if (!instance.lmz.callContext.originAuth?.claims?.isAdmin) {
    throw new Error('Admin only');
  }
})
adminMethod() {
  // Only admins reach here
}
```

### Guards with Instance Access

Guards receive the instance, providing access to both instance state and call context. This works for all node types (`LumenizeDO`, `LumenizeWorker`, `LumenizeClient`):

```typescript @skip-check
@mesh((instance: DocumentDO) => {
  const userId = instance.lmz.callContext.originAuth?.userId;
  if (!instance.allowedEditors.has(userId)) {
    throw new Error('Not an allowed editor');
  }
})
updateDocument(changes: DocumentChange) {
  // Only allowed editors reach here
}
```

### Reusable Guards

```typescript @skip-check
function requireRole(role: string) {
  return (instance: { lmz: LmzApi }) => {
    const roles = instance.lmz.callContext.originAuth?.claims?.roles ?? [];
    if (!roles.includes(role)) {
      throw new Error(`Role ${role} required`);
    }
  };
}

@mesh(requireRole('editor'))
editDocument(changes: DocumentChange) { /* ... */ }

@mesh(requireRole('admin'))
deleteDocument() { /* ... */ }
```

### State-Based Access

The `callContext.state` object is a mutable `Record<string, any>` that:
- Starts **empty** (`{}`) for each incoming mesh call
- Is typically **populated in `onBeforeCall()`** after verifying authentication
- **Persists through the call chain** — method guards and handlers see the same state
- Is **isolated per-request** via AsyncLocalStorage (concurrent calls don't interfere)

Use it to attach computed data (like user records or permissions) so method guards don't need to re-fetch:

```typescript @skip-check
// In onBeforeCall — runs once per incoming call
onBeforeCall() {
  super.onBeforeCall();
  const callContext = this.lmz.callContext;
  if (!callContext.originAuth?.userId) throw new Error('Auth required');

  // Populate state for use by method guards
  const user = this.loadUser(callContext.originAuth.userId);
  callContext.state.user = user;
  callContext.state.permissions = this.computePermissions(user);
}

// In method guard
@mesh((instance: MyDO) => {
  if (!instance.lmz.callContext.state.permissions.canEdit) {
    throw new Error('Edit permission required');
  }
})
editDocument(changes: DocumentChange) { /* ... */ }
```

:::note Per-Request Isolation
Each request gets its own `callContext` instance with its own `state` object, even when multiple requests hit the same DO concurrently. This isolation is provided by AsyncLocalStorage under the hood — you don't need to worry about concurrent requests overwriting each other's state.
:::

## HTTP Route Protection

### Creating Middleware

```typescript @skip-check
import { createAuthMiddleware } from '@lumenize/auth';

const httpAuth = await createAuthMiddleware({
  publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN],
  audience: 'https://myapp.com',
  issuer: 'https://myapp.com'
});
```

### Using with routeDORequest

```typescript @skip-check
return routeDORequest(request, env, {
  onBeforeRequest: httpAuth,
  cors: true
});
```

The middleware:
1. Extracts Bearer token from `Authorization` header
2. Verifies JWT signature (tries all provided keys for rotation)
3. Validates expiration, audience, issuer
4. On success: Enhances request with `X-Auth-User-Id` and `X-Auth-Verified` headers
5. On failure: Returns 401 with `WWW-Authenticate` header

## Key Rotation

Zero-downtime key rotation with BLUE/GREEN keys:

1. **Normal operation**: Sign with BLUE, verify with BLUE
2. **Rotate keys**:
   - Generate new GREEN key pair
   - Add `JWT_PRIVATE_KEY_GREEN` and `JWT_PUBLIC_KEY_GREEN` to secrets
   - Add GREEN public key to middleware: `publicKeysPem: [BLUE, GREEN]`
   - Set `ACTIVE_JWT_KEY="GREEN"` to start signing with GREEN
3. **After all BLUE tokens expire**: Remove BLUE keys from middleware

```typescript @skip-check
// During rotation: accept tokens signed with either key
const middleware = await createAuthMiddleware({
  publicKeysPem: [
    env.JWT_PUBLIC_KEY_BLUE,   // Active key
    env.JWT_PUBLIC_KEY_GREEN   // Fallback during rotation
  ]
});
```

## Error Handling

### Auth Close Codes

The Gateway uses standard WebSocket close codes for auth issues:

| Code | Meaning | Action |
|------|---------|--------|
| `4400` | No token provided | Redirect to login |
| `4401` | Token expired | Refresh and reconnect (automatic) |
| `4403` | Invalid token/signature | Redirect to login |

### Client Error Handling

```typescript @skip-check
using client = new EditorClient({
  accessToken,
  onAuthenticationError: (error) => {
    console.log('Auth failed:', error.code, error.reason);
    window.location.href = '/login';
  }
});
```

## Security Best Practices

### 1. Token Storage

- **Access Token**: Keep in memory only. Never store in `localStorage`
- **Refresh Token**: HTTP-only, Secure, SameSite=Strict cookies

### 2. URL Safety

Never pass tokens in WebSocket URLs:
```
❌ wss://app.com?token=...  // Logged by proxies!
✅ Use subprotocol mechanism
```

### 3. Identity Validation

The Gateway validates that the JWT's user ID matches the `instanceName` prefix, preventing impersonation:
- User `alice` can connect to `alice.tab1`
- User `alice` cannot connect to `bob.tab1`

### 4. Short-Lived Tokens

Default token lifetimes:
- **Access token**: 15 minutes (configurable)
- **Refresh token**: 30 days (configurable)

Shorter access tokens = less damage if stolen.

## API Reference

### Auth Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/auth/enter` | GET | Login instructions |
| `/auth/email-magic-link` | POST | Request magic link (body: `{email}`) |
| `/auth/magic-link` | GET | Validate magic link and login |
| `/auth/refresh-token` | POST | Refresh access token (uses cookie) |
| `/auth/logout` | POST | Revoke refresh token |

### Middleware Functions

```typescript @skip-check
// HTTP auth
const httpAuth = await createAuthMiddleware({
  publicKeysPem: string[],
  audience?: string,
  issuer?: string
});

// WebSocket auth
const wsAuth = await createWebSocketAuthMiddleware({
  publicKeysPem: string[]
});
```

### JWT Utilities

```typescript @skip-check
import {
  signJwt,
  verifyJwt,
  verifyJwtWithRotation,
  importPrivateKey,
  importPublicKey,
  parseJwtUnsafe
} from '@lumenize/auth';
```

### WebSocket Utilities

```typescript @skip-check
import {
  extractWebSocketToken,
  verifyWebSocketToken,
  getTokenTtl,
  WS_CLOSE_CODES
} from '@lumenize/auth';
```

## Test Mode

For development, add `?_test=true` to get the magic link directly:

```typescript @skip-check
const response = await fetch('/auth/email-magic-link?_test=true', {
  method: 'POST',
  body: JSON.stringify({ email: 'test@example.com' })
});
// Returns: { message: "Magic link generated (test mode)", magic_link: "..." }
```

Requires `AUTH_TEST_MODE="true"` in environment.

## See Also

- **[Managing Context](./managing-context)** — How callContext propagates
- **[LumenizeClient](./lumenize-client)** — Client-side token handling
- **[Gateway Internals](./gateway)** — Trust boundaries
