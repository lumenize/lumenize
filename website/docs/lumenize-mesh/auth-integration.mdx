---
title: Auth Integration
description: Token handling patterns for LumenizeClient
---

# Auth Integration

LumenizeClient integrates with `@lumenize/auth` for seamless JWT authentication over WebSocket connections.

## How It Works

### Token Delivery via Subprotocol

Browsers don't allow custom headers on WebSocket connections. LumenizeClient uses the WebSocket subprotocol mechanism to pass JWT tokens:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

The server:
1. Extracts the token from the `lmz.access-token.{jwt}` protocol
2. Verifies the JWT signature and expiration
3. Accepts with `Sec-WebSocket-Protocol: lmz` (the primary protocol)
4. Stores token metadata in WebSocket attachment for per-message verification

### Token Lifetime

- **Access tokens**: 15 minutes (short-lived, passed with every connection)
- **Refresh tokens**: 30 days (stored securely, used to get new access tokens)

## Basic Setup

### Client Configuration

Using the document editing example from the overview:

```typescript
import { LumenizeClient } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${getTabId()}`,
  
  // Initial access token
  accessToken: accessToken,
  
  // Token refresh handled automatically!
  // Client parses JWT expiry, refreshes ~30s before expiration
  // using HTTP-only refresh token cookie
  refreshEndpoint: '/auth/refresh-token'  // This is the default
});
```

### Server Configuration

Use `createWebSocketAuthMiddleware` in your Worker:

```typescript
import { createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

export default {
  async fetch(request: Request, env: Env) {
    const wsAuthMiddleware = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN]
    });
    
    return routeDORequest(request, env, {
      // Verify token on WebSocket upgrade
      onBeforeConnect: wsAuthMiddleware
    });
  }
};
```

## Token Refresh Flow

Token refresh is **automatic** — LumenizeClient handles it internally:

```
┌───────────────────────────────────────────────────────────────┐
│                                                               │
│   Client                    Server                            │
│     │                          │                              │
│     │  Connect with token      │                              │
│     ├─────────────────────────→│                              │
│     │                          │ Verify JWT                   │
│     │         Connected        │                              │
│     │←─────────────────────────┤                              │
│     │                          │                              │
│     │     ... 14 minutes ...   │                              │
│     │                          │                              │
│     │ (internal: token expiring soon)                         │
│     │                          │                              │
│     │  POST /auth/refresh-token (with cookie)                 │
│     ├─────────────────────────→│                              │
│     │          new accessToken │                              │
│     │←─────────────────────────┤                              │
│     │                          │                              │
│     │ (internal: update token) │                              │
│     │                          │                              │
│     │     ... continues ...    │                              │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

No callback needed — the client:
1. Parses JWT to determine expiration time
2. Sets internal timer for ~30 seconds before expiry
3. Makes HTTP POST to `refreshEndpoint` with `credentials: 'include'`
4. Updates internal token and continues

## Gateway Token Verification

LumenizeClientGateway verifies tokens in two places:

### 1. On Connection (via Middleware)

```typescript
// Worker routes to Gateway with verified auth context
onBeforeConnect: async (request, context) => {
  const result = await wsAuthMiddleware(request, context);
  // Returns enhanced request with X-Auth-User-Id header
  return result;
}
```

### 2. On Each Message (via Attachment)

```typescript
// In LumenizeClientGateway
async webSocketMessage(ws: WebSocket, message: string) {
  const attachment = ws.deserializeAttachment();
  
  // Check if token has expired
  if (attachment.tokenExp && attachment.tokenExp < Date.now() / 1000) {
    ws.close(4401, 'Token expired');
    return;
  }
  
  // Process message...
}
```

## Token Storage

### Access Token

Stored in memory (private field). Never persisted to localStorage or cookies. Managed automatically by LumenizeClient.

```typescript
// Inside LumenizeClient (internal)
#accessToken: string | null = null;
// Updated automatically during refresh
```

### Refresh Token

Use HTTP-only cookies (recommended):

```typescript
// Login response sets cookie
Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict; Path=/auth

// Client refresh request includes cookie automatically
fetch('/auth/refresh-token', {
  method: 'POST',
  credentials: 'include'
});
```

## Error Handling

### Token Expired During Connection

```typescript
client.onConnectionError = (error) => {
  if (error.message.includes('401')) {
    // Token was invalid/expired at connection time
    redirectToLogin();
  }
};
```

### Token Expires During Session

The Gateway closes the WebSocket with code `4401`:

```typescript
client.onConnectionStateChange = (state) => {
  if (state === 'disconnected') {
    // Check if we were kicked due to auth
    // The close event will have code 4401
  }
};

// Or handle via WebSocket close event
ws.onclose = (event) => {
  if (event.code === 4401) {
    // Token expired - try to refresh and reconnect
    refreshAndReconnect();
  }
};
```

### Refresh Token Expired

When the refresh token expires, the automatic refresh will fail with a 401. Handle this via `onConnectionError`:

```typescript
const client = createLumenizeClient({
  // ...
  onConnectionError: (error) => {
    if (error.message.includes('401') || error.message.includes('Session expired')) {
      // Refresh token expired - must re-authenticate
      redirectToLogin();
    }
  }
});
```

The client will automatically attempt refresh and surface the error if it fails.

## WebSocket Close Codes

LumenizeClientGateway uses custom close codes for auth errors:

| Code | Meaning | Client Action |
|------|---------|---------------|
| `4400` | No token | Redirect to login |
| `4401` | Token expired | Refresh and reconnect |
| `4403` | Invalid token | Redirect to login |

```typescript
import { WS_CLOSE_CODES } from '@lumenize/auth';

// WS_CLOSE_CODES.TOKEN_EXPIRED === 4401
// WS_CLOSE_CODES.UNAUTHORIZED === 4403
// WS_CLOSE_CODES.NO_TOKEN === 4400
```

## Security Considerations

### Token in URL (Avoid)

Never put tokens in WebSocket URLs:

```typescript
// ❌ BAD - Token in URL, logged everywhere
const ws = new WebSocket(`wss://app.com/gateway?token=${jwt}`);

// ✅ GOOD - Token in subprotocol, not logged
const ws = new WebSocket(url, ['lmz', `lmz.access-token.${jwt}`]);
```

### Token Storage (Client-Side)

```typescript
// ❌ BAD - Accessible to XSS
localStorage.setItem('accessToken', jwt);

// ✅ GOOD - Memory only, not accessible to XSS
let accessToken = jwt; // Closure variable
```

### Gateway Identity Validation

The Gateway instance name should include the user ID to prevent impersonation:

```typescript
// Instance name format: userId.tabId
const instanceName = `${userId}.${tabId}`;

// Gateway can verify caller matches instance
async fetch(request: Request) {
  const authUserId = request.headers.get('X-Auth-User-Id');
  const instanceUserId = this.lmz.instanceName?.split('.')[0];
  
  if (authUserId !== instanceUserId) {
    return new Response('Unauthorized', { status: 403 });
  }
  // ...
}
```

## Complete Example

Using the document editing example:

```typescript
// editor-auth.ts
import { LumenizeClient } from '@lumenize/mesh';

// Define the editor client with handlers
class EditorClient extends LumenizeClient {
  editor: EditorInstance;
  documentId: string;
  
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
  
  // Re-subscribe after grace period expires
  onSubscriptionsLost = () => {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}

// App state
let client: EditorClient | null = null;
let userId = '';

export async function login(email: string): Promise<void> {
  // Request magic link
  await fetch('/auth/email-magic-link', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email })
  });
}

export async function handleMagicLinkCallback(token: string): Promise<void> {
  // Exchange magic link for tokens
  const response = await fetch(`/auth/magic-link?token=${token}`);
  const { accessToken, user } = await response.json();
  
  userId = user.id;
  
  // Create authenticated editor client
  // Token refresh is automatic via HTTP-only cookie!
  client = new EditorClient({
    baseUrl: 'wss://app.example.com',
    instanceName: `${userId}.${getTabId()}`,
    accessToken,
    // refreshEndpoint: '/auth/refresh-token'  // default
    
    onConnectionError: (error) => {
      if (error.message.includes('401') || error.message.includes('Session expired')) {
        logout();
      }
    }
  });
}

export async function openDocument(documentId: string): Promise<void> {
  if (!client) throw new Error('Not authenticated');
  
  client.documentId = documentId;
  
  // Subscribe to document updates
  client.lmz.call('DOCUMENT_DO', documentId, client.ctn<DocumentDO>().subscribe());
}

export async function logout(): Promise<void> {
  // Disconnect client
  client?.disconnect();
  client = null;
  
  // Clear server session
  await fetch('/auth/logout', {
    method: 'POST',
    credentials: 'include'
  });
  
  userId = '';
  window.location.href = '/login';
}

function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}
```

## Call Context Propagation {#call-context}

In a zero-trust mesh, every node must be able to verify who originated a request — not just who made the immediate call. Lumenize propagates authentication context through the entire call chain.

### The Problem

When DocumentDO calls SpellCheckWorker, SpellCheckWorker needs to know:
- **Immediate caller**: DocumentDO (for routing responses)
- **Original auth**: Alice's credentials (for access control)

Without propagation, SpellCheckWorker would only see DocumentDO as the caller and couldn't verify Alice's permissions.

### The Solution: `this.lmz.callContext`

Every mesh node can access `this.lmz.callContext` during method execution:

```typescript
type CallChainNode = {
  type: 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient';
  bindingName?: string;
  instanceNameOrId?: string;
};

interface CallContext {
  // Full call chain: [origin, ..., priorCaller, caller]
  // Each hop appends itself to the chain
  callChain: CallChainNode[];
  
  // This node (receiving the call)
  callee: CallChainNode;
  
  // Propagated from origin (preserved through entire chain)
  originAuth?: {
    userId?: string;
    sessionId?: string;
    claims?: Record<string, any>;
  };
  
  // Convenience getters (computed from callChain)
  get origin(): CallChainNode;      // callChain[0] - who started this
  get caller(): CallChainNode;      // callChain.at(-1) - immediate caller
  get priorCaller(): CallChainNode | undefined;  // callChain.at(-2)
}
```

**Common access patterns:**
```typescript
const ctx = this.lmz.callContext;

ctx.origin          // Who started this call chain?
ctx.caller          // Who just called me?
ctx.originAuth      // What are the original user's credentials?

// Advanced: full chain for debugging/auditing
ctx.callChain       // [Gateway, DocumentDO, SpellCheckWorker]

// Circuit detection (prevent infinite loops)
ctx.callChain.some(n => n.instanceNameOrId === this.lmz.instanceNameOrId)
```

### How It Works

```
┌──────────────────────────────────────────────────────────────────────┐
│ 1. Client calls DocumentDO via Gateway                               │
│    Envelope: { callChain: [Gateway], callee: DocumentDO, originAuth }│
└──────────────────────────────────────────────────────────────────────┘
                                   ↓
┌──────────────────────────────────────────────────────────────────────┐
│ 2. DocumentDO.update() executes                                      │
│    ctx.origin === Gateway ✓                                          │
│    ctx.caller === Gateway ✓ (same as origin on first hop)            │
│    ctx.originAuth.userId === 'alice' ✓                               │
│    Makes sub-call to SpellCheckWorker...                             │
└──────────────────────────────────────────────────────────────────────┘
                                   ↓
┌──────────────────────────────────────────────────────────────────────┐
│ 3. this.lmz.callRaw() appends self to callChain                      │
│    Envelope: { callChain: [Gateway, DocumentDO], callee: SpellCheck }│
└──────────────────────────────────────────────────────────────────────┘
                                   ↓
┌──────────────────────────────────────────────────────────────────────┐
│ 4. SpellCheckWorker.check() executes                                 │
│    ctx.origin === Gateway ✓                                          │
│    ctx.caller === DocumentDO ✓                                       │
│    ctx.priorCaller === Gateway ✓                                     │
│    ctx.callChain === [Gateway, DocumentDO] ✓                         │
│    ctx.originAuth.userId === 'alice' ✓                               │
└──────────────────────────────────────────────────────────────────────┘
```

### Usage Example

```typescript
class SpellCheckWorker extends LumenizeWorker {
  async check(content: string): Promise<SpellError[]> {
    const ctx = this.lmz.callContext;
    
    // Verify original user has permission (not just immediate caller)
    if (!ctx?.originAuth?.claims?.canSpellCheck) {
      throw new Error('User not authorized for spell check');
    }
    
    // Log for audit trail
    console.log(`Spell check requested by ${ctx.originAuth.userId}`);
    console.log(`Called via ${ctx.caller.bindingName}/${ctx.caller.instanceNameOrId}`);
    console.log(`Full call path: ${ctx.callChain.map(n => n.bindingName).join(' → ')}`);
    
    // Proceed with spell check...
    const response = await fetch('https://api.spellcheck.example/check', {
      method: 'POST',
      body: JSON.stringify({ text: content })
    });
    return response.json();
  }
}
```

### Race Safety

Multiple concurrent requests to the same DO instance could interleave at `await` points. Lumenize uses `AsyncLocalStorage` internally to ensure each request sees its own `callContext` — even when requests overlap:

```
Request A arrives → sets context A
Request A awaits  → yields
Request B arrives → sets context B
Request A resumes → still sees context A ✓ (not B!)
```

This is handled automatically — you just access `this.lmz.callContext` and get the correct context for your request.

### Security: Immutable & Trust Model

**callContext is frozen (immutable)**

To prevent accidental or malicious modification, `callContext` is deep-frozen when created:

```typescript
ctx.originAuth.claims.isAdmin = true;
// TypeError: Cannot assign to read only property 'isAdmin'
```

This ensures that code within a node cannot modify auth claims before making sub-calls.

**Trust model**

Lumenize Mesh operates on a **trusted node** model:

| What's Trusted | What's Verified |
|----------------|-----------------|
| Nodes in your mesh (your code) | Token signatures at gateway entry |
| callContext propagation | Nothing after initial auth* |

*For high-security scenarios where you don't fully trust intermediate nodes, use signed tokens:

```typescript
interface CallContext {
  // ... callChain, callee ...
  
  originAuthToken?: string;  // Signed JWT - verifiable by any node
  originAuth?: { ... };       // Parsed claims (convenience cache)
}
```

Then verify independently:

```typescript
class SensitiveDO extends LumenizeDO {
  transferFunds(amount: number) {
    const ctx = this.lmz.callContext;
    
    // Don't trust parsed claims alone - verify the token!
    const verified = await verifyJWT(ctx.originAuthToken, this.env.JWT_PUBLIC_KEY);
    if (!verified.claims.canTransfer) {
      throw new Error('Not authorized for transfers');
    }
    // ... proceed
  }
}
```

**When to verify tokens independently:**
- Financial operations
- Data deletion
- Permission changes
- Cross-tenant operations

For most operations, the frozen `originAuth` from a trusted mesh is sufficient.

### Automatic vs Manual Propagation

**Automatic**: When you call `this.lmz.call()` or `this.lmz.callRaw()` from inside a method handler, the outgoing envelope includes the full `callContext` — caller (this node), callee (target), and `originAuth` (propagated from current context).

**Manual override**: If you need to make a call with different auth (e.g., service-to-service with elevated privileges), you can override:

```typescript
// Future API (not yet implemented)
this.lmz.call('TARGET_DO', 'instance', chain, handler, {
  overrideAuth: { claims: { isServiceCall: true } }
});
```

## Next Steps

- [Client API Reference](./client-api) — Complete API documentation
- [Gateway Internals](./gateway) — How LumenizeClientGateway works
- [@lumenize/auth](/docs/auth) — Server-side authentication

