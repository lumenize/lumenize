---
title: Auth Integration
description: Token handling patterns for LumenizeClient
---

# Auth Integration

LumenizeClient integrates with `@lumenize/auth` for seamless JWT authentication over WebSocket connections.

## How It Works

### Token Delivery via Subprotocol
Browsers don't allow custom headers on WebSocket connections. `LumenizeClient` uses the WebSocket subprotocol mechanism to pass JWT tokens securely:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

The server:
1. Extracts the token from the `lmz.access-token.{jwt}` protocol.
2. Verifies the JWT signature and expiration.
3. Accepts with `Sec-WebSocket-Protocol: lmz` (the primary protocol).

### Token Lifetime
- **Access tokens**: Short-lived (e.g., 15 minutes), passed with every connection attempt.
- **Refresh tokens**: Long-lived (e.g., 30 days), stored securely in HTTP-only cookies, used to obtain new access tokens.

---

## Configuration

### Client Configuration
Authentication is configured during client instantiation.

```typescript
import { LumenizeClient } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  
  // Initial access token
  accessToken: accessToken,
  
  // Token refresh is automatic!
  // Client parses JWT expiry and refreshes ~30s before expiration.
  refreshEndpoint: '/auth/refresh-token'  // Default
});
```

### Server Configuration
Use `createWebSocketAuthMiddleware` in your Worker's `fetch` handler:

```typescript
import { createWebSocketAuthMiddleware } from '@lumenize/auth';

export default {
  async fetch(request: Request, env: Env) {
    const wsAuthMiddleware = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY]
    });
    
    return routeDORequest(request, env, {
      // Verify token on WebSocket upgrade
      onBeforeConnect: wsAuthMiddleware
    });
  }
};
```

---

## Token Refresh Flow

The `LumenizeClient` handles token refresh **automatically** without any callbacks or manual intervention:

1.  **Monitor**: It parses the initial JWT to determine expiration.
2.  **Timer**: It sets an internal timer for ~30 seconds before expiry.
3.  **Refresh**: It makes an HTTP POST to the `refreshEndpoint` with `credentials: 'include'`.
4.  **Update**: It updates the internal token for future reconnection attempts and continues the session.

If the automatic refresh fails (e.g., because the refresh token cookie has expired), the client fires `onConnectionError` with a 401 error.

---

## Error Handling

### Token Expiration
There are two scenarios for expiration:

1.  **At Connection Time**: If the provided `accessToken` is already expired or invalid, `onConnectionError` fires immediately.
2.  **During an Active Session**: If the Gateway detects that the token has expired, it closes the WebSocket with code `4401`. The client will automatically attempt to refresh and reconnect.

### Auth Close Codes
The Gateway uses standard close codes to signal authentication issues:

| Code | Meaning | Recommended Action |
|------|---------|--------------------|
| `4400` | No token provided | Redirect to login |
| `4401` | Token expired | Refresh and reconnect (automatic) |
| `4403` | Invalid token/signature | Redirect to login |

---

## Security Best Practices

### 1. Token Storage
*   **Access Token**: Keep in memory only. `LumenizeClient` stores this in a private field. Never store access tokens in `localStorage`.
*   **Refresh Token**: Use **HTTP-only, Secure, SameSite=Strict** cookies. This protects the session from XSS attacks.

### 2. URL Safety
Never pass tokens in WebSocket URLs (e.g., `wss://app.com?token=...`). URLs are often logged by proxies and servers. Always use the subprotocol mechanism.

### 3. Identity Validation
The Gateway automatically validates that the user ID in the JWT matches the `instanceName` prefix to prevent impersonation. This means a user with ID `user-123` cannot connect to a Gateway DO named `user-456.tab-1`.

---
## Authentication in the Mesh

Once authenticated, your identity is automatically propagated to every node you call.

### `originAuth`
Mesh nodes receive your identity through the `this.lmz.callContext.originAuth` property. This contains the `userId` and any `claims` you included in the JWT.

```typescript
// Inside a server-side DO
@mesh
update(data: any) {
  const { userId, claims } = this.lmz.callContext.originAuth;
  if (!claims.canEdit) throw new Error("Unauthorized");
  // ...
}
```

See the [Mesh Overview: Zero Trust](./index#zero-trust) for details on propagation and access control.

---

## Complete Example

```typescript
// editor-auth.ts
import { LumenizeClient, mesh } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }

  onSubscriptionsLost = () => {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}

export async function initApp(accessToken: string, userId: string) {
  using client = new EditorClient({
    baseUrl: 'wss://app.example.com',
    instanceName: `${userId}.${getTabId()}`,
    accessToken,
    onConnectionError: (error) => {
      if (error.message.includes('401')) {
        window.location.href = '/login';
      }
    }
  });

  // Mesh calls are now authenticated
  client.lmz.call('DOCUMENT_DO', 'doc-1', client.ctn<DocumentDO>().subscribe());
}
```

## Next Steps

- [Mesh Overview](./index) — Concepts and `CallContext` details
- [Client API Reference](./client-api) — Complete API documentation
- [Gateway Internals](./gateway) — Architecture and trust boundaries
