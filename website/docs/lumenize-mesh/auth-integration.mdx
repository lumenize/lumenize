---
title: Auth Integration
description: JWT authentication, access control, and callContext propagation in the mesh
---

# Auth Integration

The Lumenize Mesh integrates with `@lumenize/auth` for secure, passwordless authentication via magic links and JWT tokens.

## Overview

| Feature | Description |
|---------|-------------|
| **Passwordless** | Magic link email login (no passwords to manage) |
| **Secure JWTs** | Ed25519 signed tokens with key rotation support |
| **Refresh rotation** | Automatic token refresh with revocation |
| **Rate limiting** | Built-in protection against abuse |
| **WebSocket auth** | Token passing via subprotocol headers |
| **Middleware** | Drop-in hooks for HTTP and WebSocket routes |

---

## Installation & Setup

### 1. Install

```bash @skip-check
npm install @lumenize/auth @lumenize/mesh @lumenize/utils
```

### 2. Generate Ed25519 Key Pair

```bash @skip-check
# Generate private key
openssl genpkey -algorithm ed25519 -out private.pem

# Extract public key
openssl pkey -in private.pem -pubout -out public.pem

# View keys (copy to .dev.vars)
cat private.pem | tr '\n' '\\n' && echo
cat public.pem | tr '\n' '\\n' && echo
```

### 3. Configure `.dev.vars`

```bash @skip-check
JWT_PRIVATE_KEY_BLUE="-----BEGIN PRIVATE KEY-----\nMC4CAQAw..."
JWT_PUBLIC_KEY_BLUE="-----BEGIN PUBLIC KEY-----\nMCowBQYD..."
ACTIVE_JWT_KEY="BLUE"
```

### 4. Configure `wrangler.jsonc`

```jsonc @skip-check
{
  "name": "my-app",
  "main": "src/index.ts",
  "compatibility_date": "2025-09-12",
  "durable_objects": {
    "bindings": [
      { "name": "LUMENIZE_AUTH", "class_name": "LumenizeAuth" },
      { "name": "LUMENIZE_CLIENT_GATEWAY", "class_name": "LumenizeClientGateway" },
      { "name": "DOCUMENT_DO", "class_name": "DocumentDO" }
    ]
  },
  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["LumenizeAuth", "DocumentDO"] }
  ]
}
```

### 5. Set Up Worker with Auth Middleware

```typescript @skip-check
import { LumenizeAuth, createAuthMiddleware, createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

export { LumenizeAuth };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Auth routes - public (no middleware)
    const authResponse = await routeDORequest(request, env, {
      prefix: 'auth',
      cors: true
    });
    if (authResponse) return authResponse;

    // Create auth middleware
    const httpAuth = await createAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });
    const wsAuth = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE]
    });

    // Protected routes - with auth middleware
    return routeDORequest(request, env, {
      onBeforeRequest: httpAuth,
      onBeforeConnect: wsAuth,
      cors: true
    }) ?? new Response('Not Found', { status: 404 });
  }
};
```

---

## Login Flow

Magic link authentication works as follows:

```mermaid
sequenceDiagram
    participant User
    participant Worker
    participant AuthDO
    participant Email
    
    User->>Worker: POST /auth/email-magic-link {email}
    Worker->>AuthDO: Forward request
    AuthDO->>Email: Send magic link
    AuthDO->>Worker: {message: "Check email"}
    Worker->>User: Response
    
    Note over User: User clicks email link
    
    User->>Worker: GET /auth/magic-link?token=...&state=...
    Worker->>AuthDO: Validate token
    AuthDO->>Worker: {access_token, Set-Cookie: refresh-token}
    Worker->>User: JWT + refresh cookie
```

### Request Magic Link

```typescript @skip-check
const response = await fetch('/auth/email-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email: 'user@example.com' })
});
// Returns: { message: "Check your email for the magic link", expires_in: 1800 }
```

### Validate Magic Link

When the user clicks the link in their email:

```json @skip-check
{
  "access_token": "eyJhbGciOiJFZERTQSIs...",
  "token_type": "Bearer",
  "expires_in": 900
}
```

Plus a `Set-Cookie` header with the refresh token (HttpOnly, Secure, SameSite=Strict).

---

## WebSocket Authentication

### Token Delivery via Subprotocol

Browsers don't allow custom headers on WebSocket connections. `LumenizeClient` uses the subprotocol mechanism:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

The server:
1. Extracts the token from `lmz.access-token.{jwt}`
2. Verifies JWT signature and expiration
3. Accepts with `Sec-WebSocket-Protocol: lmz`

### Client Configuration

```typescript @skip-check
using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: accessToken,
  refreshEndpoint: '/auth/refresh-token'  // Default
});
```

### Automatic Token Refresh

`LumenizeClient` handles refresh automatically:

1. **Monitor**: Parses JWT to determine expiration
2. **Timer**: Sets timer for ~30 seconds before expiry
3. **Refresh**: POSTs to `refreshEndpoint` with `credentials: 'include'`
4. **Update**: Updates internal token for future reconnections

If refresh fails (e.g., refresh token expired), `onConnectionError` fires with a 401 error.

---

## Identity in the Mesh

### `callContext.originAuth`

Once authenticated, your identity propagates through the entire call chain:

```typescript @skip-check
// In any mesh node
@mesh
updateDocument(changes: DocumentChange) {
  const userId = this.lmz.callContext.originAuth?.userId;
  const claims = this.lmz.callContext.originAuth?.claims;
  
  // Identity is the ORIGINAL caller's, even through multiple hops
}
```

**Call chain example:**
```
Client (alice) → DocumentDO → ValidationWorker → NotificationDO
                    ↓              ↓                  ↓
            originAuth has   originAuth has    originAuth has
            alice's auth     alice's auth      alice's auth (propagated!)
```

### Context Preservation

`callContext` (including `originAuth`) is automatically captured in continuations. Even if a DO hibernates during a long-running operation, your handler receives the correct context.

See [Managing Context](./managing-context) for the full guide.

---

## Access Control

### Three-Layer Security Model

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **Class-wide** | `onBeforeCall()` hook | WHO can call (auth, rate limiting) |
| **Entry Point** | `@mesh` decorator | WHAT is exposed (method allowlist) |
| **Capability Trust** | Automatic | Returned objects trusted for that chain |

### Class-Level: `onBeforeCall()`

Override to enforce class-wide policies:

```typescript @skip-check
class ProtectedDO extends LumenizeDO<Env> {
  onBeforeCall(callContext: CallContext) {
    super.onBeforeCall(callContext);

    // Require authentication
    if (!callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }
}
```

### Method-Level: `@mesh` Guard

```typescript @skip-check
@mesh((callContext) => {
  if (!callContext.originAuth?.claims?.isAdmin) {
    throw new Error('Admin only');
  }
})
adminMethod() {
  // Only admins reach here
}
```

### Reusable Guards

```typescript @skip-check
function requireRole(role: string) {
  return (callContext: CallContext) => {
    const roles = callContext.originAuth?.claims?.roles ?? [];
    if (!roles.includes(role)) {
      throw new Error(`Role ${role} required`);
    }
  };
}

@mesh(requireRole('editor'))
editDocument(changes: DocumentChange) { /* ... */ }

@mesh(requireRole('admin'))
deleteDocument() { /* ... */ }
```

### State-Based Access

Use `callContext.state` for middleware to pass computed access data:

```typescript @skip-check
// In middleware
async onBeforeRequest(request, callContext) {
  const user = await loadUserFromDatabase(callContext.originAuth.userId);
  callContext.state.user = user;
  callContext.state.permissions = await computePermissions(user);
}

// In method guard
@mesh((callContext) => {
  if (!callContext.state.permissions.canEdit) {
    throw new Error('Edit permission required');
  }
})
editDocument(changes: DocumentChange) { /* ... */ }
```

---

## HTTP Route Protection

### Creating Middleware

```typescript @skip-check
import { createAuthMiddleware } from '@lumenize/auth';

const httpAuth = await createAuthMiddleware({
  publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN],
  audience: 'https://myapp.com',
  issuer: 'https://myapp.com'
});
```

### Using with routeDORequest

```typescript @skip-check
return routeDORequest(request, env, {
  onBeforeRequest: httpAuth,
  cors: true
});
```

The middleware:
1. Extracts Bearer token from `Authorization` header
2. Verifies JWT signature (tries all provided keys for rotation)
3. Validates expiration, audience, issuer
4. On success: Enhances request with `X-Auth-User-Id` and `X-Auth-Verified` headers
5. On failure: Returns 401 with `WWW-Authenticate` header

---

## Key Rotation

Zero-downtime key rotation with BLUE/GREEN keys:

1. **Normal operation**: Sign with BLUE, verify with BLUE
2. **Rotate keys**:
   - Generate new GREEN key pair
   - Add `JWT_PRIVATE_KEY_GREEN` and `JWT_PUBLIC_KEY_GREEN` to secrets
   - Add GREEN public key to middleware: `publicKeysPem: [BLUE, GREEN]`
   - Set `ACTIVE_JWT_KEY="GREEN"` to start signing with GREEN
3. **After all BLUE tokens expire**: Remove BLUE keys from middleware

```typescript @skip-check
// During rotation: accept tokens signed with either key
const middleware = await createAuthMiddleware({
  publicKeysPem: [
    env.JWT_PUBLIC_KEY_BLUE,   // Active key
    env.JWT_PUBLIC_KEY_GREEN   // Fallback during rotation
  ]
});
```

---

## Error Handling

### Auth Close Codes

The Gateway uses standard WebSocket close codes for auth issues:

| Code | Meaning | Action |
|------|---------|--------|
| `4400` | No token provided | Redirect to login |
| `4401` | Token expired | Refresh and reconnect (automatic) |
| `4403` | Invalid token/signature | Redirect to login |

### Client Error Handling

```typescript @skip-check
using client = new EditorClient({
  accessToken,
  onConnectionError: (error) => {
    if (error.message.includes('401')) {
      window.location.href = '/login';
    }
  }
});
```

---

## Security Best Practices

### 1. Token Storage

- **Access Token**: Keep in memory only. Never store in `localStorage`
- **Refresh Token**: HTTP-only, Secure, SameSite=Strict cookies

### 2. URL Safety

Never pass tokens in WebSocket URLs:
```
❌ wss://app.com?token=...  // Logged by proxies!
✅ Use subprotocol mechanism
```

### 3. Identity Validation

The Gateway validates that the JWT's user ID matches the `instanceName` prefix, preventing impersonation:
- User `alice` can connect to `alice.tab1`
- User `alice` cannot connect to `bob.tab1`

### 4. Short-Lived Tokens

Default token lifetimes:
- **Access token**: 15 minutes (configurable)
- **Refresh token**: 30 days (configurable)

Shorter access tokens = less damage if stolen.

---

## API Reference

### Auth Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/auth/enter` | GET | Login instructions |
| `/auth/email-magic-link` | POST | Request magic link (body: `{email}`) |
| `/auth/magic-link` | GET | Validate magic link and login |
| `/auth/refresh-token` | POST | Refresh access token (uses cookie) |
| `/auth/logout` | POST | Revoke refresh token |

### Middleware Functions

```typescript @skip-check
// HTTP auth
const httpAuth = await createAuthMiddleware({
  publicKeysPem: string[],
  audience?: string,
  issuer?: string
});

// WebSocket auth
const wsAuth = await createWebSocketAuthMiddleware({
  publicKeysPem: string[]
});
```

### JWT Utilities

```typescript @skip-check
import {
  signJwt,
  verifyJwt,
  verifyJwtWithRotation,
  importPrivateKey,
  importPublicKey,
  parseJwtUnsafe
} from '@lumenize/auth';
```

### WebSocket Utilities

```typescript @skip-check
import {
  extractWebSocketToken,
  verifyWebSocketToken,
  getTokenTtl,
  WS_CLOSE_CODES
} from '@lumenize/auth';
```

---

## Test Mode

For development, add `?_test=true` to get the magic link directly:

```typescript @skip-check
const response = await fetch('/auth/email-magic-link?_test=true', {
  method: 'POST',
  body: JSON.stringify({ email: 'test@example.com' })
});
// Returns: { message: "Magic link generated (test mode)", magic_link: "..." }
```

Requires `AUTH_TEST_MODE="true"` in environment.

---

## See Also

- **[Managing Context](./managing-context)** — How callContext propagates
- **[LumenizeClient](./lumenize-client)** — Client-side token handling
- **[Gateway Internals](./gateway)** — Trust boundaries
