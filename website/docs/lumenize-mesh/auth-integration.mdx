---
title: Auth Integration
description: Token handling patterns for LumenizeClient
---

# Auth Integration

LumenizeClient integrates with `@lumenize/auth` for seamless JWT authentication over WebSocket connections.

## How It Works

### Token Delivery via Subprotocol

Browsers don't allow custom headers on WebSocket connections. LumenizeClient uses the WebSocket subprotocol mechanism to pass JWT tokens:

```
Sec-WebSocket-Protocol: lmz, lmz.access-token.eyJhbGciOiJF...
```

The server:
1. Extracts the token from the `lmz.access-token.{jwt}` protocol
2. Verifies the JWT signature and expiration
3. Accepts with `Sec-WebSocket-Protocol: lmz` (the primary protocol)
4. Stores token metadata in WebSocket attachment for per-message verification

### Token Lifetime

- **Access tokens**: 15 minutes (short-lived, passed with every connection)
- **Refresh tokens**: 30 days (stored securely, used to get new access tokens)

## Basic Setup

### Client Configuration

Using the document editing example from the overview:

```typescript
import { LumenizeClient } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${getTabId()}`,
  
  // Initial access token
  accessToken: accessToken,
  
  // Token refresh handled automatically!
  // Client parses JWT expiry, refreshes ~30s before expiration
  // using HTTP-only refresh token cookie
  refreshEndpoint: '/auth/refresh-token'  // This is the default
});
```

### Server Configuration

Use `createWebSocketAuthMiddleware` in your Worker:

```typescript
import { createWebSocketAuthMiddleware } from '@lumenize/auth';
import { routeDORequest } from '@lumenize/utils';

export default {
  async fetch(request: Request, env: Env) {
    const wsAuthMiddleware = await createWebSocketAuthMiddleware({
      publicKeysPem: [env.JWT_PUBLIC_KEY_BLUE, env.JWT_PUBLIC_KEY_GREEN]
    });
    
    return routeDORequest(request, env, {
      // Verify token on WebSocket upgrade
      onBeforeConnect: wsAuthMiddleware
    });
  }
};
```

## Token Refresh Flow

Token refresh is **automatic** — LumenizeClient handles it internally:

```
┌───────────────────────────────────────────────────────────────┐
│                                                               │
│   Client                    Server                            │
│     │                          │                              │
│     │  Connect with token      │                              │
│     ├─────────────────────────→│                              │
│     │                          │ Verify JWT                   │
│     │         Connected        │                              │
│     │←─────────────────────────┤                              │
│     │                          │                              │
│     │     ... 14 minutes ...   │                              │
│     │                          │                              │
│     │ (internal: token expiring soon)                         │
│     │                          │                              │
│     │  POST /auth/refresh-token (with cookie)                 │
│     ├─────────────────────────→│                              │
│     │          new accessToken │                              │
│     │←─────────────────────────┤                              │
│     │                          │                              │
│     │ (internal: update token) │                              │
│     │                          │                              │
│     │     ... continues ...    │                              │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

No callback needed — the client:
1. Parses JWT to determine expiration time
2. Sets internal timer for ~30 seconds before expiry
3. Makes HTTP POST to `refreshEndpoint` with `credentials: 'include'`
4. Updates internal token and continues

## Gateway Token Verification

LumenizeClientGateway verifies tokens in two places:

### 1. On Connection (via Middleware)

```typescript
// Worker routes to Gateway with verified auth context
onBeforeConnect: async (request, context) => {
  const result = await wsAuthMiddleware(request, context);
  // Returns enhanced request with X-Auth-User-Id header
  return result;
}
```

### 2. On Each Message (via Attachment)

```typescript
// In LumenizeClientGateway
async webSocketMessage(ws: WebSocket, message: string) {
  const attachment = ws.deserializeAttachment();
  
  // Check if token has expired
  if (attachment.tokenExp && attachment.tokenExp < Date.now() / 1000) {
    ws.close(4401, 'Token expired');
    return;
  }
  
  // Process message...
}
```

## Token Storage

### Access Token

Stored in memory (private field). Never persisted to localStorage or cookies. Managed automatically by LumenizeClient.

```typescript
// Inside LumenizeClient (internal)
#accessToken: string | null = null;
// Updated automatically during refresh
```

### Refresh Token

Use HTTP-only cookies (recommended):

```typescript
// Login response sets cookie
Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict; Path=/auth

// Client refresh request includes cookie automatically
fetch('/auth/refresh-token', {
  method: 'POST',
  credentials: 'include'
});
```

## Error Handling

### Token Expired During Connection

```typescript
client.onConnectionError = (error) => {
  if (error.message.includes('401')) {
    // Token was invalid/expired at connection time
    redirectToLogin();
  }
};
```

### Token Expires During Session

The Gateway closes the WebSocket with code `4401`:

```typescript
client.onConnectionStateChange = (state) => {
  if (state === 'disconnected') {
    // Check if we were kicked due to auth
    // The close event will have code 4401
  }
};

// Or handle via WebSocket close event
ws.onclose = (event) => {
  if (event.code === 4401) {
    // Token expired - try to refresh and reconnect
    refreshAndReconnect();
  }
};
```

### Refresh Token Expired

When the refresh token expires, the automatic refresh will fail with a 401. Handle this via `onConnectionError`:

```typescript
const client = createLumenizeClient({
  // ...
  onConnectionError: (error) => {
    if (error.message.includes('401') || error.message.includes('Session expired')) {
      // Refresh token expired - must re-authenticate
      redirectToLogin();
    }
  }
});
```

The client will automatically attempt refresh and surface the error if it fails.

## WebSocket Close Codes

LumenizeClientGateway uses custom close codes for auth errors:

| Code | Meaning | Client Action |
|------|---------|---------------|
| `4400` | No token | Redirect to login |
| `4401` | Token expired | Refresh and reconnect |
| `4403` | Invalid token | Redirect to login |

```typescript
import { WS_CLOSE_CODES } from '@lumenize/auth';

// WS_CLOSE_CODES.TOKEN_EXPIRED === 4401
// WS_CLOSE_CODES.UNAUTHORIZED === 4403
// WS_CLOSE_CODES.NO_TOKEN === 4400
```

## Security Considerations

### Token in URL (Avoid)

Never put tokens in WebSocket URLs:

```typescript
// ❌ BAD - Token in URL, logged everywhere
const ws = new WebSocket(`wss://app.com/gateway?token=${jwt}`);

// ✅ GOOD - Token in subprotocol, not logged
const ws = new WebSocket(url, ['lmz', `lmz.access-token.${jwt}`]);
```

### Token Storage (Client-Side)

```typescript
// ❌ BAD - Accessible to XSS
localStorage.setItem('accessToken', jwt);

// ✅ GOOD - Memory only, not accessible to XSS
let accessToken = jwt; // Closure variable
```

### Gateway Identity Validation

The Gateway instance name should include the user ID to prevent impersonation:

```typescript
// Instance name format: userId.tabId
const instanceName = `${userId}.${tabId}`;

// Gateway can verify caller matches instance
async fetch(request: Request) {
  const authUserId = request.headers.get('X-Auth-User-Id');
  const instanceUserId = this.lmz.instanceName?.split('.')[0];
  
  if (authUserId !== instanceUserId) {
    return new Response('Unauthorized', { status: 403 });
  }
  // ...
}
```

## Complete Example

Using the document editing example:

```typescript
// editor-auth.ts
import { LumenizeClient } from '@lumenize/mesh';

// Define the editor client with handlers
class EditorClient extends LumenizeClient {
  editor: EditorInstance;
  documentId: string;
  
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
  
  // Re-subscribe after grace period expires
  onSubscriptionsLost = () => {
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}

// App state
let client: EditorClient | null = null;
let userId = '';

export async function login(email: string): Promise<void> {
  // Request magic link
  await fetch('/auth/email-magic-link', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email })
  });
}

export async function handleMagicLinkCallback(token: string): Promise<void> {
  // Exchange magic link for tokens
  const response = await fetch(`/auth/magic-link?token=${token}`);
  const { accessToken, user } = await response.json();
  
  userId = user.id;
  
  // Create authenticated editor client
  // Token refresh is automatic via HTTP-only cookie!
  client = new EditorClient({
    baseUrl: 'wss://app.example.com',
    instanceName: `${userId}.${getTabId()}`,
    accessToken,
    // refreshEndpoint: '/auth/refresh-token'  // default
    
    onConnectionError: (error) => {
      if (error.message.includes('401') || error.message.includes('Session expired')) {
        logout();
      }
    }
  });
}

export async function openDocument(documentId: string): Promise<void> {
  if (!client) throw new Error('Not authenticated');
  
  client.documentId = documentId;
  
  // Subscribe to document updates
  client.lmz.call('DOCUMENT_DO', documentId, client.ctn<DocumentDO>().subscribe());
}

export async function logout(): Promise<void> {
  // Disconnect client
  client?.disconnect();
  client = null;
  
  // Clear server session
  await fetch('/auth/logout', {
    method: 'POST',
    credentials: 'include'
  });
  
  userId = '';
  window.location.href = '/login';
}

function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}
```

## Next Steps

- [Client API Reference](./client-api) — Complete API documentation
- [Gateway Internals](./gateway) — How LumenizeClientGateway works
- [@lumenize/auth](/docs/auth) — Server-side authentication

