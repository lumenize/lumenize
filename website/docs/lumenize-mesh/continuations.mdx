---
title: Continuations
description: How Lumenize's type-safe, serializable operation chains work under the hood
---

# Continuations

A **Continuation** is a **description of work** that gets executed in some other place or time — usually during or after some native async operation.

```typescript @skip-check
const remote = this.ctn<RemoteDO>().getUserData(userId);
const local = this.ctn().handleResult(this.ctn().$result);
this.lmz.call('REMOTE_DO', 'instance-id', remote, local);
```

**For practical patterns**, see **[Making Calls](./calls)** — this document focuses on how continuations work under the hood.

---

## Why Continuations?

Continuations solve several problems in Durable Objects:

1. **Serializable** — Can be stored, sent over the wire, or survive hibernation
2. **Type-safe** — TypeScript checks method names and signatures at compile time
3. **No `await` needed** — Avoid `async`/`await` which can break DO consistency guarantees
4. **Context capture** — `callContext` is automatically preserved across hibernation

---

## The `this.ctn()` Factory

Components extending `LumenizeDO`, `LumenizeWorker`, or `LumenizeClient` have access to `this.ctn()`:

```typescript @skip-check
// Typed: TypeScript knows RemoteDO's methods
this.ctn<RemoteDO>().someMethod(arg)

// Untyped: for local handlers on this instance
this.ctn().myHandler(this.ctn().$result)

// Chaining: multiple operations in sequence
this.ctn<RemoteDO>().validate().save().getRevision()

// Nesting: output of one operation feeds another
this.ctn<RemoteDO>().multiply(this.ctn<RemoteDO>().add(1, 2), 10)
```

### The `$result` Placeholder

The special `$result` property marks where the async operation's result should be injected:

```typescript @skip-check
this.ctn().handleResult(this.ctn().$result)
//                      ^^^^^^^^^^^^^^^^^ replaced with actual result (or Error)
```

You can use `$result` anywhere in the arguments — it's just a marker that gets substituted at execution time.

---

## How It Works

### 1. Proxy-Based Chain Building

`this.ctn()` returns a JavaScript `Proxy`. Each property access or method call records an operation:

```typescript @skip-check
this.ctn<UserDO>().getProfile(userId).formatName()
```

This builds an **operation chain**: `[{ method: 'getProfile', args: ['user-123'] }, { method: 'formatName', args: [] }]`

### 2. Serialization

When you pass a continuation to `this.lmz.call()`, it's serialized using `@lumenize/structured-clone`:

```typescript @skip-check
// The chain becomes a serializable object
{
  ops: [
    { type: 'call', name: 'getProfile', args: ['user-123'] },
    { type: 'call', name: 'formatName', args: [] }
  ],
  context: { /* captured callContext */ }
}
```

This can be:
- Sent over the wire to another DO/Worker
- Stored in SQLite for later execution
- Passed to an alarm handler

### 3. Execution

On the receiving end, `executeOperationChain()` walks the chain:

```typescript @skip-check
// Simplified execution logic
let result = target;
for (const op of chain.ops) {
  if (op.type === 'call') {
    result = result[op.name](...op.args);
  } else if (op.type === 'get') {
    result = result[op.name];
  }
}
return result;
```

Before execution, `callContext` is restored from the captured snapshot — ensuring your handler sees the correct auth and context even after hibernation.

---

## OCAN: Operation Chaining And Nesting

Continuations use **OCAN** (Operation Chaining And Nesting) — a serialization format that supports:

| Feature | Example |
|---------|---------|
| **Chaining** | `a().b().c()` — sequential calls on returned values |
| **Nesting** | `a(b(), c())` — results of inner calls as arguments |
| **Mixed** | `a(b().c()).d()` — arbitrary combinations |
| **Placeholders** | `$result` — substitute async results |

For the full specification, see [@lumenize/rpc: Operation Chaining and Nesting](/docs/rpc/operation-chaining-and-nesting).

---

## Context Capture

Continuations automatically capture `callContext` at serialization time (when `getOperationChain()` is called internally). This means:

- If a DO hibernates while waiting for a response, the handler still receives the original context
- No manual context passing needed for auth/identity
- The captured context is the **source of truth** — it overrides any ambient context during execution

See [Managing Context](./managing-context) for the full context propagation model.

---

## Manual Serialization (Advanced)

For power users who need direct access to the serialized form:

```typescript @skip-check
import { getOperationChain, executeOperationChain } from '@lumenize/mesh';

// Extract the serializable operation chain
const chain = getOperationChain(this.ctn<SomeDO>().method(arg));

// Store it
this.ctx.storage.kv.put('pendingWork', chain);

// Later, execute it
const chain = this.ctx.storage.kv.get('pendingWork');
const result = executeOperationChain(chain, targetObject);
```

---

## Best Practices

- ✅ Use `this.ctn<T>()` for type safety on remote calls
- ✅ Check for `Error` first in every handler (see [Error Handling](./calls#error-handling))
- ✅ Use chaining to reduce round trips
- ❌ Don't use `async` handlers — breaks DO consistency model

---

## See Also

- **[Making Calls](./calls)** — Practical patterns for `this.lmz.call()`
- **[Managing Context](./managing-context)** — Framework vs. application context
- **[@lumenize/rpc: OCAN](/docs/rpc/operation-chaining-and-nesting)** — Full OCAN specification
