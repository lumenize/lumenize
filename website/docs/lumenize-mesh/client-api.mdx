---
title: Client API Reference
description: Complete LumenizeClient API documentation
---

# LumenizeClient API

Complete API reference for creating and using LumenizeClient instances.

## Creating a Client

### Factory Function (Recommended)

```typescript
import { createLumenizeClient } from '@lumenize/mesh';

const client = createLumenizeClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: jwt
});
```

### Class-Based (For Extending)

Using the document editing example:

```typescript
import { LumenizeClient } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  // Called by DocumentDO when content changes
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}

using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: jwt
});
```

## Configuration

### LumenizeClientConfig

```typescript
interface LumenizeClientConfig {
  /**
   * Base URL for WebSocket connection.
   * Must use wss:// for production.
   * @example 'wss://app.example.com'
   */
  baseUrl: string;
  
  /**
   * Gateway DO binding name.
   * @default 'GATEWAY_DO'
   */
  gatewayBinding?: string;
  
  /**
   * Instance name — becomes the Gateway DO name.
   * Recommended format: `${userId}.${tabId}`
   * 
   * The tabId should be unique per browser tab (stored in sessionStorage).
   * @example 'user-123.tab-abc'
   */
  instanceName: string;
  
  /**
   * Initial JWT access token for authentication.
   * Passed via WebSocket subprotocol (not in URL).
   */
  accessToken?: string;
  
  /**
   * Endpoint for token refresh.
   * Client automatically refreshes ~30s before expiration using
   * HTTP-only refresh token cookie.
   * @default '/auth/refresh-token'
   */
  refreshEndpoint?: string;
  
  /**
   * Called when connection state changes.
   */
  onConnectionStateChange?: (state: ConnectionState) => void;
  
  /**
   * Called when a connection error occurs.
   * This is for connection-level errors, not RPC errors.
   */
  onConnectionError?: (error: Error) => void;

  // Note: No onMessage callback - all mesh→client communication
  // goes through method calls via this.lmz.call()
  
  /**
   * Request timeout in milliseconds.
   * @default 30000 (30 seconds)
   */
  timeout?: number;
  
  /**
   * Whether to auto-reconnect on connection drop.
   * @default true
   */
  autoReconnect?: boolean;
  
  /**
   * Custom WebSocket class (for testing or polyfills).
   * @default globalThis.WebSocket
   */
  WebSocketClass?: typeof WebSocket;
}

type ConnectionState = 
  | 'disconnected'
  | 'connecting' 
  | 'connected'
  | 'reconnecting';
```

## Instance Properties

### `lmz`

Access to Lumenize Mesh infrastructure:

```typescript
interface LmzClientApi {
  /**
   * Always 'LumenizeClient' for clients.
   */
  readonly type: 'LumenizeClient';
  
  /**
   * Gateway binding name (e.g., 'GATEWAY_DO').
   */
  readonly bindingName?: string;
  
  /**
   * Client instance name (becomes Gateway DO name).
   */
  readonly instanceName?: string;
  
  /**
   * Alias for instanceName (for API consistency with LumenizeBase).
   */
  readonly instanceNameOrId?: string;
  
  /**
   * Make an async RPC call to a mesh node.
   * Returns when the remote method completes.
   * 
   * @param binding - Target binding name (e.g., 'USER_DO')
   * @param instance - Target instance name/id (undefined for Workers)
   * @param chain - Operation chain from this.ctn()
   */
  callRaw(
    binding: string,
    instance: string | undefined,
    chain: OperationChain
  ): Promise<any>;
  
  /**
   * Make an RPC call with continuation pattern.
   * 
   * @param binding - Target binding name
   * @param instance - Target instance name/id
   * @param remote - Remote continuation (what to execute on target)
   * @param handler - Optional handler continuation (what to execute locally when done)
   */
  call(
    binding: string,
    instance: string | undefined,
    remote: Continuation<any>,
    handler?: Continuation<any>
  ): void;
}
```

### `connectionState`

Current connection state:

```typescript
readonly connectionState: ConnectionState;

// Example usage
if (client.connectionState === 'connected') {
  // Safe to make calls
}
```

## Instance Methods

### `ctn<T>()`

Create a continuation for building operation chains:

```typescript
ctn<T = this>(): Continuation<T>;
```

Usage:

```typescript
// Call a method on a remote DO
const chain = client.ctn<UserDO>().getUserData(userId);
const result = await client.lmz.callRaw('USER_DO', userId, chain);

// Chain multiple operations
const chain = client.ctn<DataDO>()
  .loadData()
  .transform()
  .validate();
```

### `connect()`

Establish WebSocket connection to Gateway:

```typescript
async connect(): Promise<void>;
```

Connection is **lazy** — it's automatically established on first `callRaw()` if not already connected. Call `connect()` explicitly if you want to establish the connection early.

```typescript
// Explicit connection
await client.connect();
console.log(client.connectionState); // 'connected'
```

### `disconnect()`

Close WebSocket connection:

```typescript
disconnect(): void;
```

After disconnecting, calls will fail until reconnected. If `autoReconnect` is true, the client will attempt to reconnect on the next call.

### `[Symbol.dispose]()`

Resource cleanup for `using` syntax:

```typescript
// Automatically disconnects when scope exits
{
  using client = createLumenizeClient(config);
  await client.lmz.callRaw('USER_DO', userId, chain);
} // client.disconnect() called automatically
```

## Making Calls

### `callRaw()` - Async Pattern

```typescript
// Get document content
const content = await client.lmz.callRaw(
  'DOCUMENT_DO',
  documentId,
  client.ctn<DocumentDO>().getContent()
);

// Call SpellCheck Worker (no instance name for Workers)
const errors = await client.lmz.callRaw(
  'SPELLCHECK_WORKER',
  undefined,
  client.ctn<SpellCheckWorker>().check(content)
);

// Call another client (collaborative cursor)
const cursor = await client.lmz.callRaw(
  'GATEWAY_DO',
  `${otherUserId}.${otherTabId}`,
  client.ctn<EditorClient>().getCursorPosition()
);
```

### `call()` - Continuation Pattern

```typescript
// Fire-and-forget: send document update
client.lmz.call(
  'DOCUMENT_DO',
  documentId,
  client.ctn<DocumentDO>().update({ type: 'insert', text: 'Hello' })
);

// With result handler: get content and handle response
client.lmz.call(
  'DOCUMENT_DO',
  documentId,
  client.ctn<DocumentDO>().getContent(),
  client.ctn().handleContentLoaded(client.ctn().$result)
);

// Handler method in EditorClient
handleContentLoaded(content: string) {
  this.editor.setContent(content);
}
```

## Receiving Calls

Define methods on your client class that mesh nodes can call:

```typescript
class EditorClient extends LumenizeClient {
  // Called by DocumentDO when content changes
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
    // No return = fire-and-forget from server's perspective
  }
  
  // Called for collaborative cursor updates
  handleCursorUpdate(userId: string, position: Position) {
    this.cursors.set(userId, position);
    this.renderCursors();
  }
  
  // Called to get this client's cursor (returns a value)
  getCursorPosition(): Position {
    return this.editor.getCursorPosition();
  }
}
```

From DocumentDO (pushing updates to clients):

```typescript
// In DocumentDO - notify all collaborators
notifyCollaborators(change: DocumentChange) {
  for (const clientId of this.getConnectedClients()) {
    this.lmz.call(
      'GATEWAY_DO',
      clientId,
      this.ctn<EditorClient>().handleDocumentChange(change)
    );
  }
}
```

## Error Handling

### Connection Errors

```typescript
const client = createLumenizeClient({
  // ...
  onConnectionError: (error) => {
    console.error('Connection error:', error.message);
    showConnectionErrorUI();
  }
});
```

### RPC Errors

```typescript
try {
  const content = await client.lmz.callRaw(
    'DOCUMENT_DO',
    documentId,
    client.ctn<DocumentDO>().getContent()
  );
} catch (error) {
  if (error.message === 'Client not connected') {
    // Gateway says we're disconnected
  } else if (error.message.includes('timeout')) {
    // Request timed out
  } else {
    // Error thrown by remote method
    console.error('RPC error:', error);
  }
}
```

### Connection State Handling

```typescript
const client = createLumenizeClient({
  // ...
  onConnectionStateChange: (state) => {
    switch (state) {
      case 'connecting':
        showConnectingSpinner();
        break;
      case 'connected':
        hideSpinner();
        enableFeatures();
        break;
      case 'reconnecting':
        showReconnectingBanner();
        break;
      case 'disconnected':
        disableFeatures();
        break;
    }
  }
});
```

## Reconnection & Subscriptions

### Grace Period

When a client disconnects, the Gateway waits **5 seconds** before cleaning up. If the client reconnects within this grace period:
- Subscriptions remain valid
- No re-subscription needed
- `onSubscriptionsLost` is **not** called

### Subscription Loss

If the client reconnects **after** the grace period:
1. Gateway informs the client that subscriptions were lost
2. Client receives this info in the WebSocket handshake response
3. `onSubscriptionsLost` callback fires
4. Client must re-subscribe to any DOs it was subscribed to

```typescript
class EditorClient extends LumenizeClient {
  documentId: string;
  
  onSubscriptionsLost = () => {
    // Called only when reconnecting after grace period expired
    // Re-subscribe to the document we were editing
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}
```

### How It Works

The Gateway is the source of truth for subscription state:

1. **Client disconnects** → Gateway sets alarm for 5 seconds
2. **Within grace period**: Client reconnects, alarm cancelled, subscriptions intact
3. **After grace period**: Alarm fires, Gateway notifies subscribed DOs with `ClientDisconnectedError`, cleans up
4. **Late reconnect**: Gateway tells client "subscriptions lost" in handshake, client calls `onSubscriptionsLost`

This design ensures:
- Brief network glitches don't cause subscription churn
- DOs can clean up stale subscriptions
- Clients know when to re-subscribe

## Browser Considerations

### Tab Identity

Generate a unique tab ID and store it in sessionStorage:

```typescript
function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}

const client = createLumenizeClient({
  instanceName: `${userId}.${getTabId()}`
});
```

### Page Visibility

Consider disconnecting when the page is hidden to save resources:

```typescript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    client.disconnect();
  } else {
    client.connect();
  }
});
```

### Multiple Tabs

Each tab should have its own client with a unique instance name. This ensures:
- Each tab has its own Gateway DO
- Notifications can target specific tabs
- Collaborative cursors are per-tab

## TypeScript Types

```typescript
import type { 
  LumenizeClient,
  LumenizeClientConfig,
  ConnectionState,
  Continuation
} from '@lumenize/mesh';
```

## Next Steps

- [Gateway Internals](./gateway) — How LumenizeGateway works
- [Auth Integration](./auth-integration) — Token handling patterns

