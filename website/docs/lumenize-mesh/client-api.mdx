---
title: Client API Reference
description: Complete LumenizeClient API documentation
---

# LumenizeClient API

Complete API reference for creating and using LumenizeClient instances.

## Creating a Client

Extend `LumenizeClient` to define methods that mesh nodes can call on your client:

```typescript
import { LumenizeClient } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  // Called by DocumentDO when content changes
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
  
  // Called for collaborative cursor updates
  @mesh
  handleCursorUpdate(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}

using client = new EditorClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${tabId}`,
  accessToken: jwt
});
```

**Why extend a class?** In a word, "consistency". All nodes in the Lumenize Mesh, including nodes hosted outside of Cloudflare (aka "clients"), are full peers that can make and receive calls. All Lumenize Mesh nodes are defined by extending the appropriate base class. Mesh nodes call methods on clients via `this.lmz.call('LUMENIZE_CLIENT_GATEWAY', clientId, ctn<YourClient>().yourMethod(...))`. You must define those methods on your subclass.

## Configuration

The `LumenizeClient` constructor takes a configuration object.

### Connection & Identity
- **`baseUrl`**: Base URL for WebSocket connection. (e.g., `wss://app.example.com`).
- **`instanceName`**: Your unique client identifier (becomes the Gateway DO name). Recommended format: `${userId}.${tabId}`.
- **`gatewayBinding`**: (Optional) Gateway DO binding name. Defaults to `LUMENIZE_CLIENT_GATEWAY`.

### Authentication
- **`accessToken`**: Initial JWT access token.
- **`refreshEndpoint`**: (Optional) Endpoint for token refresh using refresh token stored in a cookie. Defaults to `/auth/refresh-token`.

### Lifecycle Callbacks
- **`onConnectionStateChange`**: Called with `connecting`, `connected`, `reconnecting`, or `disconnected`.
- **`onConnectionError`**: Called when a connection-level error occurs.
- **`onSubscriptionsLost`**: Called when reconnecting after the grace period has expired (see [Subscription Loss](#subscription-loss)).

---

## The `lmz` API

The `this.lmz` property provides the same identity and communication API found in Durable Objects and Workers.

### Unique Client Behavior
*   **Automatic Connection**: The WebSocket connection is established as soon as the client is instantiated. You do not need to call `connect()` manually.
*   **Call Context**: `this.lmz.callContext` is only available during the execution of a method called by a remote node (an "Entry Point").

See the [Mesh Overview](/docs/lumenize-mesh/#the-thislmz-api) for the full `lmz` API reference.

### `connectionState`

Current connection state:

```typescript
readonly connectionState: ConnectionState;

// Example usage
if (client.connectionState === 'connected') {
  // Safe to make calls
}
```

## Instance Methods

### `ctn<T>()`
Create a type-safe continuation for building operation chains.

```typescript
// Build a continuation for a remote method
client.lmz.call(
  'DOCUMENT_DO',
  documentId,
  client.ctn<DocumentDO>().getContent(),
  client.ctn().handleContentLoaded(client.ctn().$result)
);
```

### `connect()` and `disconnect()`
The connection is automatically established upon instantiation and will reconnect during network disruptions or when the browser tab "wakes up" (e.g., the user returns to a backgrounded or suspended tab). Use `disconnect()` to manually close the connection. If the client is disconnected, calling `connect()` will manually re-establish the connection.

### Resource Cleanup
Use the `using` keyword for automatic resource cleanup. When the scope exits, the client will automatically disconnect.

```typescript
{
  using client = new EditorClient(config);
  // ...
} // disconnects here
```

## Making and Receiving Calls

The `LumenizeClient` enables full bidirectional communication. You can both make calls to the mesh and receive calls from other nodes.

### Receiving Calls
Define methods on your client class and decorate them with `@mesh`. These become **Entry Points** that other mesh nodes can call.

```typescript
class EditorClient extends LumenizeClient {
  // Called by a DO to push updates
  @mesh
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
}
```

### Making Calls
Use `this.lmz.call()` to communicate with server-side DOs, Workers, or even other clients provided you [override `onBeforeCall` to allow client-to-client calls](#opting-in-to-peer-communication).

```typescript
// 1. Fire-and-forget
client.lmz.call('DOCUMENT_DO', id, client.ctn<DocumentDO>().update(change));

// 2. With a local handler for the result
client.lmz.call(
  'DOCUMENT_DO', 
  id, 
  client.ctn<DocumentDO>().getContent(),
  client.ctn().handleContent(client.ctn().$result)
);

// 3. Chaining operations in one round trip
client.lmz.call(
  'DOCUMENT_DO',
  id,
  client.ctn<DocumentDO>().validate().save().getRevision()
);
```

## Access Control

LumenizeClient has the same **secure-by-default** model as DOs and Workers. See [Auth Integration: Access Control](./auth-integration#access-control) for full details.

### Implementing Access Control

- **Class-level `onBeforeCall`** — Override for class-wide policies (focuses on WHO has any access).
- **Method Exposure** (required) — Only methods decorated with `@mesh` are Entry Points.
- **Method-level `@mesh(handler)`** — Optional `handler` can enforce per-method policies (allows for some users to have different access).
- **Capability Trust** (automatic) — Once an Entry Point is authorized, the returned object's public interface is trusted for that call chain. So, only the handler for `isAdmin()` is checked when calling `isAdmin().doAdminOnlyThing()`.

### Default: Peer Calls Rejected

By default, `LumenizeClient` rejects calls from other clients (peer-to-peer calls). This is a security measure — most applications don't need client-to-client communication, and enabling it increases attack surface.

The base class implements:

```typescript
class LumenizeClient {
  // Default: reject peer-to-peer calls
  onBeforeCall(callContext: CallContext) {
    if (callContext.origin.type === 'LumenizeClient') {
      throw new Error('Peer-to-peer calls not allowed');
    }
  }
}
```

With this default:
- ✅ Calls from DOs and Workers are allowed
- ❌ Calls from other clients are rejected

### Opting In to Peer Communication

For collaborative features (e.g., direct peer-to-peer cursors, voice/video signaling), override `onBeforeCall` **and** decorate methods with `@mesh`:

```typescript
import { LumenizeClient, mesh } from '@lumenize/mesh';

class CollaborativeClient extends LumenizeClient {
  // Override: allow peer calls from known collaborators
  onBeforeCall(callContext: CallContext) {
    // Note: NOT calling super.onBeforeCall() because we WANT to allow peers
    if (callContext.origin.type === 'LumenizeClient') {
      // Allow peers, but only for authenticated users
      if (!callContext.originAuth?.userId) {
        throw new Error('Authentication required for peer calls');
      }
    }
  }
  
  // ✅ Exposed + Callable by peers
  @mesh
  handlePeerCursor(userId: string, position: Position) {
    this.cursors.set(userId, position);
  }
}
```

### Method-Level Access Control

Use the `@mesh(handler)` parameter for per-method checks:

```typescript
import { LumenizeClient, mesh } from '@lumenize/mesh';

class EditorClient extends LumenizeClient {
  // Class-level: allow calls from DOs only (default rejects peers)
  onBeforeCall(callContext: CallContext) {
    super.onBeforeCall(callContext); // Maintain peer rejection
    // additional custom logic...
  }
  
  // ✅ Exposed + Method-level check: only accept changes from our document
  @mesh((callContext, methodName, args) => {
    if (callContext.caller.instanceNameOrId !== this.documentId) {
      throw new Error('Change from unexpected source');
    }
  })
  handleDocumentChange(change: DocumentChange) {
    this.editor.applyChange(change);
  }
  
  // ✅ Exposed + Class-level check only
  @mesh
  handleNotification(message: string) {
    this.showNotification(message);
  }
}

## Error Handling

### Connection Errors
Handle network-level failures via `onConnectionError`:

```typescript
onConnectionError: (error) => {
  console.error('Network failure:', error.message);
  showOfflineBanner();
}
```

### Call Errors
Mesh calls return an `Error` object on failure. Check the type in your handler:

```typescript
handleContentLoaded(result: string | Error) {
  if (result instanceof Error) {
    if (result.message === 'Client not connected') {
      this.showOfflineMessage();
    } else {
      console.error('Call failed:', result.message);
    }
    return;
  }
  
  this.editor.setContent(result);
}
```

## Reconnection & Subscriptions

Lumenize handles the complexities of flaky mobile networks and tab hibernation automatically.

### Connection State Management
Use `onConnectionStateChange` to update your application UI:

```typescript
using client = new MyClient({
  onConnectionStateChange: (state) => {
    const isOnline = state === 'connected';
    const isPending = state === 'connecting' || state === 'reconnecting';
    updateUI({ isOnline, isPending });
  }
});
```

### Grace Period & Subscription Loss
When a client disconnects, the mesh maintains its state for a **5-second grace period**. If the client reconnects within this window, all subscriptions remain active.

If a client is disconnected for longer than 5 seconds, other mesh nodes may clean up resources. When the client eventually reconnects, it is notified that its subscriptions may have been lost via the `onSubscriptionsLost` callback. Best practice is to re-subscribe:

```typescript
class EditorClient extends LumenizeClient {
  onSubscriptionsLost = () => {
    // Re-establish mesh state after a long disconnect
    this.lmz.call('DOCUMENT_DO', this.documentId, this.ctn<DocumentDO>().subscribe());
  };
}
```

---

## Browser Considerations

### Tab Identity
Each browser tab should have its own `LumenizeClient` with a unique `instanceName`. This allows the mesh to target specific tabs for notifications and collaborative features. 

We recommend generating a `tabId` and storing it in `sessionStorage`:

```typescript
function getTabId(): string {
  let tabId = sessionStorage.getItem('tabId');
  if (!tabId) {
    tabId = crypto.randomUUID();
    sessionStorage.setItem('tabId', tabId);
  }
  return tabId;
}

using client = new MyClient({
  baseUrl: 'wss://app.example.com',
  instanceName: `${userId}.${getTabId()}`
});
```

### Hibernation and Backgrounding
It is not necessary to manually disconnect when tabs are hidden or hibernated. `LumenizeClient` automatically senses when a tab is "woken up" by the browser and will immediately attempt to re-establish the connection.

*   **Within 5 seconds**: The connection is restored seamlessly.
*   **After 5 seconds**: The connection is restored, and the `onSubscriptionsLost` callback is triggered to allow your UI to re-sync.
