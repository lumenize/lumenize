---
title: Lumenize Mesh
description: Durable Objects, Workers, and browser clients as peers in an actor-model network
---

# Lumenize Mesh

The **Lumenize Mesh** is an actor-model network where Durable Objects, Workers, and browser clients communicate as **true peers** via `this.lmz.call()`. While Cloudflare's native RPC is also actor-like, Lumenize Mesh adds critical security, race-condition safety, and de✨light✨fulness.

## Node Types

Every participant in the mesh extends one of these base classes:

| Node Type | Runs In | Storage | Use Case |
|-----------|---------|---------|----------|
| **LumenizeDO** | Cloudflare DO | SQL/KV | Stateful server-side logic |
| **LumenizeWorker** | Cloudflare Worker | None | Stateless server-side logic |
| **LumenizeClient** | Browser/Node.js | Local | Client applications |

Supporting infrastructure:

| Element | Type | Purpose |
|---------|------|---------|
| **LumenizeClientGateway** | Cloudflare DO | Bridges WebSocket clients ↔ mesh (zero storage) |
| **createLumenizeRouter** | Factory function | Creates Worker fetch handler with auth + gateway routing |

## Architecture

```mermaid
flowchart TB

    subgraph browserA[" "]
        ClientA[/"Client<br/><small>alice.tab1</small>"/]
    end

    subgraph cloud[" ☁️ Cloudflare "]
        direction TB
        
        subgraph mesh[" "]
            direction LR
            Workspace["Workspace<br/><small>acme-corp</small>"]
            Doc1["Document<br/><small>draft-1</small>"]
            Doc2["Document<br/><small>draft-2</small>"]
            Spell1(("SpellCheck"))
            Spell2(("SpellCheck"))
        end
        
        subgraph gatewaysA[" "]
            GwA(["Gateway<br/><small>alice.tab1</small>"])
        end
        
        subgraph gatewaysB[" "]
            GwB1(["Gateway<br/><small>bob.tab1</small>"])
            GwB2(["Gateway<br/><small>bob.tab2</small>"])
            GwB1 ~~~ GwB2
        end
        
        Workspace <--> Doc1
        Workspace <--> Doc2
        Doc1 <--> Spell1
        Doc2 <--> Spell2
        
        GwA <--> Workspace
        GwB1 <--> Workspace
        GwB2 <--> Workspace
        
        GwA <--> Doc2
        GwB1 <--> Doc2
        GwB2 <--> Doc1
    end

    subgraph browserB[" "]
        ClientB1[/"Client<br/><small>bob.tab1</small>"/]
        ClientB2[/"Client<br/><small>bob.tab2</small>"/]
        ClientB1 ~~~ ClientB2
    end
    
    GwB1 <-->|WebSocket| ClientB1
    GwB2 <-->|WebSocket| ClientB2
    GwA <-->|WebSocket| ClientA
    
    classDef workspaceDO fill:#6366f1,stroke:#4f46e5,color:#fff
    classDef documentDO fill:#a855f7,stroke:#9333ea,color:#fff
    classDef spellWorker fill:#10b981,stroke:#059669,color:#fff
    classDef gateway fill:#f59e0b,stroke:#d97706,color:#fff
    classDef client fill:#ec4899,stroke:#db2777,color:#fff
    classDef invisible fill:none,stroke:none
    
    class Workspace workspaceDO
    class Doc1,Doc2 documentDO
    class Spell1,Spell2 spellWorker
    class GwA,GwB1,GwB2 gateway
    class ClientA,ClientB1,ClientB2 client
    class mesh,gatewaysA,gatewaysB,browserA,browserB invisible
```

---

## Core Concepts

### Automatic Identity Propagation

Durable Objects don't inherently know their own binding name or instance name. However, any caller *must* know this information to make a call. Lumenize leverages this by including callee identity in every call envelope. Each node stores this information on first contact, enabling it to provide return addresses for callbacks.

```typescript @skip-check
// DocumentDO doesn't know it's "DOCUMENT_DO" / "draft-1" until someone calls it
// After the first call, it can tell other nodes: "call me back at DOCUMENT_DO/draft-1"
```

### Call Context

Every mesh call carries **context** that propagates through the entire call chain:

```
Client (alice) → DocumentDO → SpellCheckWorker
                     ↓              ↓
            callContext has    callContext has
            alice's auth       alice's auth (propagated!)
```

Access context in any mesh node via `this.lmz.callContext`:

```typescript @skip-check
@mesh
updateDocument(changes: DocumentChange) {
  const userId = this.lmz.callContext.originAuth?.userId;
  const caller = this.lmz.callContext.caller;
  // Make decisions based on who's calling
}
```

**Hibernation-safe** (for DOs): Call context is automatically captured in continuations. Even if a DO hibernates during a long-running operation, your handler receives the correct context when it executes.

See [Managing Context](./managing-context) for the full guide.

### Zero Trust Security

Every node is responsible for its own access control. Lumenize provides **secure-by-default** defense-in-depth:

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **Class-wide** | `onBeforeCall()` hook | WHO can call (auth, rate limiting) |
| **Entry Point** | `@mesh` decorator | WHAT is exposed (method allowlist) |
| **Capability Trust** | Automatic | Returned objects are trusted for that chain |

```typescript @skip-check
class DocumentDO extends LumenizeDO {
  // Class-level: require authentication for all calls
  onBeforeCall(callContext: CallContext) {
    super.onBeforeCall(callContext);
    if (!callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
  }
  
  // Entry point: exposed to mesh, can add method-specific checks
  @mesh((callContext) => {
    if (!callContext.state.user.canEdit) {
      throw new Error('Edit permission required');
    }
  })
  update(changes: DocumentChange) {
    // Safe to execute - auth and permissions verified
  }

  // NOT exposed - missing @mesh decorator
  #internalHelper() { /* ... */ }
}
```

**Key insight**: Only methods decorated with `@mesh` are entry points. Once authorized, the returned object's public interface is trusted for that call chain (capability-based trust).

See [Auth Integration](./auth-integration) for complete security documentation.

### Continuations

Continuations describe work to be done elsewhere or later. They enable type-safe, serializable method chains:

```typescript @skip-check
// Describe what to call on a remote DO
const remote = this.ctn<DocumentDO>().getContent();

// Describe what to do locally when the result arrives
const handler = this.ctn().handleContent(this.ctn().$result);

// Make the call
this.lmz.call('DOCUMENT_DO', 'draft-1', remote, handler);
```

Continuations:
- Are **serializable** — can be stored, sent over the wire, survive hibernation
- Are **type-safe** — TypeScript checks method names and signatures
- **Capture context** — `callContext` is automatically preserved

See [Continuations](./continuations) for the full guide.

---

## The `this.lmz` API

Every mesh node has access to `this.lmz` — the unified API for identity and communication.

### Identity

```typescript @skip-check
this.lmz.type           // 'LumenizeDO' | 'LumenizeWorker' | 'LumenizeClient'
this.lmz.bindingName    // e.g., 'DOCUMENT_DO' (auto-propagated)
this.lmz.instanceName   // e.g., 'draft-1' (auto-propagated, DOs only)
this.lmz.callContext    // Current request's context (during handler execution)
```

### Making Calls

```typescript @skip-check
// Fire-and-forget
this.lmz.call('DOCUMENT_DO', 'draft-1', this.ctn<DocumentDO>().update(changes));

// With response handler
this.lmz.call(
  'SPELLCHECK_WORKER',
  undefined,
  this.ctn<SpellCheckWorker>().check(content),
  this.ctn().handleResult(this.ctn().$result)
);
```

See **[Making Calls](./calls)** for all patterns including cost optimization and error handling.

---

## Getting Started

Ready to build? See the **[Getting Started Guide](./getting-started)** for a hands-on tutorial building a collaborative document editor.

## Reference Documentation

- **[Making Calls](./calls)** — All call patterns, cost optimization, error handling
- **[LumenizeDO](./lumenize-do)** — Stateful server-side nodes with SQL/KV storage
- **[LumenizeWorker](./lumenize-worker)** — Stateless server-side nodes
- **[LumenizeClient](./lumenize-client)** — Browser/Node.js client nodes
- **[Gateway Internals](./gateway)** — How client-mesh bridging works
- **[Auth Integration](./auth-integration)** — Authentication and access control
- **[Creating Plugins](./creating-plugins)** — Build your own NADIS services

## Concept Deep Dives

- **[Continuations](./continuations)** — How operation chains work under the hood
- **[Managing Context](./managing-context)** — Framework vs. application context
