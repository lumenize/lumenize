---
title: Making Calls
description: Patterns for mesh communication with this.lmz.call()
---

# Making Calls

Every mesh node communicates via `this.lmz.call()`. Any node type can call any other — DOs, Workers, and clients are true peers in the mesh. However, keep in mind:

- **Calling a Worker**: Use `undefined` as the `instanceName` parameter (every call to a Worker creates a new instance)
- **Calling a client**: The `bindingName` is always `'LUMENIZE_CLIENT_GATEWAY'` (unless you've customized it)
- **Client-to-client calls**: Disabled by default. See [Opting In to Peer Communication](./lumenize-client#opting-in-to-peer-communication) to enable.

## Basic Patterns

### Fire-and-Forget

Send a message without waiting for a response:

```typescript @skip-check
this.lmz.call(
  'DOCUMENT_DO',                          // Binding name
  'draft-1',                              // Instance name (undefined for Workers)
  this.ctn<DocumentDO>().notifyUpdate(change)
);
```

**Use when:** You don't need the result, or the callee will call you back separately.

### With Response Handler

Execute a local handler when the remote call completes:

```typescript @skip-check
this.lmz.call(
  'VALIDATION_WORKER',
  undefined,                                        // Workers have no instance
  this.ctn<ValidationWorker>().validate(data),      // Remote continuation
  this.ctn().handleValidationResult(this.ctn().$result)  // Local handler
);

handleValidationResult(result: ValidationResult | Error) {
  if (result instanceof Error) {
    console.error('Validation failed:', result);
    return;
  }
  this.applyValidation(result);
}
```

**Use when:** You need the result

**`await` under the covers:** Eventhough there is no await in the example, there is one under the covers. This will open input gates so another request can be initiated before the handler is called. It will also keep a DO in wall clock billing time. See the two one-way calls pattern below to avoid this. 

### With Additional Context

Pass extra data to your handler alongside the result:

```typescript @skip-check
this.lmz.call(
  'DOCUMENT_DO',
  documentId,
  this.ctn<DocumentDO>().getContent(),
  this.ctn().handleContent(documentId, this.ctn().$result, userId)
);

handleContent(documentId: string, content: string | Error, userId: string) {
  if (content instanceof Error) return;
  // documentId and userId are available alongside the result
  this.cache.set(`${userId}:${documentId}`, content);
}
```

**Use when:** Your handler needs identifying context, for instance, when you make the same call multiple times and need the handler to know for which call it is processing

---

## Cost Optimization: Two One-Way Calls

When a DO calls an external API, Cloudflare bills for **wall-clock time** — even while waiting for the response. For long-running calls, use the "two one-way call" pattern to shift the wait to a Worker (which only bills CPU time). This incurs additional request charges so the break even point is around 500ms. With the added latency and complexity, it's generally not worth it unless you have a lot of calls over 1 second in duration.

```typescript @skip-check
// In DocumentDO — initiates the call, returns immediately
@mesh
generateSummary() {
  const content = this.ctx.storage.kv.get('content');
  const clientId = this.lmz.callContext.caller.instanceName;  // Capture requesting client
  this.lmz.call(
    'LLM_WORKER',
    undefined,
    this.ctn<LlmWorker>().summarize(content, clientId)
  );
  // DO returns immediately — no wall-clock charges while waiting
}

// In LlmWorker — makes the slow LLM call, sends result back
@mesh
async summarize(content: string, clientId: string) {
  // Worker waits here — CPU-only billing, not wall-clock
  const summary = await this.callLlmApi(content);

  // Call back to the DO using callContext
  const caller = this.lmz.callContext.caller;
  this.lmz.call(
    caller.bindingName,
    caller.instanceName,
    this.ctn<DocumentDO>().handleSummary(summary, clientId)  // Pass clientId through
  );
}

// Back in DocumentDO — sends result to the requesting client
@mesh
handleSummary(summary: string, clientId: string) {
  this.lmz.call(
    'LUMENIZE_CLIENT_GATEWAY',
    clientId,
    this.ctn<EditorClient>().handleSummary(summary)
  );
}
```

### Variation: Worker Responds Directly to Client

Skip the return hop through the DO — the Worker sends results directly to the client:

```typescript @skip-check
// In DocumentDO — passes clientId, won't see the response
@mesh
generateSummary() {
  const content = this.ctx.storage.kv.get('content');
  const clientId = this.lmz.callContext.caller.instanceName;
  this.lmz.call(
    'LLM_WORKER',
    undefined,
    this.ctn<LlmWorker>().summarize(content, clientId)
  );
}

// In LlmWorker — sends result directly to client, bypassing DO
@mesh
async summarize(content: string, clientId: string) {
  const summary = await this.callLlmApi(content);

  // Send directly to the client
  this.lmz.call(
    'LUMENIZE_CLIENT_GATEWAY',
    clientId,
    this.ctn<EditorClient>().handleSummary(summary)
  );
}
```

**Trade-off**: Saves one hop, but the DO loses visibility into the response.

### Variation: Client Calls Worker Directly

For operations that don't need DO state, the client can call the Worker directly:

```typescript @skip-check
// In EditorClient — calls Worker directly
requestSummary(content: string) {
  this.lmz.call(
    'LLM_WORKER',
    undefined,
    this.ctn<LlmWorker>().summarize(content)
  );
}

// In LlmWorker — caller is the client, respond directly
@mesh
async summarize(content: string) {
  const summary = await this.callLlmApi(content);

  const caller = this.lmz.callContext.caller;
  this.lmz.call(
    caller.bindingName,   // 'LUMENIZE_CLIENT_GATEWAY'
    caller.instanceName,  // e.g., 'alice.tab1'
    this.ctn<EditorClient>().handleSummary(summary)
  );
}
```

**Trade-off**: Fewest hops, but bypasses DO entirely — no DO-level state access, Worker must be able to accomplish required auth, logging, etc.

---

## Operation Chaining

Chain multiple operations in a single round trip.

Chaining is particularly useful for the [Capability Trust](./security#capability-trust) pattern — get a restricted interface, then call methods on it:

```typescript @skip-check
// Only admins can get the admin interface; once granted, its methods are trusted
this.lmz.call(
  'DOCUMENT_DO',
  id,
  this.ctn<DocumentDO>().admin().forceReset()
);
```

All chained operations execute in a single round trip.

**Use when:** You have a sequence of operations that should execute on the callee, particularly when using capability-based access control.

---

## Operation Nesting

Nest operations so the result of one becomes the argument to another:

```typescript @skip-check
// Inner operations execute first, results feed into outer operation
this.lmz.call(
  'CALCULATOR_DO',
  'calc-1',
  this.ctn<CalculatorDO>().add(
    this.ctn<CalculatorDO>().add(1, 10),      // Returns 11
    this.ctn<CalculatorDO>().add(100, 1000)   // Returns 1100
  ),  // add(11, 1100) = 1111
  this.ctn().handleResult(this.ctn().$result)
);
```

All nested operations execute in a single round trip. The framework resolves dependencies and executes in the correct order.

**Use when:** You need to compose operations where outputs feed into inputs.

---

## Error Handling

Results can be `Error` — **always check before using**:

```typescript @skip-check
handleResult(result: SomeType | Error) {
  if (result instanceof Error) {
    // Handle failure
    console.error('Call failed:', result.message);
    return;
  }
  // Safe to use result
  this.processResult(result);
}
```

### Error Types

| Error | Cause |
|-------|-------|
| `MeshAccessError` | Method lacks `@mesh` decorator |
| Guard/`onBeforeCall` threw | Your access control code rejected the call |
| Method threw | Remote method threw an exception |
| Network/timeout | Connection issues, especially for clients |
| `ClientDisconnectedError` | Target client is not connected |

#### `MeshAccessError`

Thrown when a method lacks the `@mesh` decorator — a framework-level check for misconfigured entry points:

```typescript @skip-check
handleResult(result: SomeType | Error) {
  if (result instanceof MeshAccessError) {
    console.error(`Method '${result.method}' is not exposed on ${result.node.bindingName}`);
    return;
  }
  // ...
}
```

:::note Guard Errors Pass Through
Errors thrown by `@mesh` guards or `onBeforeCall` are **not wrapped** — they pass through unchanged. This preserves your domain-specific error types (e.g., `AuthenticationError`) so you can handle them appropriately.
:::

:::info Error Serialization
Errors are serialized/deserialized across the wire using `@lumenize/structured-clone`. The `message`, `name`, `stack`, and custom properties are preserved. Custom error subclasses can retain their type if [registered globally](/docs/structured-clone#errors-and-error-subclasses); otherwise they become plain `Error` objects (but still preserve `name` and custom properties).
:::

---

## Context Preservation

Call context (`this.lmz.callContext`) is available in your handler when using `this.lmz.call()`:

```typescript @skip-check
@mesh
triggerOperation() {
  const userId = this.lmz.callContext.originAuth?.userId;
  console.log(`User ${userId} triggered operation`);

  this.lmz.call(
    'VALIDATION_WORKER',
    undefined,
    this.ctn<ValidationWorker>().validate(data),
    this.ctn().handleResult(this.ctn().$result)
  );
}

// callContext is available in the handler
handleResult(result: ValidationResult | Error) {
  const userId = this.lmz.callContext.originAuth?.userId;
  console.log(`Validation completed for user ${userId}`);
}
```

:::warning Hibernation
If a DO hibernates while waiting for a response (possible during long-running calls), the in-flight call is lost — your handler never executes.

For hibernation-safe patterns:
- Use **[Two One-Way Calls](#cost-optimization-two-one-way-calls)** — the DO returns immediately, so there's nothing to lose
- Use **[@lumenize/alarms](/docs/alarms)** — persists continuations to storage with automatic context capture
:::

See [Managing Context](./managing-context) for the full context strategy.
