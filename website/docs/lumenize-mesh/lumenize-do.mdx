---
title: LumenizeDO
description: Stateful Durable Objects as mesh nodes with NADIS auto-injection
---

# LumenizeDO

`LumenizeDO` is the base class for **stateful mesh nodes** running as Cloudflare Durable Objects. It combines:

- **Mesh integration** — `this.lmz` API for identity and communication
- **NADIS auto-injection** — Zero-boilerplate service injection via `this.svc`
- **Access control** — `@mesh` decorator and `onBeforeCall()` hooks

## Installation

```bash @skip-check
npm install @lumenize/mesh
```

---

## Quick Start

```typescript @skip-check
import { LumenizeDO, mesh } from '@lumenize/mesh';

class UsersDO extends LumenizeDO<Env> {
  // Lifecycle hook for initialization (runs once, wrapped in blockConcurrencyWhile)
  async onStart() {
    this.svc.sql`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        email TEXT NOT NULL,
        created_at INTEGER NOT NULL
      )
    `;
  }

  @mesh
  addUser(email: string): { id: string; email: string } {
    const id = crypto.randomUUID();
    this.svc.sql`
      INSERT INTO users (id, email, created_at)
      VALUES (${id}, ${email}, ${Date.now()})
    `;
    return { id, email };
  }

  @mesh
  getUser(id: string) {
    const rows = this.svc.sql`SELECT * FROM users WHERE id = ${id}`;
    return rows[0];
  }
}
```

:::warning Don't Write Custom Constructors
Always use `async onStart()` for initialization — it's automatically wrapped in `blockConcurrencyWhile` so it's guaranteed to complete before the DO does anything else.
:::

---

## Mesh API

`LumenizeDO` shares the standard [Mesh API](./mesh-api) with all node types:

- **`this.lmz`** — Identity properties and `call()` for mesh communication
- **`@mesh` decorator** — Mark methods as mesh entry points
- **`onBeforeCall()`** — Class-wide access control hook
- **`this.ctn<T>()`** — Create type-safe continuations

See [Mesh API](./mesh-api) for full documentation.

### DO-Specific: Rate Limiting with Storage

DOs can use persistent storage for stateful access control patterns like rate limiting:

```typescript @skip-check
class ProtectedDO extends LumenizeDO<Env> {
  onBeforeCall(callContext: CallContext) {
    super.onBeforeCall(callContext);
    if (!callContext.originAuth?.userId) {
      throw new Error('Authentication required');
    }
    // DOs can use storage for rate limiting
    const key = `rate:${callContext.originAuth.userId}`;
    const count = this.ctx.storage.kv.get(key) ?? 0;
    if (count > 100) throw new Error('Rate limit exceeded');
    this.ctx.storage.kv.put(key, count + 1);
  }
}
```

See [Security](./security#access-control) for the complete security model.

---

## NADIS Auto-Injection

NADIS (Not A DI System) provides **zero-boilerplate dependency injection** via `this.svc`.

### How It Works

1. **Import a service package** — Side-effect import registers the service
2. **Use via `this.svc`** — Services are lazily instantiated and cached
3. **TypeScript knows** — Declaration merging provides full type safety

```typescript @skip-check
import '@lumenize/alarms';  // Registers alarms

class MyDO extends LumenizeDO<Env> {
  doSomething() {
    this.svc.sql`SELECT * FROM items`;  // ✅ Auto-injected
    this.svc.alarms.schedule(60, 'handler', {});  // ✅ Auto-injected
  }
}
```

### Available Services

| Package | Service | Purpose |
|---------|---------|---------|
| `@lumenize/mesh` | `sql` | SQL template literal tag (LumenizeDO only) |
| `@lumenize/alarms` | `alarms` | Alarm scheduling |
| `@lumenize/fetch` | `fetch` | Proxy fetch (cost optimization) |

:::note Logging
For debug logging, use the standalone `@lumenize/debug` package — see [Debug](./debug). It's not a NADIS service because it works cross-platform (Workers, Node.js, browsers).
:::

### Service: `sql` Template Literal

```typescript @skip-check
// SELECT
const users = this.svc.sql`SELECT * FROM users WHERE active = ${true}`;

// INSERT
this.svc.sql`INSERT INTO users (id, email) VALUES (${id}, ${email})`;

// UPDATE
this.svc.sql`UPDATE users SET email = ${newEmail} WHERE id = ${id}`;

// DELETE
this.svc.sql`DELETE FROM users WHERE id = ${id}`;
```

Parameters are automatically bound and SQL-injection safe.

### Service: `alarms` Scheduling

```typescript @skip-check
import '@lumenize/alarms';

// Schedule work
const schedule = await this.svc.alarms.schedule(
  60,           // Seconds from now
  'handleTask', // Handler method name
  { userId: '123' }  // Payload
);

// Cancel if needed
await this.svc.alarms.cancel(schedule.id);

// In your DO: delegate the alarm
async alarm() {
  await this.svc.alarms.alarm();
}
```

---

## Storage Patterns

### Synchronous Storage

Always use synchronous storage APIs:

```typescript @skip-check
// ✅ Correct - synchronous
this.ctx.storage.kv.put('key', value);
const value = this.ctx.storage.kv.get('key');
this.ctx.storage.kv.delete('key');

// ❌ Wrong - legacy async (never use)
await this.ctx.storage.put('key', value);
```

:::warning Compatibility Date
Requires `compatibility_date: "2025-09-12"` or later in wrangler.jsonc.
:::

### SQL vs KV

| Use Case | API |
|----------|-----|
| Simple key-value | `ctx.storage.kv.get/put/delete` |
| Structured/queryable data | `this.svc.sql` |
| Complex queries, JOINs | `this.svc.sql` |

### Keep Methods Synchronous

**Critical rule**: Keep mesh handler methods synchronous to maintain Cloudflare's consistency guarantees.

```typescript @skip-check
// ✅ Correct - synchronous
@mesh
updateUser(id: string, email: string) {
  this.svc.sql`UPDATE users SET email = ${email} WHERE id = ${id}`;
}

// ❌ Wrong - async breaks consistency
@mesh
async updateUser(id: string, email: string) {
  await somePromise();  // Input gate may close!
  this.svc.sql`UPDATE ...`;  // Race condition possible
}
```

**Exceptions** (these methods may be async):
- `fetch()` — HTTP handler
- `alarm()` — Scheduled tasks
- `webSocketMessage()`, `webSocketClose()`, `webSocketError()` — WebSocket handlers

---

## HTTP Handling

`LumenizeDO` receives mesh calls, but can also handle HTTP directly:

```typescript @skip-check
class MyDO extends LumenizeDO<Env> {
  async fetch(request: Request): Promise<Response> {
    // Check for mesh call first
    const meshResponse = await this.handleMeshRequest(request);
    if (meshResponse) return meshResponse;

    // Handle regular HTTP
    const url = new URL(request.url);
    if (url.pathname === '/status') {
      return new Response(JSON.stringify({ status: 'ok' }));
    }

    return new Response('Not Found', { status: 404 });
  }
}
```

---

## Testing

Test DOs using `@lumenize/testing`:

```typescript @skip-check
import { describe, test, expect } from 'vitest';
import { createTestDO } from '@lumenize/testing';
import { UsersDO } from '../src/users-do';

describe('UsersDO', () => {
  test('adds and retrieves users', async () => {
    const stub = await createTestDO(UsersDO, env);

    const user = await stub.addUser('test@example.com');
    expect(user.email).toBe('test@example.com');

    const retrieved = await stub.getUser(user.id);
    expect(retrieved.email).toBe('test@example.com');
  });
});
```

---

## API Reference

### Class: `LumenizeDO<EnvType>`

**Constructor:**
```typescript @skip-check
constructor(ctx: DurableObjectState, env: EnvType)
```
*Do not override — use `onStart()` for initialization.*

**Properties:**
- `ctx: DurableObjectState` — Cloudflare DO state
- `env: EnvType` — Worker environment bindings
- `svc: LumenizeServices` — Auto-injected NADIS services
- `lmz: LmzApi` — Mesh communication API

**Overridable Methods:**
- `onStart()` — Async initialization hook (runs once, wrapped in `blockConcurrencyWhile`)
- `onBeforeCall(callContext: CallContext)` — Hook for class-wide access control
- `fetch(request: Request)` — HTTP request handler

**Inherited Methods:**
- `ctn<T>()` — Create typed continuation builder
- `handleMeshRequest(request: Request)` — Process mesh call from HTTP

See [Mesh API](./mesh-api#api-reference) for shared types (`@mesh`, `CallContext`, `LmzApi`).

---

## See Also

- **[Getting Started](./getting-started)** — Build a complete app
- **[LumenizeWorker](./lumenize-worker)** — Stateless mesh nodes
- **[Creating Plugins](./creating-plugins)** — Build custom NADIS services
- **[Continuations](./continuations)** — Deep dive on operation chains

