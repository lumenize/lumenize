---
title: LumenizeDO
description: Stateful Durable Objects as mesh nodes
---

# LumenizeDO

`LumenizeDO` is the base class for **stateful mesh nodes** running as Cloudflare Durable Objects.

## Installation

```bash @skip-check
npm install @lumenize/mesh
```

---

## Quick Start

```typescript @skip-check
import { LumenizeDO, mesh } from '@lumenize/mesh';

class UsersDO extends LumenizeDO<Env> {
  // Lifecycle hook for initialization (runs once, wrapped in blockConcurrencyWhile)
  async onStart() {
    this.svc.sql`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        email TEXT NOT NULL,
        created_at INTEGER NOT NULL
      )
    `;
  }

  @mesh
  addUser(email: string): { id: string; email: string } {
    const id = crypto.randomUUID();
    this.svc.sql`
      INSERT INTO users (id, email, created_at)
      VALUES (${id}, ${email}, ${Date.now()})
    `;
    return { id, email };
  }

  @mesh
  getUser(id: string) {
    const rows = this.svc.sql`SELECT * FROM users WHERE id = ${id}`;
    return rows[0];
  }
}
```

:::warning Don't Write Custom Constructors
Always use `async onStart()` for initialization — it's automatically wrapped in `blockConcurrencyWhile` so it's guaranteed to complete before the DO does anything else.
:::

---

## Mesh API

`LumenizeDO` shares the standard [Mesh API](./mesh-api) with all node types:

- **`this.lmz`** — Identity properties and `call()` for mesh communication
- **`@mesh` decorator** — Mark methods as mesh entry points
- **`onBeforeCall()`** — Class-wide access control hook
- **`this.ctn<T>()`** — Create type-safe continuations

See [Mesh API](./mesh-api) for full documentation.

---

## NADIS Auto-Injection

NADIS (Not A DI System) provides **zero-boilerplate dependency injection** via `this.svc`.

### How It Works

Services are accessed via `this.svc`. Some are built-in, others require a side-effect import:

```typescript @skip-check
import '@lumenize/alarms';  // Side-effect import registers alarms

class MyDO extends LumenizeDO<Env> {
  doSomething() {
    this.svc.sql`SELECT * FROM items`;  // ✅ Built-in (no import needed)
    this.svc.alarms.schedule(60, this.ctn().handleTask({ id: 1 }));  // ✅ Requires import above
  }
}
```

### Available Services

| Package | Service | Import Required | Purpose |
|---------|---------|-----------------|---------|
| `@lumenize/mesh` | `sql` | No (built-in) | SQL template literal tag |
| `@lumenize/alarms` | `alarms` | Yes | Alarm scheduling |
| `@lumenize/fetch` | `fetch` | Yes | Proxy fetch (cost optimization) |

:::note Logging
For debug logging, use the standalone `@lumenize/debug` package — see [Debug](./debug). It's not a NADIS service because it works cross-platform (Workers, Node.js, browsers).
:::

### Service: `sql` Template Literal

```typescript @skip-check
const users = this.svc.sql`SELECT * FROM users WHERE active = ${true}`;
this.svc.sql`INSERT INTO users (id, email) VALUES (${id}, ${email})`;
```

Parameters are automatically bound and SQL-injection safe. See **[SQL Template Literal](./sql)** for complex queries, pagination, and standalone usage.

### Service: `alarms` Scheduling

```typescript @skip-check
import '@lumenize/alarms';

// Schedule with continuations (type-safe!)
const schedule = this.svc.alarms.schedule(
  60,  // Seconds from now
  this.ctn().handleTask({ userId: '123' })
);

// Cancel if needed
this.svc.alarms.cancelSchedule(schedule.id);

// Handler method
handleTask(payload: { userId: string }) {
  console.log('Task for user:', payload.userId);
}
```

No `alarm()` boilerplate required — LumenizeDO handles it automatically.

See [Alarms](/docs/alarms) for cron scheduling, recurring tasks, and advanced patterns.

---

## Storage Patterns

### Synchronous Storage

Always use synchronous storage APIs:

```typescript @skip-check
// ✅ Correct - synchronous KV
this.ctx.storage.kv.put('key', value);
const value = this.ctx.storage.kv.get('key');
this.ctx.storage.kv.delete('key');

// ✅ Correct - this.svc.sql uses synchronous ctx.storage.sql.exec under the covers
const users = this.svc.sql`SELECT * FROM users WHERE active = ${true}`;

// ❌ Wrong - legacy async (never use)
await this.ctx.storage.put('key', value);
```

:::warning Compatibility Date
Requires `compatibility_date: "2025-09-12"` or later in wrangler.jsonc.
:::

### Keep Methods Synchronous

**Critical rule**: Keep mesh handler methods synchronous to take advantage of DO's consistency model (input gates).

```typescript @skip-check
// ✅ Correct - synchronous read-modify-write
@mesh
addSubscriber(userId: string) {
  const subscribers = this.ctx.storage.kv.get('subscribers') ?? [];
  subscribers.push(userId);
  this.ctx.storage.kv.put('subscribers', subscribers);
}

// ❌ Wrong - async/await risks race condition
@mesh
async addSubscriber(userId: string) {
  const subscribers = this.ctx.storage.kv.get('subscribers') ?? [];  // ['alice']
  await somePromise();  // Input gate opens! Another call adds 'bob' → ['alice', 'bob']
  subscribers.push(userId);  // Our stale copy: ['alice', 'charlie']
  this.ctx.storage.kv.put('subscribers', subscribers);  // Overwrites — 'bob' is lost!
}
```

In the wrong example, the `await` opens the input gate, allowing another request to modify the array. When we `put` our stale copy, we overwrite changes made by the other request.

---

## Testing

Test DOs using `@lumenize/testing`. The key feature is **tunneling** — direct access to DO internals from your test:

```typescript @skip-check
import { it, expect } from 'vitest';
import { createTestingClient } from '@lumenize/testing';
import { UsersDO } from '../src/users-do';

it('adds and retrieves users', async () => {
  using client = createTestingClient<typeof UsersDO>('USERS_DO', 'test-instance');

  // Setup: pre-populate storage directly
  await client.ctx.storage.put('initialized', true);

  // Exercise: call methods via RPC
  const user = await client.addUser('test@example.com');
  expect(user.email).toBe('test@example.com');

  // Verify: inspect storage directly
  const rows = await client.ctx.storage.sql.exec('SELECT * FROM users').toArray();
  expect(rows).toHaveLength(1);
});
```

See **[@lumenize/testing](/docs/testing/usage)** for complete patterns including Browser simulation, WebSocket testing, and multi-instance scenarios.

---

## API Reference

### Class: `LumenizeDO<EnvType>`

**Constructor:**
```typescript @skip-check
constructor(ctx: DurableObjectState, env: EnvType)
```
*Do not override — use `onStart()` for initialization.*

**Properties:**
- `ctx: DurableObjectState` — Cloudflare DO state
- `env: EnvType` — Worker environment bindings
- `svc: LumenizeServices` — Auto-injected NADIS services
- `lmz: LmzApi` — Mesh communication API

**Overridable Methods:**
- `onStart()` — Async initialization hook (runs once, wrapped in `blockConcurrencyWhile`)
- `onBeforeCall(callContext: CallContext)` — Hook for class-wide access control

**Inherited Methods:**
- `ctn<T>()` — Create typed continuation builder

See [Mesh API](./mesh-api#api-reference) for shared types (`@mesh`, `CallContext`, `LmzApi`).
