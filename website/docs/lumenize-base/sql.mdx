---
title: "SQL Template Literal"
description: Type-safe SQL queries with automatic parameter binding
---

# SQL Template Literal

The `sql` template literal tag provides a clean, safe way to execute SQL queries against Cloudflare's embedded SQLite storage.

:::tip Core Utility
This is a small (~10 lines), universally useful utility from `@lumenize/core` that's automatically available via NADIS when using LumenizeBase.
:::

## Basic Usage

### Standalone Usage

```typescript @check-example('packages/core/sql/test/for-docs/basic-usage.test.ts')
import { sql } from '@lumenize/core';
import { DurableObject } from 'cloudflare:workers';

class ProductDO extends DurableObject {
  #sql = sql(this);

  constructor(ctx: DurableObjectState, env: any) {
    super(ctx, env);
    // Run migrations in constructor
    this.#sql`
      CREATE TABLE IF NOT EXISTS products (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        price REAL NOT NULL,
        stock INTEGER DEFAULT 0
      )
    `;
  }
```

### Using with LumenizeBase

When using `@lumenize/lumenize-base`, `sql` is automatically injected via NADIS:

```typescript @skip-check
import '@lumenize/core';  // Registers sql in this.svc
import { LumenizeBase } from '@lumenize/lumenize-base';

class ProductDO extends LumenizeBase<any> {
  constructor(ctx: DurableObjectState, env: any) {
    super(ctx, env);
    // Use this.svc.sql instead of #sql
    this.svc.sql`
      CREATE TABLE IF NOT EXISTS products (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        price REAL NOT NULL
      )
    `;
  }
}
```

See [@lumenize/lumenize-base documentation](/docs/lumenize-base) for complete NADIS examples.

## Template Literal Parameters

Parameters are automatically bound and SQL-injection safe:

```typescript @check-example('packages/core/sql/test/for-docs/basic-usage.test.ts')
  addProduct(id: string, name: string, price: number, stock: number = 0) {
    this.#sql`
      INSERT INTO products (id, name, price, stock)
      VALUES (${id}, ${name}, ${price}, ${stock})
    `;
    return { id, name, price, stock };
  }

  getProduct(id: string) {
    const rows = this.#sql`SELECT * FROM products WHERE id = ${id}`;
    return rows[0];
  }
```

The template literal tag:
1. Safely escapes all interpolated values
2. Prevents SQL injection attacks
3. Handles strings, numbers, and other primitive types automatically

## Query Results

The `sql` function returns an array of result rows. Each row is a plain JavaScript object with column names as keys:

```typescript @check-example('packages/core/sql/test/for-docs/basic-usage.test.ts')
  getLowStockProducts(threshold: number = 10) {
    return this.#sql`
      SELECT id, name, stock FROM products 
      WHERE stock < ${threshold}
      ORDER BY stock ASC
    `;
  }
```

Example return value:
```typescript @skip-check
[
  { id: 'prod-1', name: 'Widget', stock: 5 },
  { id: 'prod-2', name: 'Gadget', stock: 8 }
]
```

## Complex Queries

You can use the full power of SQLite:

```typescript @skip-check
// JOINs
const results = this.#sql`
  SELECT orders.id, products.name, orders.quantity
  FROM orders
  JOIN products ON orders.product_id = products.id
  WHERE orders.user_id = ${userId}
`;

// Aggregations
const stats = this.#sql`
  SELECT 
    COUNT(*) as total,
    AVG(price) as avg_price,
    SUM(stock) as total_stock
  FROM products
`;

// Updates
this.#sql`
  UPDATE products 
  SET stock = stock - ${quantity}
  WHERE id = ${productId}
`;

// Deletes
this.#sql`
  DELETE FROM products 
  WHERE stock = 0 AND last_updated < ${cutoffDate}
`;
```

## API Reference

### `sql(doInstance)`

Factory function that creates a SQL template literal tag bound to a Durable Object instance.

**Parameters:**
- `doInstance` - The Durable Object instance (typically `this`)

**Returns:**
A template literal tag function that executes SQL queries and returns an array of result rows.

**Example:**
```typescript @skip-check
const sql = sql(this);  // Create the tag
const rows = sql`SELECT * FROM users WHERE id = ${userId}`;  // Execute query
```

## Implementation Details

The `sql` template literal is **tiny** (~10 lines of code) and provides:

1. **Automatic parameter binding** - Interpolated values are safely bound as SQL parameters
2. **Direct storage access** - Uses `ctx.storage.sql.exec()` under the hood
3. **Array results** - Returns results as plain JavaScript arrays of objects
4. **Stateless factory** - `sql(this)` returns a bound function you can reuse

The implementation is a simple wrapper that:
```typescript @skip-check
// Simplified implementation (actual code is in @lumenize/core)
export function sql(doInstance: any) {
  return (strings: TemplateStringsArray, ...values: any[]) => {
    const query = strings.join('?');
    return [...doInstance.ctx.storage.sql.exec(query, ...values)];
  };
}
```

This pattern enables both standalone usage and automatic injection via NADIS.

## Why Use This?

**vs Raw Storage API:**
```typescript @skip-check
// ❌ Raw API - verbose, error-prone
const result = [...ctx.storage.sql.exec(
  'SELECT * FROM products WHERE id = ?',
  productId
)];

// ✅ SQL template literal - clean, safe
const result = sql`SELECT * FROM products WHERE id = ${productId}`;
```

**Benefits:**
- **Cleaner syntax** - Looks like natural SQL
- **Automatic binding** - No manual `?` placeholders
- **Type-safe** - TypeScript checks your template literals
- **SQL injection protection** - All values automatically escaped

## See Also

- [Cloudflare SQLite Storage](https://developers.cloudflare.com/durable-objects/api/storage/#sql) - Official storage API docs
- [@lumenize/lumenize-base](/docs/lumenize-base) - Auto-injection via NADIS
- [@lumenize/alarms](/docs/alarms) - Uses SQL for persistence








