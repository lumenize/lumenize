/**
 * Production Latency Measurement for proxyFetchWorker (Simplified Architecture)
 * 
 * This worker exports:
 * - OriginDO: Test DO that initiates fetches and measures latency
 * - FetchOrchestrator: Queue manager for dispatching to Workers
 * - Worker fetch handler: Handles both routing AND proxy-fetch execution
 */

import { DurableObjectState } from 'cloudflare:workers';
import { LumenizeBase } from '@lumenize/lumenize-base';
import { proxyFetchWorker, FetchOrchestrator as _FetchOrchestrator, handleProxyFetchExecution } from '@lumenize/proxy-fetch';
import '@lumenize/proxy-fetch'; // Register result handler

// Env is auto-generated by wrangler types
declare global {
  interface Env extends Cloudflare.Env {}
}

/**
 * Origin DO - Initiates fetches and measures latency
 * Uses hibernating WebSocket API for real-time result delivery
 */
export class OriginDO extends LumenizeBase<Env> {
  // Track batch metrics for scalability testing
  #batchMetrics: Map<string, {
    total: number;
    completed: number;
    successCount: number;
  }> = new Map();

  /**
   * Handle HTTP requests to this DO
   */
  async fetch(request: Request): Promise<Response> {
    // WebSocket upgrade
    if (request.headers.get('Upgrade') === 'websocket') {
      // Create WebSocket pair: [client, server]
      const webSocketPair = new WebSocketPair();
      const [client, server] = Object.values(webSocketPair);
      
      // Accept the server end (Durable Object side)
      this.ctx.acceptWebSocket(server);
      
      // Return the client end (caller side)
      return new Response(null, {
        status: 101,
        webSocket: client
      });
    }
    
    return new Response('Origin DO - Use WebSocket connection', {
      headers: { 'Content-Type': 'text/plain' }
    });
  }

  /**
   * Handle WebSocket messages (hibernating API)
   */
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    if (typeof message !== 'string') return;
    
    try {
      const msg = JSON.parse(message);
      
      if (msg.type === 'start-fetch') {
        const targetUrl = msg.url;
        const clientId = msg.clientId;
        const startTime = Date.now();
        
        // Create continuation that captures clientId and startTime
        const reqId = await proxyFetchWorker(
          this,
          targetUrl,
          this.ctn().handleFetchResultWithMetadata(clientId, startTime),
          { originBinding: 'ORIGIN_DO' }
        );
        
        const enqueueTime = Date.now() - startTime;
        
        // Send enqueue confirmation with clientId
        ws.send(JSON.stringify({
          type: 'enqueued',
          reqId,
          clientId,
          enqueueTime
        }));
      } else if (msg.type === 'start-batch-fetch') {
        const batchId = msg.batchId;
        const count = msg.count;
        const targetUrl = msg.url;
        
        console.log('[Batch] Starting batch', { batchId, count });
        
        // Initialize batch tracking (DO only tracks completion, not time)
        this.#batchMetrics.set(batchId, {
          total: count,
          completed: 0,
          successCount: 0
        });
        
        // Kick off all fetches in parallel
        for (let i = 0; i < count; i++) {
          const myId = crypto.randomUUID(); // Generate our own ID for tracking
          await proxyFetchWorker(
            this,
            targetUrl,
            this.ctn().handleBatchFetchResult(batchId, myId),
            { originBinding: 'ORIGIN_DO' }
          );
          console.log('[Batch] Dispatched fetch', { batchId, index: i, myId });
        }
        
        console.log('[Batch] All fetches dispatched', { batchId, count });
        
        // Send batch started confirmation (timing done by client)
        ws.send(JSON.stringify({
          type: 'batch-started',
          batchId,
          count
        }));
      }
    } catch (error) {
      ws.send(JSON.stringify({
        type: 'error',
        error: error instanceof Error ? error.message : String(error)
      }));
    }
  }

  /**
   * Handle WebSocket close
   */
  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {
    // Cleanup if needed
  }

  /**
   * Handle WebSocket error
   */
  async webSocketError(ws: WebSocket, error: unknown) {
    console.error('WebSocket error:', error);
  }

  /**
   * Handle batch fetch result (continuation for scalability testing)
   * Timing is done by Node.js client where clock works properly
   */
  async handleBatchFetchResult(result: Response | Error, batchId: string, myId: string) {
    console.log('[Batch] handleBatchFetchResult called', { batchId, myId });
    
    const batch = this.#batchMetrics.get(batchId);
    if (!batch) {
      console.error('[Batch] Batch not found:', batchId);
      return;
    }
    
    // Consume Response body (required)
    if (!(result instanceof Error)) {
      await result.text(); // Must consume the body
      batch.successCount++;
    }
    batch.completed++;
    
    console.log('[Batch] Batch status:', { batchId, myId, completed: batch.completed, total: batch.total });
    
    // Check if batch is complete
    if (batch.completed === batch.total) {
      console.log('[Batch] All fetches complete', { batchId, successCount: batch.successCount });
      
      // Broadcast completion (client measures total time)
      const sockets = this.ctx.getWebSockets();
      for (const ws of sockets) {
        ws.send(JSON.stringify({
          type: 'batch-complete',
          batchId,
          count: batch.total,
          successCount: batch.successCount
        }));
      }
      
      // Clean up
      this.#batchMetrics.delete(batchId);
      console.log('[Batch] Batch complete, cleaned up:', { batchId });
    }
  }

  /**
   * Handle fetch result with captured metadata (continuation)
   * The clientId and startTime are captured in the closure, not looked up
   */
  async handleFetchResultWithMetadata(result: Response | Error, clientId: string, startTime: number) {
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    // Get reqId from temporary storage (set by result handler)
    const reqId = this.ctx.storage.kv.get('__lmz_proxyfetch_result_reqid') as string;
    
    if (!reqId) {
      console.error('No reqId found in storage');
      return;
    }
    
    let resultData: any;
    if (result instanceof Error) {
      resultData = {
        type: 'result',
        reqId,
        clientId,  // From captured closure
        success: false,
        error: result.message,
        duration
      };
    } else {
      const text = await result.text();
      resultData = {
        type: 'result',
        reqId,
        clientId,  // From captured closure
        success: true,
        status: result.status,
        responseLength: text.length,
        duration
      };
    }
    
    // Broadcast to all connected WebSockets
    const sockets = this.ctx.getWebSockets();
    for (const ws of sockets) {
      ws.send(JSON.stringify(resultData));
    }
    
    this.ctx.storage.kv.delete('__lmz_proxyfetch_result_reqid');
  }
}

/**
 * Re-export FetchOrchestrator
 */
export const FetchOrchestrator = _FetchOrchestrator;

/**
 * Worker entry point - Handles both routing AND proxy-fetch execution
 */
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    console.log('[Worker] Request:', url.pathname);
    console.log('[Worker] Has PROXY_FETCH_SECRET:', !!env.PROXY_FETCH_SECRET);
    
    try {
      // Try proxy-fetch execution handler first
      const proxyFetchResponse = await handleProxyFetchExecution(request, env);
      if (proxyFetchResponse) {
        console.log('[Worker] Handled by proxy-fetch, status:', proxyFetchResponse.status);
        return proxyFetchResponse;
      }
      
      // Route all other requests to OriginDO (including WebSocket upgrades)
      const id = env.ORIGIN_DO.idFromName('latency-test');
      const stub = env.ORIGIN_DO.get(id);
      return stub.fetch(request);
    } catch (error) {
      console.error('[Worker] Error:', error);
      console.error('[Worker] Error stack:', error instanceof Error ? error.stack : 'no stack');
      return new Response(error instanceof Error ? error.message : String(error), {
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
}

